suppose two interface interface readable public read interface writable public write case implementing object support one lot case implementation support interface people use interface something like write without explicit casting readable myobject new myobject read without explicit casting writable myobject new myobject tight coupling actual implementation myobject myobject new myobject none option terribly convenient even considering want parameter one solution would declare wrapping interface interface extends readable writable one specific problem implementation support readable writable implement want compatible people using interface even though offer nothing apart guaranteed presence interface clean solution problem go wrapper interface update fact often necessary readable writable simply seperating concern argument always clean solution update2 extracted answer easier comment please beware primary usecase stream although must supported stream make specific distinction clear separation responsibility rather think something like bytebuffer need one write read one specific state attached object exist useful thing like asynchronous encoding one first thing tried suggestion given check accepted answer proved fragile suppose public rw extends readable writable rw call generic rw determined receiving need way describe var myobject myobject someinstance would work tie implementation may actually throw classcastexceptions runtime depending returned additionally want rw need define generic level