prehistory trying make statistical analysis experimental data arises measurement made ordinal scale faced problem rank aggregation get many individual ordering set object one collective ordering natural approach problem kemeny young method better look primary source surprisingly found program application method one c code allow weak ordering e allow case several object share position ordering previously asked point one two constructing needed code decide tell problem complicated thought first miss point since null mathematica programming description let r r r r n denote individual weak ordering n given object b c let consider r set ordered pair object b r usual interpretation ordered least good b r case b also r say ordered equally good case b r say ordered b b ordered introducing metric see possible neglect since make difference pair b b c c demonstrate ordering notation possible ordering n r b c b c r c b c b r b c b c c b r b b c c r b c b c r b b c c c r c c b b r c b c b r c c b b b r b b c b c r c c b c b r b c c b b c r b b c c b c c b notation may introduce metric delta called kemeny distance two ordering r r next way delta r r r setminus r r setminus r setminus mean set theoretic difference mean cardinality set e number element set finite required collective ordering called kemeny mean ordering given object minimizes sum square kemeny distance individual ordering e min sum n delta r fact may unique may several appropriate sum square kemeny distance equal minimal general case set attack several r input goal output look like brute force one one generating possible ordering calculating sum square kemeny distance input ordering verifiaction minimum even small n number possible ordering huge data case n possible ordering keep less data