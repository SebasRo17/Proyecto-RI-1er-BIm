modular programming reusable software routine around since early num earlier exist every programming language conceptually software library list program interface entry point exit point signature state applicable library high quality module focused solving narrow problem well defined interface cost amortized across future software program ever use library purely additive adding new module introduce bug limitation existing module software library solve problem write software merely composition high quality software module fix problem software library unleash full potential incredibly powerful mechanism writing high quality program faster problem intrinsic library never solved note several comment said many question please treat question real question everything follows point discussion software library widely used programming language c enormous software library numerous problem num well known language less ideal library support e g c lisp extent mitigated piggybacking virtual machine platform e g jvm clr corollary question future software written virtual machine platform increase library support problematic script want incur cost launching virtual machine every time num lot reinventing wheel ever written linked list module c yes course enjoy writing linked list c alternative num given library e g libfoo num num trusted basis write important software library tested documented implement feature need tell num learning library api time consuming learning whole new programming language num bug discovered library proper procedure fixing bug software bugfix distributed library user num library built distributed example autotools obviously got wrong semantic versioning good verified enforced num library dependency handled download install automatically version license compatible num license given library compatible software tell num library abandoned starting software starting software