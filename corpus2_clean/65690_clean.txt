understand solid supposed accomplish use regularly situation modularity important goal clearly useful however two thing prevent applying consistently across codebase want avoid premature abstraction experience drawing abstraction line without concrete use case kind exist foreseeable future lead drawn wrong place try modify abstraction line get way rather helping therefore tend err side drawing abstraction line good idea would useful find hard justify increasing modularity sake make verbose harder understand etc eliminate duplication find simple tightly coupled procedural god sometimes easier understand well factored ravioli flow simple linear also much easier write hand mindset often lead god object generally refactor adding clear abstraction line see clear pattern emerging anything wrong god object tightly coupled clearly need modularity significant duplication readable edit far individual solid principle meant emphasize liskov substitution imho formalization common sense applied everywhere since abstraction make sense also every single responsibility level abstraction though may high level implementation detail crammed one huge num num basically abstraction make sense choose abstract principle question case modularity clearly useful open closed interface segregation especially dependency inversion since modularity abstraction make sense