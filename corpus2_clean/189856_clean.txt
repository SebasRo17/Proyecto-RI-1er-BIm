recently attended online course programming language among concept closure presented write two example inspired course give context asking question first example sml produce list number num x x parameter fun x let fun count x else count num count num end sml repl val fn list num val num num num num num list us helper closure count capture us x context second example invoke create multiplier get back actually closure multiplies argument fun create multiplier fn x x sml repl fun create multiplier fn x x val create multiplier fn val create multiplier num val fn num val num num val num bound closure returned call use closure work properly throughout lifetime need extend lifetime captured example integer could far know sml made possible garbage collection closure keep reference captured later disposed garbage collector closure destroyed question general garbage collection possible mechanism ensure closure safe callable whole lifetime mechanism could ensure validity closure without garbage collection copy captured value store inside closure restrict lifetime closure cannot invoked captured variable expired popular approach edit think example explained implemented copying captured closure general captured variable e g bound large immutable list implementation would inefficient copy value sake completeness another example using reference side effect return closure containing counter initialized num incremented num time closure invoked fun create counter let create reference integer allocate integer let c point val c ref num fn c c num c end create closure contains c increment referenced time called val create counter sml repl val create counter fn unit unit val fn unit val num val num val num variable also captured reference still alive call created create counter completed