trying parallelize function paralleltable seems speedup good parallel kernel computer node version linux x bit november launchkernels kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local kernelobject local using documentation example get x speedup table pause f absolutetiming null paralleltable pause f absolutetiming null however code get x speedup hz c ht hz c n hbar x nx ex tx x ti piecewise ex hbar co x nx sin x nx tx nx tx true cf compile real real evaluate runtimeattributes listable table cf evaluate ti ti ti evaluate ht ht n ht developer packedarrayq absolutetiming true table cf evaluate ti ti ti evaluate ht ht n ht developer packedarrayq absolutetiming true paralleltable cf evaluate ti ti ti evaluate ht ht n ht developer packedarrayq absolutetiming true paralleltable cf evaluate ti ti ti evaluate ht ht n ht developer packedarrayq absolutetiming true question possible get x speedup using paralleltable second paralleltable get x speedup update mr wizard suggested useful discussion efficiently parallelize problem understand basic idea use parallelmap instead paralleltable tried approach turn result packedarray parallelmap x slower un parallelized table l tuples range ht ht n ht range ti ti ti developer packedarrayq l true map cf l developer packedarrayq absolutetiming false parallelmap cf l developer packedarrayq absolutetiming return kill running minute