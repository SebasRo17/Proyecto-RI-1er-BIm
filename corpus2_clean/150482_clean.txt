working project implement unit test new module quite clear architecture mind quickly wrote class method started writing unit test writing test make quite modification original making private method public order test adding extra method access private variable adding extra method inject mock object used run inside unit test somehow feeling symptom something wrong e g num initial design wrong functionality public beginning num designed properly interfaced unit test maybe due fact started design unit test quite class designed already num implementing unit test wrong way e g unit test directly test address public method api private one num mixture three point maybe additional issue thought since experience unit testing far guru would interested read thought regarding issue beside general question specific technical question question num make sense directly test private even make public order test assume indirectly tested unit test covering public method call question num instance contains instance b composite aggregation make sense mock b order test first idea mock b b instance part instance started doubt argument mocking b num b private wrt used implementation therefore mocking b seems like exposing private detail like num maybe problem indicate design flaw maybe use composite aggregation plain association b question num example decide mock b inject b instance idea inject b instance argument constructor instead creating b instance constructor pas bfactory interface argument constructor let use factory create private b instance use bfactory singleton private use static set singleton want create b instance us factory singleton set test scenario creates b directly singleton set production scenario first two alternative seem cleaner require changing signature constructor changing api make testable seems awkward common practice third one advantage require changing signature constructor change api less invasive requires calling static starting test imo prone implicit dependency call test work properly know one choose