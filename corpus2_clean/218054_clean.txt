let say wanted create list see spec implementation us complex subsystem database file system store act persistent collection rather memory one skeleton implementation implement list private return list possibly non empty public static getlist new public get index db gettable may throw add add etc problem lie fact underlying db api may encounter connection error specified list interface throw problem whether violates liskov substitution principle lsp paper lsp bob martin actually give example violates lsp difference newly specified exception determined inserted strengthening precondition case connection read unpredictable due external factor technically new precondition merely circumstance perhaps like outofmemoryerror occur even unspecified normal circumstance new exception might never thrown caller could catch aware possibility memory restricted program might specifically catch therefore valid argument throwing extra still claim valid util list pick sdk language collection general violation lsp edit argument might palatable consider reliable connection rather indeed violate lsp thus practically usable provided two less palatable alternative solution answer comment see footnote use case simplest case goal provide familiar interface case say database used persistent list allow regular list operation search sublist iteration another use case slot replacement library work basic list e g third party task queue usually work plain list new new arraylist start susceptible losing queue event crash replace new new start get instant persistence ability share task amongst one machine either case could either handle connection read exception thrown perhaps retrying connection read first allow throw crash program e g change