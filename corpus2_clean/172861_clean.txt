real world problem try abstract illustrative example imagine object tree parent object access child child access parent interface interface list child interface ichild parent class top middle middle bottom ichild top bottom ichild middle usage var top new top var middle top child list middle foreach var middle middle var middle child list bottom foreach var bottom var middle bottom parent access parent var top middle parent access grandparent three object property persisted two store e g database web service need reflect synchronise store object request web service write mapper favourite pattern access mapper completely separate object communication store public top fetchbyid id var top new top datastore id top child top top public middle fetchbyid id var middle new middle datastore id middle parent middle middle child bottom middle way one mapper per store build mapper want save back using mapper want circular reference guess problem language store memory reference object actually infinite problem every time want construct new top middle bottom need build entire tree within parent child property store request memory usage entail real life tree much bigger one represented problem request object request parent child middle private list bottom child cache public list bottom child get child child child set child think example repository pattern correct solution seems neat get requested store need thereafter stored want request avoiding request however two different source database also web service need able create web service save back database request database update web service also make uneasy object longer ignorant source introduced new dependency mention circular dependency making harder test object mask communication database solution solution could take care multiple store problem also mean need build request every time