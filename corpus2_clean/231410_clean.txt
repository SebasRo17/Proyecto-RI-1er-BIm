read article confused let imagine num webapp num distinct application acting worker sharing database oh said sharing article warns sharing database application service bad thing tempting put amorphous shared state know hugely coupled monster disagree case distinct application still part unit therefore notion coupling issue make sense case let continue webapp handle client http request may update time aggregate ddd term generating corresponding domain event goal worker would handle domain event processing needed job point event passed worker first solution read article promotes would use rabbitmq great message oriented middleware workflow would simple time web dyno generates event publishes rabbitmq feed worker drawback would nothing guarantee immediate consistency commit aggregate update publishing event without dealing potential sending failure hardware issue another issue example would possible event published without success aggregate update resulting event representing representation domain model could argue global xa two phase commit exists solution fit database middlewares could good solution ensure immediate consistency imo storing event database local transaction aggregate update simple asynchronous scheduler would created responsible querying current unpublished event database send rabbitmq turn populates worker needing extra scheduler webapp side way needing rabbitmq case solution appears logically rabbitmq could unnecessary especially database shared indeed whatever case saw immediate consistency involves polling database thus worker responsible directly polling therefore wonder many article web criticizes hardly database queuing promoting message oriented middleware excerpt article simple use right tool job scenario cry messaging system solves problem described polling efficient message delivery need clear completed message queue shared state immediate consistency ignored sum really seems whatever case meaning database shared need database polling miss critical notion thanks