problem imagine public api need kind collection something like foo b b kind collection far see three major kind collection least one used often num sequence order matter might duplicate num set order matter duplicate num map element key pair order matter duplicate key use b three case considered three alternative might list alternative list everything num foo c num foo c document duplicate num foo k c document duplicate key advantage client construct collection want returned list disadvantage num num duplicate guarantee client work get set map construction list num num might less efficient something like union set obviously faster list might construct intermediate list depends problem hand b concrete matching guarantee alternative precisely match guarantee giving num foo c maybe foo sequence seq c num foo set set c lazy strict num foo map map k c lazy strict advantage accurately describes guarantee want express client extra work disadvantage locked particular implementation want switch different set implementation break public api might good thing case switch lazy strict matter correctness calling general want able swap implementation without client noticing c let client decide alternative constrain let client decide concrete num foo sequence b c b num foo set b c b num foo map b c k b name used collection api really matter advantage client choose collection use disadvantage control collection construct anymore mean e g cannot assume laziness complexity insert another problem client get ambiguous type e g immediately fold returned collection fold foo whatever b ambiguous alternative would recommend want foo able different kind collection every call three case considered completely separate case question need x x sequence set map kind collection think