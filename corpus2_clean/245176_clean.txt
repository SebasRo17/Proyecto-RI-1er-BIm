designing kind parser thought would nice operator overload like operator rvalue val example collection foos foocollection public assume foo defined foo operator const foo val need assign foo foocollection c c num last resolve c operator num advantage operator comparison existing foo operator know rvalue assignment something could ordinary operator example tried design parse tree consisting polymorphic node minimal interface basic node node type inherited public virtual operator const op take almost action overloaded subclass take sensible action virtual operator return special pure virtual possible construct object one syntax element try parse like list may contain heterogenous value may integer public public operator return reference th element happen try assign something cell assigned concrete defined operator const op called action taken want know rvalue could possible deduce concrete rtti take sensible action subscript assignment operator could look like operator const val gettype provided return predefined enum underlying container hold pointer assume possible reference another subclass switch val gettype case new also may need delete new allocation process specific initialization break could use dynamic cast instead switch val gettype suppose kind assignment operator easily consistently built language moreover delimits piece execute expression lvalue rvalue usual subscript operator called subscription rvalue course proposed operator defined operator defined execute usual way question pitfall could miss operator included language break language consistency way bring ambiguity language