trying mathematica prototyping tool initial exercise put together brute force ray tracer view using mathematica built probability distribution function test fancy shaders starting point f ray tracer available first attempt using mathematica fancy calculator would welcome guidance critique whether coding style going effective detect code accustomed object oriented paradigm observation particular order enjoyable way work lot busy type definition additional syntax required language needed code quite compact intention fairly readable imho built ray tracer scratch without using built graphic primitive would defeat learning purpose exercise would probably able roll shaders simple example addition defined rgbcolor example probably consequence tracer slow even use kernel available dare say existing code could speeded considerably removing type pattern matching code would much harder follow think certainly much harder debug approach seems mean cannot take advantage compile optimization far see wanted fast ray tracer would write c wonder whether easy optimization missed involve mangling extent prototyping benefit mathematica easy refactoring would lost however surprised even kernel cpu core core count hyperthreading never max example worth changing thing would even slower aliased result averaging adjacent trace example real time ray tracing seems reach ray tracing result lot corner case dealt naturally ieee math unfortunately mathematica produce infinity example code really extended treat case properly would great mathematica built vector algebra could write equation defining object ray involved getting mathematica calculate ray intersection point heart ray tracer thing stand reduce solve helped find better intersection algorithm producing either nothing something large unintelligible depending posed problem anyway get raytrace basescene get code raytrace basescene code code colour helper black darkgrey grey white background black defaultcolor black brightness r g b mean r g b scale k c r g b k c zero mainly reference pattern matching normally used instead ray start ray ray dir ray camera po camera p l p camera lookat camera p l l camera forward camera p l normalize l p camera camera p l camera right c camera p l normalize cross forward c c camera c camera p l normalize cross forward c right c light po light p c p light color light p c c scene thing scene l c scene light scene l c l scene camera scene l c c surface diffuse surface ro surface specular surface ro surface reflect surface ro surface roughness surface ro ro intersection thing intersection r intersection ray intersection r r intersection dist intersection r miss intersection nothing ray zero zero infinity sceneobject surface sceneobject n sceneobject intersect sceneobject n sceneobject normal sceneobject n n sphere center sphere c r c sphere radius sphere c r r sphere surface sphere c r normal sphere center po normalize po center plane normal plane n n plane offset plane n plane surface plane n normal plane n n axis aligned bounding box todo yet used integrate tracer box lowerb box l u l box upperb box l u u extendby box l u pt box mapthread min l pt mapthread max u pt size box l u u l majoraxis b box l u ordering size b todo work case dir compnent mathematic return complexinfinity infinity intersectboxq b box l u r ray start dir module tl l start dir tu u start dir tmin tmax swap u l dir avoid erroneous result tmin max mapthread min tu tl tmax min mapthread max tu tl tmax tmin tmax use cover infinity comparison tmax false intersection tmax behind u tmin tmax false intersection true true interesection tmin intersect sphere center radius r ray start dir intersection currentdist module eo center start v dist disc v eo dir dist v disc radius radius eo eo v v disc v sqrt disc dist dist currentdist intersection r dist intersect p plane norm offset r ray start dir intersection currentdist module denom norm dir candidatedist denom candidatedist norm start offset denom candidatedist currentdist intersection p r candidatedist testray ray scene dist fold intersect ray miss thing scene traceray ray scene depth maxdepth shade fold intersect ray miss thing scene scene depth maxdepth shade miss background shade intersection thing ray start dir dist scene depth maxdepth module po dist dir start n reflectdir naturalcolor reflectedcolor n normal thing po reflectdir dir n dir n naturalcolor defaultcolor getnaturalcolor thing po n reflectdir scene reflectedcolor depth maxdepth grey getreflectioncolor thing po reflectdir n reflectdir scene depth maxdepth naturalcolor reflectedcolor getreflectioncolor thing po n rd scene depth maxdepth reflect surface thing po traceray ray po rd scene depth maxdepth getnaturalcolor thing po n rd scene module addlight normraydir normalize rd howrough roughness surface thing setattributes addlight listable addlight light p c module ldis p po livec neatisect isinshadow illum lcolor spec scolor livec normalize ldis neatisect testray ray po livec scene isinshadow neatisect norm ldis isinshadow defaultcolor illum livec n lcolor illum illum c defaultcolor spec livec normraydir scolor spec spec howrough c defaultcolor diffuse surface thing po lcolor specular surface thing po scolor defaultcolor total addlight light scene raytrace screenwidth screenheight scene basescene maxdepth module getpoint getpoint x camera recenterx x screenwidth screenwidth recentery screenheight screenheight normalize forward camera recenterx right camera recentery camera image parallelarray traceray ray po camera scene getpoint camera scene scene maxdepth screenheight screenwidth absolutetiming harness surface diffuse specular reflect roughness uniformsurface diffuse specular reflect roughness surface diffuse specular reflect roughness shiny uniformsurface white grey matteshiny uniformsurface white darkgrey checkerboard surface oddq floor floor white black white oddq floor floor basescene scene sphere shiny sphere matteshiny plane checkerboard light light camera illustrate going example one could generate mesh complex object polysphere polyspherepoints rad real divs integer u pi v pi du pi divs dv pi divs rad flatten table co du u co dv j v sin du u co du u sin dv j v j divs divs put polygon vertex right order ordervertices b c b c orderverticestotriangeles b c b c generate list polyspherepoint vertice number partition cyclically quad associate polygon polyspheremeshtriangles rad real divs integer normal graphicscomplex polyspherepoints rad divs map polygon map orderverticestotriangeles partition partition range divs divs polyspheremeshtriangles rad real divs integer normal graphicscomplex polyspherepoints rad divs map polygon map orderverticestotriangeles partition partition range divs divs would satisfying use geometric transform function built mathematica generate vertex life short graphic polyspheremeshtriangles generates polysphere trianges