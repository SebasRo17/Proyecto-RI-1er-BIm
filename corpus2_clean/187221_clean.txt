writing still year programming language change library change num num even num year ago might still produce expected result whereas num year might fail syntax partly inevitable since language evolve least developer responsibility maintain sometimes stability important requirement production simply num year without need someone going every year adapt language change might small script example scientific analysis need revisit touching year example office lot operational fortran even non speed essential part stability one reason heard fear instability one object moving apart language inertia course possible new dependent old course one strategy stable freeze entire operating system always feasible using example issue limited particular document compatibility issue case several document outlining policy backward incompatible change pep num according pep num must least one year transition period release transitional version release backwards incompatible version user least year test program migrate use deprecated construct alternative one personally consider one year rather short mean might write 1 year anymore pep num pep num contains incomplete list guideline thing avoided order maintain backward compatibility however relates num x num final release num x series num bugfix pep historical interest pep num also pep num backward incompatible change pep num draft official policy june num discussed idea mailing list part discussion focussed developer write robust language change one post listed advice along several rule infer probably time call stuff starting monkey patch anything use dynamic replacement object class depend depth inheritance hierarchy example base num base num make sure test without producing mindful potential namespace conflict adding attribute class inherit library think thing written one place though addition point mine field new feature likely change frozen area sold apis virtually guaranteed change quoting think frozen area defined positively explicit public apis explicitly guaranteed behaviour rather negatively explicit mine field otherwise forget put important thing minefield get bitten later need change thing backwards incompatible way seem conclusion thread get pretty close core looking thread almost four year old perhaps situation changed improved kind likely survive kind fragile porting guideline addition document outlined version come porting guideline porting num porting num etc useful compatibility pep num introduced concept useful compatibility word boil idea carefully written language developer need careful maintain compatibility really define useful compatibility think similar idea quoted pep num discussion programmer point view programmer know change future people notably try perhaps several year version one two perhaps three minor version everything compatible fact easy come fail encountered stating sys version num num wrong version exiting looking set guideline enhance chance still unaltered future guideline write still future question relates core standard library also commonly used add library particular numpy scipy matplotlib edit far two answer relate python2 v python3 mean know tool migrate python2 python3 question relates language change yet come better crystal ball finding coding guideline stable example import module future proof module import latter break module grows one new function class using undocumented method may less future proof using documented method something undocumented may sign something stable yet kind practical coding advice since present future limit python3 python2 going change anymore