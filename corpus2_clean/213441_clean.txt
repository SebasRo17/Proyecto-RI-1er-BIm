learning functional programming haskell meantime studying automaton theory two seem fit well together writing small library play automaton problem made ask question studying way evaluate state reachability got idea simple recursive algorithm would quite inefficient path might share state might end evaluating example evaluating reachability g exclude f checking path c digraph representing automaton idea algorithm working parallel many path updating shared record excluded state might great much seen simple recursion case one pas state argument pas forward list state gone avoid loop way pas list also backwards like returning tuple together boolean result although feel bit forced besides validity example case technique available solve kind problem feel like must common enough solution like happens fold map far reading com find consider touched monad yet interested posted