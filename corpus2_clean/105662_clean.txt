one thing never quite come term haskell polymorphic constant function whose cannot determined like foo foo reason like referential transparency haskell given always really read num num used context throw used say context yes argue read also taking parameter implicitness parameter make lose beauty opinion restriction one annoying thing haskell correct wrong whole reason mr computation look shared might parameter implicit defaulting one annoying thing haskell happens e g pas result function polymorphic function polymorphic correct wrong would necessary without function whose cannot determined polymorphic constant question running risk stamped discussion quesion would possible create haskell like language checker disallows kind definition would benefit disadvantage restriction see immediate problem say num integer num num check anymore current definition case think class functional dependency could come rescue yes know extension furthermore think lot intuitive function take different type function restricted type pas polymorphic value typing value like nothing seems like tougher nut crack thought good way handle doubt first person thought like anybody link good discussion haskell design decision pro con