first quick background eagerly learning wolfram mathematica two month along way written page teaching material ballooned computer science book sort available question wanted ask concern difference module block specifically used recursion googled wolfram documentation stackexchange place previously learned bunch stuff still entirely clear suppose try functional programming list manipulation standard textbook exercise implementing flatten flatten x list module result scan result join result flatten x result flatten x list x get correct result function try assume module always creates new version local symbol tacking dollar sign running number end symbol name despite fact documentation say module us lexical scoping seems done dynamically time module entered recursively different level recursion end differently named local variable cannot clash running tally modulenumber increasing one recursive call alternatively use block flattenblock x list block result scan result join result flattenblock x result flattenblock x list x understood exists one instance variable result shared level recursion time recursive block entered old value pushed internal stack popped moment block exited different level recursion end using separate value variable similar way recursion usually implemented imperative stack based language question outside advanced metaprogramming staying within realm recursion exercise traditionally seen computer science textbook exist simple situation module block used inside recursively defined function us define local variable represents intermediate result would produce different end result two always pretty much equivalent even recursion