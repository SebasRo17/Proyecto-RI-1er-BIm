question compiled listable parallel function work perfectly fine main kernel run parallel sub kernel detail first example let give first example compile function f mathbb r mathbb r simple sum sine function option compilationtarget c runtimeattributes listable parallelization true due listable attribute call function tensor parameter due parallelization value tensor processed parallel slow machine adjust n high f compile real compilationtarget c runtimeattributes listable parallelization true sum sin pi k k k data n table n f data looking system monitor calculation show processor running enter image description like compare speed execution instance f data hood may correct linux o x happens use compile c option shared library created mathematica code contains function called library stored folder specific process id specific kernel let make short function print important stuff compiled function extract compiledfunction information shared library placed type function additionally add kernelid processid printcfunclibrary holdpattern compiledfunction lib stringjoin kernelid tostring kernelid processid tostring processid tostring lib inputform using f get printcfunclibrary f kernelid processid libraryfunction home patrick mathematica applicationdata ccompilerdriver buildfolder lenerd compiledfunction compiledfunction real constant real please note build folder process id main kernel lenerd try execute different sub kernel see shared library function used stay kind expected paralleltry printcfunclibrary f f f f kind unexpected call f even sub kernel lose vector parallelization completely one processor working task paralleltry f data enter image description would expected calling compiled function compiled main kernel sub kernel clash whatsoever compiling function sub kernel since could explain behavior could surely imagine one shared library function maybe loaded one time best situation several process want access compile function sub kernel every sub kernel get copy shared library load version function parallelevaluate fsub compile real compilationtarget c runtimeattributes listable parallelization true sum sin pi k k k parallelevaluate printcfunclibrary fsub skip output see every sub kernel get copy shared library place folder named like process id sub kernel additionally main kernel exist function fsub therefore calling numeric value stay unevaluated hand parallelevaluate fsub calculates correct result try supply vector data compiled function sub kernel see processed parallel paralleltry fsub data tried several thing get insight behavior nothing really helped understand going might ask compiled function parallelized nicely pretty useless take second layer parallelization answer yes real problem case assume minimization problem parallelize target function still since minimization method run serially call target function parallel still much cpu time left case would reasonable run two minimization time