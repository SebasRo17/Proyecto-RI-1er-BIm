since internal bag internal stuffbag internal bagpart compiled precious source various application already many question appendto slow way exist make dynamically grow able array faster since inside compile many trick simply used instance case sow reap good alternative fast compiled version appendto comparison use appendto directly easy loop ignore fact would necessary since know number element result list real application maybe know appendto compile n integer module list n appendto list list using internal bag expensive since code list copied iteration case internal bag stuffbag compile n integer module list internal bag n internal stuffbag list internal bagpart list comparing run time function uncovers potential internal bag first absolutetiming appendto stuffbag usage feature following information collected different source article daniel lichtblau kind enough give insider information question mathgroup led conversation oleksandr rasputinov knew third argument internal bagpart various post stackoverflow exist mention explicitly restrict following usage internal bag compile together function internal bag internal stuffbag internal bagpart internal baglength first three compiled therefore one explicitly count element inserted bag needed use length element internal bag creates empty bag type real integer inserted converted real true converted false type bag possible see internal stuffbag b elm add element elm bag b possible create bag bag inside compile way easy create tensor arbitrary rank internal bagpart b give th part bag b internal bagpart b return list span operator used internal bagpart third argument used head returned expression variable internal bag general inside compile require hint compile deducing type bag integer declared list internal bag knowledge supported number type contain integer real complex example important property following example completely compiled call kernel using internal bag way likely speed thing famous sum gauss adding number note number explicitly added use third argument replace list head plus possible head inside compile plus time list sumton compile n integer module list internal bag n internal stuffbag list internal bagpart list plus sumton creating rank tensor creating inner bag directly inside constructor outer one tensor compile n integer integer module list internal bag j table internal stuffbag list internal bag table j j n table internal bagpart internal bagpart list n equivalent function insert every number separately tensor compile n integer integer module list internal bag elm internal bag j table elm internal bag table internal stuffbag elm j j internal stuffbag list elm n table internal bagpart internal bagpart list n position integer matrix position compile mat integer elm integer module result internal bag j table mat j elm internal stuffbag result internal bag j length mat j length first mat table internal bagpart po po internal bagpart result compilationtarget c runtimeoptions speed last example easily used measure timing kernel function time table block data randominteger n n transpose n n sqrt first absolutetiming data position position n listlineplot transpose time plot run time open question simpler way tell compiler type local variable bother really explained doc mentioned shortly define declare tensor user want empty tensor completely unintuitive use trick like declaring variable would one first thing need would new compile tutorial find hint feature bag may important know combination compile timing function position leak memory run n gb memory occupied investigated issue really deeply return list position memory seems ok actually memory returned position collected block finish system ubuntu mathematica