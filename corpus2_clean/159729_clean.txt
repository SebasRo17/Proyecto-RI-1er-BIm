created scenario two function b tested despite test still injected rather stupid bug getting database note orm present written crud operation directly paying price therefor scenario perl something like sub bunch work re b bunch work sub b record database result happened though higher level application changed one field go forgot change b test stub mock lot thing need meet goodly refactoring including b stub b verifies correct parameter including correct field name get passed test pass test b verifies old field name real b actually us old field name test pass well thus put production oversight putting null database want null clearly big isolate mock six different function could cause system state change thus test theoretically unconcerned strategy b store database even kind database b store think test probably query database directly changed format think test detected basically changed api without propagating change better way set test catch case beforehand continue isolation strategy b also write integration test way database would lead proliferation possible test case already trouble justifying existing test case proliferation management though know coverage woefully inadequate write test query database possibly abstraction something different would help ultimately took karl bielefeldt suggestion added validation b also added integration test test way db far tell need many integration test possibly verifying overall state system resource change predictably time expect still need mock network resource cannot actually get test network environment