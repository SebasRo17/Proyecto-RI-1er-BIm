like preface question similar question involve randomness finicky determinism answer use known seed really apply likewise question similar expecting algorithm ever fail know way correct question came testing graph algorithm mean limited algorithm multiple correct answer depending exact implementation may get one several answer equally correct make difficult test though know one going spit ahead time time consuming compute answer hand specific case got around modifying floyd warshall spit every possible shortest path spent time hand testing benefit good feature right could test function term known correct path fw returned path one path returned fw start end pair correct course work dense graph due fw work still nice however may always viable algorithm characteristic far best answer come test characteristic correct answer rather correct answer go back shortest path algorithm check cost returned path known right cost make sure path valid work risk verifying everything correctly criterion correctness especially verification complex e g correct algorithm exist verifying minimum spanning tree known hard problem probably harder constructing mst case extensively test testing worse presumably construct mst test mst verification algorithm great scenario mst test relies mst verification algorithm working mst verification algorithm test relies mst generation working finally cheap way involves observing verifying hand hard coding test test verified great idea since may revise test every time change implementation little automated testing supposed avoid obviously answer depends exact algorithm testing degree wondering best practice verifying algorithm several definite deterministic correct output precise correct output difficult know ahead time possibly hard even verify fact