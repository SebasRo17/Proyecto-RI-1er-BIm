provided image like test import run edgedetect canny shencastan sobel option convolve kernel form image approximate first order derivative indicate border significant sudden variation image wondering exists mechanism parallelizing edgedetect multiple core certainly seems like possible since heavy lifting computationally speaking less convolution process perhaps could decompose input image smaller chunk perform fast stitching post processing operation update cormullion comment make good point one decompose image many fragment core using imagepartition run edgedetect fragment stitch resultant edgedetect transformed image back together using imageassemble suppose one would use paralleltable trouble cormullion note dealing seam reconstituted assembled image also noted paralleltable really offer great speedup especially smaller image use larger image purpose example better way proceeding perhaps storing image memory let step cormullion suggestion cropped version image twelve core going try crop chop image twelve fragment clear adjust according number core machine first let grab image crop testimage import testimage imagecrop testimage variable test pixel crop original imported image let u break twelve pixel fragment remembering matrix time flatten output imagepartition imagefragmentset flatten imagepartition testimage compare flattenedimageset paralleltable edgedetect imagefragmentset length imagefragmentset absolutetiming edgedetect testimage absolutetiming result something like approx approx fold speedup better optimized stitch image together like reconedimage imageassemble partition flattenedimageset note need put front flattenedimageset neglect remove absolutetiming command problem one fix seam reassembled image fragment order match output edgedetect testimage