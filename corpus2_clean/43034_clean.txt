trying reduce computation time mcmc simulation essentially set particle performing random walk periodic random potential particle independent every timesteps perform check modify state particle seemed perfect case optimized parallelizing simulation whatever try always make thing little bit worse short detail first define random potential function u x interpolation simple discrete time random walk rw l accumulate randomvariate normaldistribution l myrw rw myrw rescale myrw ifun interpolation transpose range join reverse myrw myrw periodicinterpolation true u x ifun x two function needed perform single time step evolution particle potential metropolis hastings algorithm p x prop exp u prop u x mcmcevo x module prop prop randomvariate normaldistribution x return randomreal p x prop prop x function check state particle probability modifies performs time step evolution whole population return state particle function time step evolution populationevolve pop pdiv plife module newpop leave somefunctionofthestates sake completeness commenting setting newpop pop change anything timing newpop somefunctionofthestates pdiv plife pop return join mean u last nestlist mcmcevo randomreal newpop generate population one element one perform test pop table randomreal pop table randomreal try parallelized unparallelized calculation core ghz absolutetiming populationevolve pop absolutetiming table populationevolve pop absolutetiming paralleltable populationevolve pop proportion change even make populationevolve perform time step instead principle would expect ratio change favor parallelized version since ratio data exchanged kernel length computation change time step absolutetiming populationevolve pop absolutetiming table populationevolve pop absolutetiming paralleltable populationevolve pop experienced parallel calculation since sure interaction among parallel calculation bottleneck ever found passing much data back forth kernel seem case example missing would good way parallelize