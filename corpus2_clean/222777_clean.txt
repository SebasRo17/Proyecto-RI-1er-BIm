algorithm given sorted swap first unique element beginning duplicate end remaining stable unique subarray duplicate subarray run n swap preferably one pas length unique portion contrived example result using easy read num num num num num num num num num num already sorted r unique r num num num num num num num num num num num r sorted portion num num num num num r duplicate portion num num num num num stability mean even two key compare equal ordering key result persists e g j k j k original property hold whole running unique algorithm even though might unique subarray j k duplicate subarray failed attempt one pas track current unique element iterating next unique element swapped element end current unique subarray def unique1 len num num num j range num len j num j j j num swap first unique element sorted beginning run one pas n stable unique subarray satisfy requirement duplicate subarray num num num num num num num num num num r unique1 r duplicate part num num num num num sorted change algorithm make unique subarray somewhat obvious see happening duplicate subarray feeling could reversed knew stored information duplicate note sorting duplicate subarray non starter num n log n n num break stability also think another algorithm swap newly found unique item way next position would satisfy condition would n num swap unique algorithm possible