designed generic dao confusion whether refactor different design p say use already existing 3rd person framework know present learning design pattern need practice get confusion please ask clarify current architecture daofactory contains abstract method creation num interface implemented concrete implementation class public creating concrete factory producing concrete interface mentioned public abstract connection con tablename tablename primarykey throw sqlexception similarly interface generic method connection passed service layer closed transaction management tablename enum using switch case lower layer dao calling table specific function also using enum helping checking override public connection con tablename tablename primarykey throw sqlexception preparedstatement p resultset r try querystring querystring tablename primarykey read p con preparestatement querystring r p executequery r next tablename r finally daofactory p r implemented interface concrete lower layer dao talking basically contains switch case check specific table function call table specific function suppresswarnings unchecked static tablename tablename resultset r throw sqlexception switch tablename case master case master temp r case authenticate table r default table specific specifically schema specific layer producing required field public static resultset r throw sqlexception cur new cur setusername r getstring num cur setpassword r getstring num cur r getstring num cur service layer dao called pojo representing schema field e g con cur table primarykey pojo aka dto communicating controller service layer model please note giving overview simplest way num interface abstract daos containing total num abstract method implemented num concrete class generic class depend lower layer dao getting specific query preparedstatement etc call function auxiliary utility function depending tablename passed hierarchy bottom layer schema specific confusion refactoring satisfied upper layer dao think lower level specifically thing strong coupling weak coupling e g different method getting preparedstatement insert update turn switch case calling function lower utility although schema specific method tied together different utility class call coupling thinking whether change enum tablename contain specific state state thinking schema specific lowest level utility class specific state contained enums used change state dao dao call specific function based interface implemented state thus depending state behavior change automatically design decision correct would meaningless thing might overlooked thought design would lose safety introduced generic due change