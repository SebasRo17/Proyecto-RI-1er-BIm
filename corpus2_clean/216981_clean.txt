suppose parse tree abstract syntax tree control flow graph one logically derived one principle easy construct graph given parse tree manage complexity updating graph parse tree modified know exactly tree modified change propagated tree way become difficult manage naturally dependent graph updated simply reconstructing scratch every time first graph change would way knowing detail change dependent graph currently four way attempt solve problem one difficulty num node dependent tree observe relevant node original tree updating observer list original tree node necessary conceptual complexity become daunting num node original tree list dependent tree node specifically depend upon node change set flag dependent node mark dirty including parent dependent node way root change algorithm much like algorithm constructing dependent graph scratch skip clean node reconstructs dirty node keeping track whether reconstructed node actually different dirty node also get tricky num represent logical connection original graph dependent graph structure like list constraint perhaps designed using declarative language original graph change need scan list discover constraint violated dependent tree need change correct violation encoded num reconstruct dependent graph scratch though existing dependent graph compare existing graph new graph discover changed sure easiest way know algorithm available detecting difference quite computationally expensive principle seems unnecessary deliberately avoiding option right way deal sort problem surely must design pattern make whole thing almost easy would nice good solution every problem general description problem let elaborate trouble problem cause issue pop various place whenever two part project operate graph graph different representation thing change software running like making adapter interface instead wrapping single fixed number object need wrap entire graph arbitrary size every time try end confusing unmaintainable mess control flow observer difficult follow get complicated algorithm converting one graph another usually tricky enough follow laid plainly spread across multiple class problem seems way use plain straight forward graph conversion algorithm original graph changing naturally use ordinary graph conversion algorithm directly respond change way starting scratch alternative perhaps algorithm could written continuation passing style step algorithm represented node original graph like visitor algorithm assembled composing various simple visitor together another example suppose gui laid like might swing using jpanels layout manager simplify process using nested jpanels place complex layout manager end tree various container includes node exist layout purpose otherwise meaningless suppose tree used generate gui also used another part application instead laying tree graphically working library generate abstract representation tree system folder order use library need version tree layout node layout node need flattened parent node library still need notified time tree change though two version tree single structure another way look concept working mutable tree violates law demeter really violation law tree parse tree syntax tree normally case would problem since nothing would need kept date problem exists direct result violating law demeter avoid general domain seems manipulating tree graph composite pattern wonderful tool turning graph single obeying law demeter possible use composite pattern effectively turn one kind tree another make composite parse tree act like abstract syntax tree even control flow graph way without violating single responsibility principle composite pattern tends cause class absorb every responsibility touch perhaps could combined strategy pattern somehow