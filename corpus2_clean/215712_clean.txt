explaining combinator context haskell usually noted straight forward implementation check haskell recursive example rosettacode obvious definition combinator haskell canot used contains infinite recursive b defining mu allows recursion broken newtype mu roll unroll mu fix fix f x f unroll x x roll x f unroll x x indeed obvious definition check let fix f g x f x x x f x x g interactive num num occurs check cannot construct infinite t2 t2 t0 t1 expected t2 t0 t1 actual t2 t0 t1 t0 t1 first argument x namely x first argument f namely x x expression f x x interactive num num occurs check cannot construct infinite t2 t2 t0 t1 first argument x namely x first argument f namely x x expression f x x num sec num byte limitation exists ocaml let fix f g fun x f x x fun x f x x g expression b expression expected occurs inside b however ocaml one allow recursive type passing switch allow arbitrary recursive type checking default recursive type recursion go supported using everything work let fix f g fun x f x x fun x f x x g val fix b b b fun let fact partial n n num num else n partial n num val fact fun fix fact num num curious system inference raise question still able answer first checker come t2 t2 t0 t1 come guess problem t2 refers right side second perhaps interesting reason haskell ocaml system disallow guess good reason since ocaml also allow default even deal recursive type given switch really big topic appreciate pointer relevant literature