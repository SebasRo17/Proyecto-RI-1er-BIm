working design new system better start statically typed language like haskell dynamically typed language like ruby argument think static language quickly create specification scope program dynamic language quickly create working demo present customer review dynamic language often avoid rearrange structure refactor change design static language define type implementation keeping maintain small static language figure advance program dynamic language start writing let design grow organically paul graham say hacker painter programming language thinking program expressing program already thought static language help identify many type bug dynamic language begin testing finding bug sooner static dynamic typing advantage disadvantage far prototyping concerned however seem like equally valid approach based experience one ultimately better note prototyping natural language third language consider natural language instead prototyping one prototype writing customer read documentation critique design early cannot toy around working demo well written documentation make implementation language straightforward caveat documentation may tedious read difficult digest without able see speculate customer would rather experiment something work rather read wall text image prototyping application english rather definition verbose less concrete haskell type descriptive note type particularly descriptive haskell many static language like c example suppose signature haskell foo forall take list item return even without knowing know fact perform modify value well unless us incorrectly haskell purely functional cannot treat item say integer support use list throw exception go infinite otherwise would get therefore thing could possibly fail extract item list although still know item use tell everything else