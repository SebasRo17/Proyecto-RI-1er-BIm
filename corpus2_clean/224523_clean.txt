thinking structure cannot describe better word book exactly binder wondering already implemented library like boost others principle structure allows constant time random access amortized constant time insertion deletion long sequence performed index far away consists two stack left right representing state binder would open particular page inserting deleting element near page pretty fast since consists pushing popping page left stack flipping page necessary course worst case one would flip first page last page fill one stack example user insert something beginning something end rudimentary implementation c include iostream include vector using namespace std template book vector left right public inline size size left size right size push insert size get size left size left else right right size left size num insert size reposition num left push back remove size reposition left pop back protected reposition size put element position top left stack left size num right push back left back left pop back right size size left push back right back right pop back book b num num b push b insert num num b remove num num b size b get num num b remove else num b size cout b get cout endl num note possible nice optimization would two stack reverse order allow memcpy whole portion moved stack instead moving element one one memcpy usually much faster use good use case d would algorithm run sequence element index add new element remove old element near index particular case filtering element need iterate index simply call binder remove element index removed efficient optimal way given element would usually allocate another size copy element want save easy see amount operation binder implementation start first page difference binder allows simpler algorithm hiding dirty detail implementation end different thing get even messier implement need handle deletion close element mix deletion addition binder d encapsulated algorithm stay simple binder d seen vector sense c allows efficiently working content including working buffer one never allocate extra space hand help reduce dynamic memory allocation make whole mutation process transparent conclusion time tested conventional algorithm expect would little slower element access plain vector higher complexity two buffer instead one think good idea structure would prove efficient already done library better alternative propose