producer consumer implementation number consumer configurable form configurable throttling producer consumer kicked like var ct new var ct token task parallel invoke new cancellationtoken producer consumer producer action quite simple populates blockingcollection object derived system threading task task yes possible simplified example var num var producer new action random rnd new random datetime second ii num ii num ii var r rnd next num num add new task dummy task illustrative purpose writeline queued task starting set sleep num second id num r thread currentthread managedthreadid thread sleep r num writeline producer added task queue system threading thread sleep writeline exiting producer example creates anonymous task sleep random number second num num real producer poll database extract entity representing work item transforms executable task added collection consumer task us parallel start n instance anonymous action dequeues task collection start wait task repeat var num var consumer new action parallel num x action continue dequeue work item cancelled var take writeline consumer num taken task queue thread currentthread managedthreadid start wait num break writeline consumer num task wait elapsed thread currentthread managedthreadid writeline exiting consumer num thread currentthread managedthreadid question efficient way start operate arbitrary number consumer efficient way using plinq within consumer action continues execute queued task block still cancelled using note operated separately cancel token contained within queued task independently cancelable run within window service used cancel everything service stopped