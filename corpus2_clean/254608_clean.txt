cobol cics process running mainframe legacy system process 2k highly concurrent db environment crud operation result used make computation followed crud operation entire process run transaction block failure successful completion result entire set db change rolled back success every step process till end commit cobol program written manner consume num odd second completion failure lest process starve db resource lock stall etc due transaction commissioned expose legacy application soap web service three approach num service layer sends message queue parameter already existing cobol program pick message queue transaction layer ping queue asynchronously got result cobol process sends back controller num write stored procedure mimic job done cobol process including db transaction call sp service layer num write business logic inside service dao layer transaction inside spring transaction block business want num approach mean dependency legacy cobol program two doubt num understanding sps better performance point view sp able handle 2k odd within transaction block job time least equivalent time cobol process take yes efficient enough locking releasing db resource db highly concurrent want process starve due num never done db transaction magnitude doubt whether spring transaction block hold 2k single block effectively even sure match speed cobol sps hence may acquire lock record etc starve process need access long time transaction particular db table distributed num odd different table containing critical financial thinking breaking large number crud operation chunk spring transaction block would humongous task entire roll back logic alright concern locking process db access meanwhile developer meager knowledge rdbms practically knowledge cobol would grateful someone help point right direction come solution