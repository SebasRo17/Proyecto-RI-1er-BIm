lot thought went implementation set algorithm linq distinct except intersect union guarantee item returned order appear calling two expression item order var book select b b author orderby distinct var book select b b author distinct orderby implementation distinct would look something like public ienumerable distinct ienumerable source hashset set new hashset foreach item source set add item yield item implementation except would look like public static ienumerable except ienumerable source1 ienumerable hashset set new hashset foreach item source1 set add item yield item implementation intersect would look something like public static ienumerable intersect ienumerable source1 ienumerable hashset set new hashset hashset found new hashset foreach item source1 set contains item found add item yield item added second set remove duplicate list finally union little complex basically thing public static ienumerable union ienumerable source1 ienumerable hashset set new hashset foreach item source1 set add item yield item foreach item set add item yield item operation supported linq symmetrical difference playing around creating stable version algorithm pure curiosity wondering better implementation straight forward implementation call except twice public static ienumerable ienumerable source1 ienumerable var source1 except var except source1 concat although requires going list twice wrote version requires going second list twice public static ienumerable ienumerable source1 ienumerable hashset set new hashset hashset found new hashset foreach item source1 set contains item found add item yield item foreach item found add item yield item verified correctness algorithm ambiguity linq handle duplicate curious efficient way something better 2n