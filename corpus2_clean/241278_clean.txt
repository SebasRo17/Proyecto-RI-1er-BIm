working relationship creates tree structure many child b many child c etc lowest level call bar also point connected bar effectively make nearly every domain inter connected immutable object would problematic due expense rebuilding almost domain make single change one chose go interface approach every immutable interface publishes getter method controller object construct domain object thus reference full object thus capable calling setter method ever publishes immutable interface change requested go controller something like public interface public bar getbar public location getlocation public foo implement private bar bar private location location override public bar getbar bar public setbar bar bar bar bar override public location getlocation location public controller private map location foo foomap public addbar bar bar foo foo foomap get bar getlocation foo foo addbar bar foo felt basic approach seems sensible however speak others always seem trouble envisioning describing leaf concerned may larger design issue aware problematic domain object tightly coupled use quasi mutable approach modifying assuming design approach inherently flawed particular discussion left wondering approach presence business logic domain object currently setter method mutable object checking logic required verify make change suggested pulled service applies business logic simplify domain object understand advantage mocking testing general separation logic two class however service seems loose advantage polymorphism override base add new checking business logic seems polymorphic class complicated enough would end service check dozen flag decide checking business logic applies example wanted also size field compared bar adding par current approach would look something like public foo implement public addbar bar bar getlocation equal bar getlocation throw new bar bar public interface extends public getsize public extends foo implement private size override public getsize size override public addbar bar bar getsize bar getsize throw new super addbar bar colleague suggesting instead service look something like simplified service would likely complex public interface original interface presumably used method public location getlocation public boolean public interface implement public getsize public foo implement public bar bar override public addbar bar bar bar bar override public getsize default size size known num override public boolean public extends foo private size override public getsize size override public boolean public controller private map location foo foomap public addbar bar bar foo foo foomap get bar getlocation service foo bar returned foo public service public static foo foo bar bar foo foo getlocation equal bar getlocation throw new foo foo getsize bar getsize throw new foo setbar bar recommended approach using service inversion control inherently superior superior certain case overriding method directly good way go service approach loosing power polymorphism override behavior