trying solve variant knapsack changing money problem set number trying find linear integer combination close given value implemented brute force method generates possible combination max value sort find desired value using binary search leonid answer another question effort compile able speed workable hoping elegant efficient solution would scale better unlike common money changing problem interested closest value exact value care many possible combination calling function list value max value nmax return second function used search closest set within specified range makearray value nmax module countlist sum sorted countlist rest tuples range nmax length value sum dot value countlist sorted sort sum specific application duplicate desired remove custom compiled function relies sorted list although rare random data sorted pick sorted deleteduplicates sorted function desired delta window sorted desired delta desired delta helper function c compiler installed simply remove compilationtarget c bsearchmin list list elem module n n length list n n floor n n list elem list elem return list elem n n list elem bsearchmax list list elem module n n length list n n floor n n list elem list elem return list elem n n list elem window list xmin xmax minpos bsearchmax list xmin maxpos bsearchmin list xmax take list minpos maxpos memberq minpos maxpos window dot compile v real v real v v runtimeattributes listable parallelization true runtimeoptions speed sort compile real sort runtimeoptions speed compilationtarget c deleteduplicates compile v real block len length v output output table len len compile getelement v compile getelement v output output runtimeoptions speed compilationtarget c using code let start random list list randomreal solvef makearray list absolutetiming second workable solvef absolutetiming second basically instant