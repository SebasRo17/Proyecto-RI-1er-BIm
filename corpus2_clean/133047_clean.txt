current project succinctly involves creation random event basically generating schedule inspection based strict schedule constraint perform inspection week friday num 00am inspection random basic configurable requirement inspection must occur num time per week inspection must happen hour 9am two inspection within num hour period within whatever constraint configured particular set inspection resulting date time predictable unit test tdd imo great system used incrementally build full set requirement still incomplete make sure engineering thing currently know need strict schedule piece cake tdd however finding difficult really define testing write test random portion system assert time produced scheduler must fall within constraint could implement algorithm pass test without actual time random fact exactly happened found issue time though predictable exactly fell small subset allowable date time range algorithm still passed assertion felt could reasonably make could design automated test would fail situation pas given random result demonstrate problem solved restructuring existing test repeat number time visually check time generated fell within full allowable range anyone tip designing test expect non deterministic behavior edit thanks suggestion opinion seems need deterministic test order get deterministic repeatable result make sense created set sandbox test contain candidate algorithm constraining process process byte could long becomes long min max give algorithm several known byte array value num num num num start algorithm constrain num num using prime number ensure algorithm pas range resulting constrained value counted histogram produced pas input must reflected within histogram sanity ensure lose difference two bucket histogram cannot greater num really num stay tuned winning algorithm cut pasted directly production permanent test put place regression private min max func byte long long long var histogram new max min num num num stand prng produce known byte var buffer bitconverter getbytes long long result buffer min max histogram result min var num var maxcount num var total num num histogram length writeline num num min histogram num histogram histogram maxcount num maxcount histogram maxcount histogram total histogram assert areequal num total assert maxcount num test explicit sandbox test production public num num private long byte buffer long min long max strip sign bit significant byte converting long buffer buffer length num 0x7f var orig bitconverter toint64 buffer num var result orig apply bitmask removing msb fall range var mask long maxvalue result max min mask num result mask result min result test explicit sandbox test production public num num private long byte buffer long min long max strip sign bit significant byte converting long buffer buffer length num 0x7f var orig bitconverter toint64 buffer num var result orig bit shift number num place right fall within range result max min result num result min result test explicit sandbox test production public num num private long byte buffer long min long max buffer buffer length num 0x7f var result bitconverter toint64 buffer num modulo divide range produce fall within result max min num result min result result enter image description lsb rejection bit shifting number fall within range terrible easy explain reason divide number num less maximum quit soon non trivial range bias result towards upper third seen detailed result histogram exactly behavior saw finished date time afternoon specific day msb rejection removing significant bit number one time within range better large number bit evenly distributed unlikely get number upper lower end get bias toward middle third might benefit someone looking normalize random bell ish curve sum two smaller random number similar throwing dice would give natural curve purpose fails one passed test constrain modulo division also turned fastest three modulo definition produce even distribution possible given available input