learning problem messing around realised needed typeclass function operation applying composing etc reason num convenient treat representation applying implicitly us interpreter composing function derives new description num typeclass function derived typeclasses special kind function case want function example function apply integer offset could represented adt containing integer applying function mean adding integer composition implemented adding wrapped integer inverse integer negated identity wrap zero constant cannot provided suitable representation course need spell thing value genuine haskell function idea thought library like must already exist maybe even using standard spelling find typeclass haskell library found module typeclass common function also available prelude typeclass function useful think maybe fundamental problem idea biggest possible problem thought far application actual function would probably special cased avoid looping problem order apply need apply application need call application clue example show aiming language language language gadts first version doable one argument f version seemed needed support seems work also seems strange particular composition b c yet nothing special c compared b doable f b f b b f b c f b f c first version needed constraint doable f b either version make sense doable f b doable f b undoable f b f b f b f b b f b f b original adt making sure could wrap pair function really mistake b b b instance doable b f g f g g f instance undoable b f f f making one work led extension representation represent certain function seem need typeclass argument also need restrict case happen hence gadt gadt one constructor still seems odd perhaps surprisingly toy except whole thing toy really one real case need exercise still simple special case though b instance doable x x x x instance undoable x x x x constructing function x shorthand subtraction whoop x x x x x div x possible define break law prevent need constructor private public ops preserve law already always validate undoable f b eq f b bool validate f x f f x x validating multiply zero show flaw validate plan must try harder putstrln show validate num num putstrln show validate num num putstrln show validate num num num num putstrln num show num putstrln num show num putstrln num show num putstrln num show num application involves kind unification unified value equal related via function prolog style logic f b constraint rather b composition result optimizing union find structure need inverse obvious item unified set exact particular item quantified relative another item unified set want use real function computing relative value could drop whole aspect absolute relative quantity probably need number vector inner architecture astronaut want fun way break link apart via backtracking everything pure union find done using key intmap pointer simple union find working added function yet point listing reason use applicative monad arrow etc operation need abstraction provide application composition sound familiar e g applicative monad arrow composition function however type implement abstraction case contain structure represents contain represent limited set function mentioned explanation sometimes quantify one item relative another item unified cluster exact want able derive representation general composition several provided function walking common ancestor union find tree several inverse function walking back item simple case original function limited integer offset function want composed result integer offset add component offset big part composition need well application mean cannot provide operation pure arr type use applicative monad arrow failure type mismatch abstraction abstraction want simple pure side effecting example need build convenient notation sequencing composing function equivalent standard applies function could instance category confident thing able provide identity though probably need category support application still need derived anyway add operation