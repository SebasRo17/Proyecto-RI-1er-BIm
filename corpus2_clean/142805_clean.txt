made given signal using transform basically normalised gaussian signal follows importing relevant library future import division scipy signal import import numpy np def smooth func sig x num n len x x1 x num x0 x num defining new symmetric around zero make gaussian symmetric np x1 x0 num x1 x0 num n gaussian centered around zero np exp num using speed sum normalization constant sig sum mode say step corner boundary interprets another corner result giving unnecessary behaviour boundary explain figure shown image problem arise directly integrate find hence problem transform hence problem scipy understand problem arises first need understand working scipy basically us theorem speed computation short say int1 int2 fft int1 fft int2 directly apply theorem dont get desired result get desired result need take fft double size max int1 int2 lead undesired boundary effect fft size greater size take fft zero pad take fft zero padding exactly responsible undesired boundary effect suggest way remove boundary effect tried remove simple trick signal original signal near boundary dont match replace func signal point follows num eps 1e num ab smooth sig eps signal left boundary smooth sig num j num ab smooth j sig j eps right boundary smooth j sig j j j num problem using epsilon small jump change made solve boundary problem