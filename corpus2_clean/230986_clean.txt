clarification rule meant prevent accessing variable declared yet clarification num rule mandate follows call function defined scope call happen actual definition forward referencing making much alike interpreter thinking fictional programming language behaves similar javascript declaring function using keyword create named function get top scope used anywhere visible example following legal f f log f called however potential problem f us x defined call like f var x num f log x case javascript also legal variable well program get essentially transformed something like var x f log x f x num therefore print undefined fictional language variable get mean example would produce rule concern generated function visible entire block defined illegal call access declared call mean time language would encounter call would check defined current scope check access variable current scope declared call reason rule make sense access variable declared hoisting variable top scope like javascript hack leaf room believe must done situation detected treated error referencing something chronologically exist yet looking reason bad rule e result complication inconsistency reason suspect rule bad one exist scala language scala solved problem much general rule scope introduced declaration definition whole statement sequence containing binding however restriction forward reference block statement sequence num n making block simple refers entity defined j j k including j k cannot definition k definition must lazy update time adopted scala approach approach general version rule catch illegal access also tradeoff willing make since think rule may complicated even impossible implement rephrased explained rule scala variable cannot forward referenced lazy value function defined def syntax sugar lambda assigned lazy value might even remove doval suggested class module restriction reference declaration inclusive must definition might altered entity referenced introduced program