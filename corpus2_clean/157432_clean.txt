learning clojure see something leverage current job importantly convince boss clojure killer feature make worth feature guessing clojure evangelist would tout state management concurrency example see often blog book account balance updated multiple thread clojure state management always cleanly ensure balance accurate regardless number thread reading writing practice though application would never allow account balance live memory would persisted outside jvm probably database two hopefully obvious reason num app go database need accurately reflect latest state recovery reason database cannot asynchronously updated read would block database update complete num application reading manipulating account balance maybe scaled app several server balance would need kept sync instance clojure state management handle situation like elegantly instance given scenario num read account balance would first need check database get database locked would block correct available great clojure handle memory concurrency elegantly elegance extended external state really gain anything num note thing like expressiveness elegance etc rarely considered killer feature mgmt