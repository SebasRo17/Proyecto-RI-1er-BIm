currently refactoring application periodically downloads content various source ftp sql etc schedule control time application active example download content 8am application written oriented language c general design came first iteration first iteration design scheduler responsible keeping general schedule start downloading start scheduled period stop end scheduler contains number itask implementation bit downloading created abstract base implementation periodically call protected abstract subclass task implement worry timing scheduling far good tdd ing task baseclass realised actually difficult mock behaviour task timer tick call finished previous download iteration since implementation detail hard mock made wonder task actually violating single responsibility principle taking care periodical invocation responsible actual downloading came separated design second iteration design responsibility task limited periodically calling client client responsibility downloading content testing task easier inject mock task download num num relationship task performs one download speak practice task instance added single scheduler instance started stopped wonder actually clearer design though task seems bit odd single implementation without subclass guy think