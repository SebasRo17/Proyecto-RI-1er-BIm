currently reading benjamin c pierce type programming language really getting theory explains lambda calculus evaluation strategy bit confused explanation call v call context two strategy explained following manner call like normal order chooses leftmost outermost redex first restrictive allowing reduction inside abstraction example id id z id z id z id z z id z call outermost redexes reduced redex reduced right hand side already reduced term finished computing cannot reduced example id id z id z id z id z z id z identical call evaluation ok far good followed following paragraph call strategy strict sense argument function always evaluated whether used body contrast non strict lazy strategy call call need evaluate argument actually used know call call mean practically used among others c haskell cannot see evaluation strategy explained lead lambda calculus additional rule always accompany call follow reduction strategy outlined especially since reduction step example identical fail see difference two strategy would love someone could help gain intuition