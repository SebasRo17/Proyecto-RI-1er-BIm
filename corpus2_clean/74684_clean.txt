according answer question good reason always starting failing test red make sure test working written make test pass paraphrase since appears ability write test written kind mental everyone would sufficient write first write test revert change see test fail without change suppose could automated kind ide integration would alternate form tdd development environment tdd enforced ide framework strict mechanical rule enforcement limit developer option optimization example might useful suppose module unit test already completed working correctly want introduce refactoring would improve performance unknown amount reducing number internal call without fundamental change external behavior module know much benefit would get refactoring write test without failing test allowed modify seems chicken egg problem allowed write dummy test simply capture number internal call old new modify refactoring update test refactoring successful reducing number internal call assert number internal call reduced afterthought although performance test lesser importance requirement unit test would like keep benefit efficient change functional requirement want others refactor away benefit based assumption functional requirement would broken however change functional requirement possible meet current performance level functional requirement met first new performance target would set experimentation disclaimer never done strict tdd skeptical although test soon coding several month change question appear post tdd development since occurs well functional requirement met test place therefore long original tdd unit test continue pas change considered tuning