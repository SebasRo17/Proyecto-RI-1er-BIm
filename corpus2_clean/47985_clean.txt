interested efficient way transform huge rectangular array sparse array structure consider numeric rectangular table rather sparse zero position set null rather save time memory fill problem sparsearray function directly applied kind table first every null replaced seen following example q matrix dimension qxq f p p primeq p p null specific form matrix element chosen illustrative purpose mat paralleltable f p p p q p q matrix later compressed sparsearray mat mat null replace null zero sparse sparsearray mat sparsearray may applied however replacement procedure bytecount mat dramatically increased sufficiently large q one run memory besides seem logical artificially inflate matrix order able compress afterwards transform huge rectangular array full null sparse array structure without replacing null zero thank p way form sparse array aware getting speed memory inefficient q taken large say q e g way sparsearray flatten paralleltable p p f p p p q p q null sequence take gb memory form sparse array gb p p one could ask need compress matrix already quite sparse sparsearray version take less memory anyway bytecount sparse less bytecount mat p p p toy problem realistic code follows compiledfunctiontools compiler ccompileroptions systemcompileoptions fpic ofast march native compile noinfo n number electron upp upp upper occupied quantum state subset range upp n set many particle state q binomial upp n number many particle state fast compiled function compare two vector return position different element vectorcompare compile v integer v integer block internal bag internal bag run along list recording difference go length v length v v v internal stuffbag v v internal stuffbag true fix case ran end one list length v internal stuffbag length v internal stuffbag internal bagpart internal bagpart compilationtarget c compilationoptions expressionoptimization true inlineexternaldefinitions true runtimeoptions speed runtimeattributes listable parallelization true comparematrix sparsearray developer topackedarray paralleltable p p vc vectorcompare p p diff length flatten vc diff vc vc diff vc vc vc vc p q p q null array need could built without unnecessary zero running following code cmb internal bag cmb internal bag vc vectorcompare p p l length flatten vc l internal stuffbag cmb p p vc vc l internal stuffbag cmb p p vc vc vc vc p q p p q parallelizable edit fastest memory efficient solution follows cm join parallelmap developer topackedarray table vc vectorcompare p p diff length flatten vc diff empty diff p p vc vc vc vc true p p vc vc p q p p q essence close question