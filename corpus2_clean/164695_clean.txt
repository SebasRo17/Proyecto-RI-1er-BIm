factory creates object x instance x large purpose factory cache transparently client possible object x immutable following seems reasonable module py import x registry def get x self arg1 arg2 use cache use cache hash id hash arg1 arg2 hash id registry registry hash id obj x x arg1 arg2 registry hash id obj obj module x py x good pattern know actual factory pattern anything change find sometimes want cache x object disk use pickle purpose store value registry filename object instead reference object course registry would stored persistently perhaps pickle file text file database simply giving pickle file filename contain hash id except validity cached depends parameter passed get x also version created object strictly speaking even memory cached could become invalid someone modifies x py dependency reloads program running far ignored danger since seems unlikely application certainly cannot ignore object cached persistent storage suppose could make hash id robust calculating hash tuple contains argument arg1 arg2 well filename last modified date x py every module file recursively depends help delete cache file ever useful add registry unhashed representation modified date record even solution num safe since theoretically someone might load module dynamically know statically analyzing source go assume every file project dependency mechanism still break module grab external website etc addition frequency change x py dependency quite high leading heavy cache invalidation thus figured might well give safety invalidate cache obvious mismatch mean x would level cache validation identifier changed whenever developer belief change happened invalidate cache multiple developer separate invalidation identifier required identifier hashed along arg1 arg2 becomes part hash key stored registry since developer may forget update validation identifier realize invalidated existing cache would seem better add another validation mechanism x return known trait x instance x table might add name column hash calculation include trait well write afraid missing something important also wondering perhaps framework package stuff already ideally like combine memory disk based caching edit may seem need served well pool pattern investigation however case thought list difference num used multiple client pool need checked checked longer needed precise mechanism may complicated yes object immutable used infinitely many client never need create second copy num pool size need controlled pool often yes strategy may quite complicated must delivered demand client existing unsuitable new one need created num object freely substitutable pool yes object typically freely substitutable trivial check client need absolutely hard find given service given client request depends whether existing available created argument b version source part b cannot verified asks client help client fulfills responsibility two way first client may increment several designated internal version counter one per developer cannot happen runtime developer may change counter belief source change make existing object unusable second client invariant object need verify invariant violated serving client check fail create deliver new num performance impact need careful analysis pool yes case pool actually hurt performance overhead management greater overhead creation destruction computation cost object question known high loading memory disk without doubt superior recalculating scratch num object destroyed pool pool shut perhaps might also destroy object told partially release resource certain object used whenever created version source longer current evidenced either invariant violation counter mismatch process locating destroying object right time quite complicated addition time based invalidation object may implemented reduce accumulated risk using invalid object since never certain sole owner invalidation best achieved additional version counter client object incremented programmatically periodic basis rather developer num special consideration exist multithreaded environment pool avoid collision checking checking want check two client avoid collision creation want create two object based two identical request num need done client release pool may want make available others waiting time applicable client notify done num object need modified pool may reset default state reused object immutable num special consideration related persistence object pool typically pool saving cost creation object kept memory reading disk would defeat purpose yes saving cost performing complex calculation storing pre calculated object disk make sense result need deal typical problem persistent storage e g initialization need connect persistent storage obtain metadata object currently available ready load memory requested may one three state exist exists disk exists memory running state may change one direction right sequence summary pool complexity item num num num num possibly num num num complexity item num num num overlap item num really core either pool rather constraint design common pattern need work multithreaded environment