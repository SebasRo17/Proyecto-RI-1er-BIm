studying type programming language trouble getting head around concept 5th chapter untyped lambda calculus specifically redex reduction various evaluation strategy head following understand put word attempt explain thing get knowledgeable people correct mistake honestly unsure whether acceptable format stackexchange open suggestion make better fit note others tried answer similar question still left confused call lambda calculus untyped lambda calculus call strict redex understanding correct redex expression application lambda term lambda abstraction concretely redex always form x redex reduction reducing x done replacing free occurrence x example x x num num num num num process reducing lambda expression normal form driven evaluation strategy algorithm picking redex reduce first order describe however need vocabulary redex qualification leftmost rightmost leftmost redex one whose abstraction textually left redexes rightmost redex one whose abstraction textually right redexes example x x num num leftmost redex x x num rightmost redex num one leftmost one rightmost redex given expression assuming expression composed single redex redex leftmost rightmost innermost outermost innermost redex one contains redex outermost redex one contained within redex example x num x num innermost num contains redex outermost x contained redex assuming expression composed single redex redex outermost innermost evaluation strategy defined talk two evaluation strategy struggling call call call call leftmost outermost redex always picked reduction additionally reduction occur within lambda abstraction example given type programming language id id z id z leftmost outermost redex first id id z id z leftmost outermost redex still first id z id z outermost redex remaining done understand need definition strategy include reduction occur within lambda abstraction implied fact outermost redexes eligible reduction call call rightmost outermost redex always picked reduction example given type programming language id id z id z rightmost outermost redex second id id z id z rightmost outermost redex first id left redex right z id z remaining redex outermost contained within abstraction cannot reduced