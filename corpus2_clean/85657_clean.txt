programming num year according advice first programming teacher always keep extremely short first idea obeyed without understanding much delight professor gaining experience realized designed correctly short sortof happened writing modularized following single responsibility principle allowed designed bunch served nothing catalyst get program running fast forward week ago looking souce found minimal program everything loaded library argc argv py argc argv yay short good programming teacher right wanting look deeper took look py entirety defined follows program py argc argv c sts command filename module file fp stdin p unbuffered num num stdin interactive num help num version num saw unbuffered flag num cf cf cf flag num orig argc argc py orig argv argv ifdef py num endif c getopt argc argv program opts eof c c c last option following argument look like option left command interpret command malloc strlen num command py enough memory copy c argument strcpy command strcat command n break c last option following argument look like option left module interpret module malloc strlen num module py enough memory copy argument strcpy module break switch c case b py break case py break case num py py py num break case q strcmp old num py num break strcmp warn num py num break strcmp num py num break strcmp new num affect cf cf flag co future division tell eval treat binary divide binary divide py num break fprintf stderr q option n usage num argv num case py py break case j reserved jython case py break case b py break case py break case py break case e py break case py break case u unbuffered saw unbuffered flag num break case v py break ifdef case w py num break endif case x num break case x reserved implementation specific argument case u py break case h case help break case v version break case w break space reserved option default usage num argv num help usage num argv num version fprintf stderr n py version num py py num implies tt py num py p py p num py num saw unbuffered flag p py p num unbuffered num py p py p num py num p py p num buf warning buf malloc strlen p num buf py enough memory copy strcpy buf p warning strtok buf warning warning strtok warning free buf command module argc strcmp argv num ifdef vms filename translate vms argv filename num filename num filename argv else filename argv endif stdin interactive py stdin num unbuffered defined m window defined cygwin setmode fileno stdin binary setmode fileno stdout binary endif ifdef stdin stdout stderr else stdin stdout stderr endif else py ifdef m window buffered use unbuffered set v buf stdin screw tkinter stdout else m window ifdef stdin stdout endif endif m window leave stderr alone unbuffered anyway ifdef vms else stdout endif vms ifdef apple macos x interpreter embedded application bundle get executed bootstrapping script o execve argv num different actual executable needed keep finder happy rather work around apple overly strict requirement process however still need usable sys executable actual executable path passed environment see lib mac py detail bootstrap script p py p num py p else py argv num else py argv num endif py initialize py command filename module stdin interactive fprintf stderr n py getversion py py fprintf stderr n copyright command backup force sys argv num c argv c module backup force sys argv num c correctly set sys path num rather looking file called see tracker issue num detail argv c argc argv py command filename module fileno stdin v v readline v clear else py decref v command sts command cf num free command else module sts module num free module else filename stdin interactive py num exit cf xxx sts num keep track whether already filename sts filename sts num filename fp fopen filename r fprintf stderr open file errno n argv num filename errno errno num else ch push back first newline number remain ch getc fp eof ch n ch fp break xxx work win win64 see posix struct stat sb fileno fp sb num sb st mode fprintf stderr directory cannot continue n argv num filename fclose fp num sts num call pending call like signal handler sigint py num sts num else sts fp filename stdin filename filename cf num check environment end give program opportunity set py p py p num py num py stdin interactive filename command module py num xxx sts stdin stdin cf num py finalize ifdef py fprintf stderr make frontend quit endif ifdef insure insure memory analysis tool aid discovering memory leak memory problem exit interned dictionary flagged use exit normal circumstance fine memory automatically reclaimed system memory debugging huge source useless noise trade slower shutdown less distraction memory report py endif insure sts good god almighty big enough sink titanic seems though intro programming num trick moved different called something similar question terribly written reason short stand right see absolutely difference moving py back wrong thinking