lesson learn project nearly actually failed due bad multithreading sometimes framework imposes certain threading model make thing order magnitude difficult get right yet recover last failure feel better work anything multithreading framework found good multithreading problem simple fork join travel one direction signal travel circular direction unable handle gui work done strictly serialized thread thread work done thread thread worker thread message travel direction n component fully connected graph time left project another one deadlock issue everywhere heard num num month later several developer managed fix deadlock issue point shipped customer never managed find missing piece knowledge lacking something project number message id integer value describe meaning event sent message queue another regardless threading run several thousand unique string user message also thousand added best analogy got another team unrelated past present project put database database referring centralization atomic update gui fragmented multiple view running thread non gui heavy lifting done individual worker thread application stored single act like database let database handle atomic update involving non trivial dependency part gui handle screen drawing nothing else ui part could cache stuff user notice stale fraction second designed properly database also known document document view architecture unfortunately app actually store view know like fellow contributor contributor need use real personal example lesson anecdotal example judged credible also welcome