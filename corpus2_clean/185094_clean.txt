wondering better design wise usability maintainability better far fitting community given model amount enough plenty deriving show eq container container deriving show eq category category deriving show eq store store category deriving show eq item item container category amount store deriving show instance eq item i1 i2 i1 i2 user user container category store item deriving show instance eq user u1 u2 getname u1 getname u2 implement monadic function transform user instance adding item store etc may end invalid user monadic function would need validate user get create wrap monad make monadic function execute validation wrap monad make consumer bind monadic validation sequence throw appropriate response choose validate carry around invalid user actually build bind instance user effectively creating kind monad executes validation every bind automatically see positive negative num approach want know commonly done scenario community term something like option num user n1 c1 c2 s1 i1 validate user n1 c1 c2 s1 i1 someuser store yay category doesnt exist invalid argh option num user n1 c1 c2 s1 i1 right user n1 c1 c2 s1 i1 right someuser store yay category doesnt exist invalid argh validate choice validation could pushed last possible moment like inside db get updated option num u u u instance monad u f case u x f x u f u u validate u store user u vu u vu user n1 c1 c2 s1 i1 user n1 c1 c2 s1 i1 store yay category doesnt exist invalid argh