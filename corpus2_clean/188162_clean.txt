consider benchmark c application little proportion overall runtime compute intensive single threaded program page read outset run many iteration core task hand average cache ephemeral variation large multi core linux system far memory us memory hierarchy machine idle course number usual daemon floating around plenty core memory spare keep happy observe surprising u range variation wall clock time result anyone suggest look explanation reduce variation linux net num num num num x86 64 num smp mon jun num num num num bst num x86 64 x86 64 x86 64 gnu linux show show policy default preferred node current num num num num num num num num num num num num num num num num num num num num num num hardware available num node num num node num cpu num num num num num num num num node num size num mb node num free num mb node num cpu num num num num num num num num node num size num mb node num free num mb node distance node num num num num num num num num