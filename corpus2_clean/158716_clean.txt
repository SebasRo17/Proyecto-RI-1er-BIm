understand correctly liskov substitution principle cannot observed language object inspect like usual duck typed language example ruby b inherits every x x going x b x going statement lsp let q x property provable object x q provable object subtype ruby example end end violate lsp form witnessed property q x x addition answer yes lsp incompatible introspection question would modified weak form lsp possibly hold dynamic language possibly additional condition special type property update reference another formulation lsp found web function use pointer reference base class must able use object derived class without knowing another declared subtype object behave object expected behave treated object last one annotated note lsp expected behaviour object one follow lsp one clear expected behaviour object seems weaker original one might possible observe would like see formalized particular explained decides expected behavior lsp property pair class programming language pair class together given set property satisfied ancestor practically would mean construct subclass descendant respecting lsp possible us ancestor known according lsp ancestor supposed replaceable descendant right update already accepted answer would like add one concrete example ruby illustrate question ruby module sense descendant module however c end c module c superclass module module end module new extend ok extend c typeerror wrong argument expected module