looking solution question ran across old binary tree code daniel lichtblau reproduced clear leftsubtree rightsubtree nodevalue emptytree treeinsert leftsubtree left left rightsubtree right right nodevalue val val emptytree treeinsert emptytree elem emptytree elem emptytree treeinsert tree elem sameq nodevalue tree elem tree treeinsert tree elem orderedq nodevalue tree elem leftsubtree tree nodevalue tree treeinsert rightsubtree tree elem treeinsert tree elem treeinsert leftsubtree tree elem nodevalue tree rightsubtree tree mapped onto list treeinsert give sorted duplicate free list example tr scan tr treeinsert tr randominteger flatten tr machine take process randominteger increase nearly randominteger likely technique speed curious memoization could adapted problem issue though tree change insertion cannot used directly memoization definition depends directly form would one edit discovered testing fold work much better scan creating tree follows tr fold treeinsert randominteger flatten tr update question per se answered directly answer indicated better way accomplish wanted end chose one two reason speed simplicity