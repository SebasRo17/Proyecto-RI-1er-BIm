first realize perfect q style question absolute answer think wording make work better think absolute solution one reason posting instead stackoverflow last month rewriting fairly old piece server mmorpg modern easier extend mod started network portion implemented 3rd party library libevent handle stuff refactoring change introduced memory corruption somewhere struggling find happens seem reliably reproduce dev test environment even implementing primitive bot simulate load dont get crash anymore fixed libevent issue caused stuff tried far valgrinding hell invalid writes thing crash may take num day production hour really baffling surely point would access invalid memory overwrite stuff chance way spread address range analysis tool namely coverity cppcheck point nastiness edge case nothing serious recording process crash gdb via working way backwards sound like doable either end crashing gdb using auto complete feature end internal libevent structure get lost since many possible branch one corruption causing another guess would nice could see pointer originally belongs allocated would eliminate branching issue cant valgrind though normal gdb record slow even work combination valgrind review thoroughly friend look though doubt thorough enough thinking maybe hiring dev review debugging cant afford put much money know look someone willing work little money doesnt find issue anyone qualified also note usually get consistent place crash happens mostly related socket becoming corrupted somehow invalid pointer pointing something isnt socket socket becoming overwritten partially gibberish although suspect crashing since one mostly used part first corrupted memory get used issue busy nearly num month hobby project really frustrating point become grumpy irl think giving cant think else supposed find issue useful technique missed guy deal cant common since much information really blind edit spec case matter using c num via gcc num version supplied debian codebase around 150k line edit response david pfx post sorry slow response keeping careful record crash look pattern yes still dump recent crash lying around place really similar way well recent version seem change whenever add remove change related structure would always get caught item timer basically item specific time expires sends updated info client invalid socket pointer would still valid far tell player mostly related also experiencing load crash cleanup phase normal shutdown destroying static class havent explicitly destroyed exit handler backtrace mostly involving std map one guessing first thing come though corrupt look like zero ascii pattern havent found pattern yet seems somewhat random hard tell since know corruption started heap related entirely heap related enabled gcc stack guard didnt catch anything corruption happen free gonna elaborate bit one mean pointer already free object lying around setting every reference get destroyed unless missed something somewhere show valgrind though didnt something distinctive network traffic buffer size recovery cycle network traffic consists raw array u intx packed remove padding structs complex thing packet header consisting id packet size validated expected size around num biggest internal bootup packet fired startup size mb lot lot production asserts crash early predictably damage propagates crash related std map corruption entity map view entity see vice versa added buffer infront filled 0x33 checked access corruption magically vanished must moved something around made corrupt something else strategic logging know accurately happening add logging get closer answer work extend desperation save state auto restart think piece production software somewhat software consists cache process worker one access cache get save stuff per crash dont lose much progress still disconnect user definitely solution concurrency threading race condition etc mysql thread async query untouched though share information database via function lock interrupt interrupt timer prevent locking didnt complete cycle safe though abort else num volatile num increased time cycle completed old event callback exception corrupting state stack unpredictably lot callback used async network io timer anything bad unusual unsual timing state edge case related disconnecting socket packet still processed resulted accessing nullptr easy spot far since every reference get cleaned right telling done destruction handled deleting destroyed object cycle dependency asynchronous external process care elaborate somewhat case cache process mentioned thing could imagine top head would finishing quick enough using garbage case since using network packet model