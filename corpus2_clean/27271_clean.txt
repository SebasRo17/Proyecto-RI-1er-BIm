using dynamical programming save intermediate step recursive relation f n f n f n f n however store definition explicit value n need able store function definition number parameter function depends step specifically something like cdots n cdots n b cdots n c ab ab index unspecified value recursive definition allows express cdots n combination c easy implement mathematica c b b b rest high n calculation time become long especially function bit complicated normally would use dynamic programming something like b rest need execute b c make definition b c literally meaning b c recalculated recursively stored set setdelayed b c c b b c would need kind magic dynamic programming store function definition magic b rest execute b c store b c c b b c etcetera looked leonid answer question easily see adapt growing number argument idea many thanks advance edit thanks leonid answer understand bit solved unfortunately way need bit complicated several function definition condition patterntest optional next recursive growing variable also first thought figure based leonid answer hence accept idea make wrapper memoize wrap around function definition memorises function definition example pseudocode memoize dot b evenq c b c recursive function first thing tried retrieve patternames replace unique one clearall memoize setattributes memoize holdallcomplete memoize expr setdelayed first retrieve lh rh funclhs hold expr hold setdelayed x hold x funcrhs hold expr hold setdelayed x hold next retrieve name pattern used patternnames first case funclhs pattern infinity make locally scoped pattern varsext table unique length patternnames express lh rh function former locally scoped pattern lh funclhs rule transpose patternnames varsext rh funcrhs rule transpose patternnames varsext lh rh hold x hold setdelayed x work anything useful would need replace central part leonid answer somehow mean inject var lh rh additional difficulty length var equal length varsext tried clearall memoize setattributes memoize holdallcomplete memoize expr setdelayed funclhs hold expr hold setdelayed x hold x funcrhs hold expr hold setdelayed x hold patternnames first case funclhs pattern infinity varsext table unique length patternnames lh funclhs rule transpose patternnames varsext rh funcrhs rule transpose patternnames varsext lh hold var table unique length varsext pt pattern var lh mapthread pattern sequence function x pattern x varsext var rh mapthread sequence varsext var hold x hold set x lh x pattern x hold x hold setdelayed x pattern replacing lh work take care condition optional patterntest totally stuck although feeling change make work