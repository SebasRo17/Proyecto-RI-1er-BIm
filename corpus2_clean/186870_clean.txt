developing utilizes generic one guiding principle make usable future scenario today however several coworkers expressed may traded readability sake extensibility wanted gather feedback possible way resolve specific interface defines transform start source collection item apply transform element storing result destination collection additionally want able destination collection caller rather forcing use collection reference want able use whatever collection actually provided destination collection finally make possible item destination collection different item source collection maybe transform instance several source item make one destination item transform yield following interface interface transform src dst extends collection super dst transform collection extends src tried nice apply josh bloch principle producer extends consumer super make sure interface usable super sub type appropriate end result somewhat monstrosity would nice could extend interface specialize somehow example really care playing nice subtypes source item destination item could interface src dst extends collection dst transform collection src way want make implementation interface something others would actually consider opposed running fear considered several option destination collection seems weird given transform get nothing back abstract implement interface translates parameter something easier use call another simpler signature thus present less cognitive burden implementers weird write abstract make interface user friendly forgo extensibility simpler interface possibly couple returning destination collection limit option future think missing approach could use