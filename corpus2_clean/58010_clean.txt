update thanks answer noticed handle following special case li li z li z li z also considered legal input given question easy add special case processing making li li z etc calling parser actually nice incorporated special pattern rule well could inside alternative check special case make sure input clarify term form c z n one term e li term term term term c numerical value n numerical value positive negative result list c n one entry term even one term work example verify li li z li z li z li z li z z z z li z z z z original question hammer use everything see need parsing pattern case trying write simple pattern based parser accepts output expand f z f z rational function z example take input expand z z z z z z expand z z z z z z z z z input thought power series z term form well defined output parser list show coefficient term exponent z given input z z z z output best come li z z z z case li alternative x power z e time x power z e x x e problem generates pattern matched x last one alternative e mathematica replaced e null sequence documented help another problem x last one alternative wrote instead case li alternative x x power z e time x power z e x e would worked another thing worry ok fine except output symmetric need special case processing hoping something like case li alternative x power z e x e time x power z e x e x x ie specific rule specific pattern much easier work since specific output pattern instead pattern target one output course valid mathematica code case like general way pattern matching allows one write specific rule specific pattern use case long follows general approach know one probably use polynomial specific function coefficientrules coefficientlist related function case interested general approach learn use thing example