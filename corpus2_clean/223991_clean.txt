short introduction question used tdd lately bdd one year use technique like mocking make writing test efficiently lately started personal project write little money management program since legacy perfect project start tdd unfortunate experience joy tdd much even spoiled fun much given project problem well used tdd like approach let test requirement evolve design program problem one half development time writing refactor test end want implement feature would need refactor write many test work lot legacy write integration acceptance test less unit test seem bad approach since bug mostly detected acceptance integration test idea could end write integration acceptance test unit test like said detecting bug unit test better integration acceptance test unit test also good design since used write lot class always designed good testable additionally approach let test requirement guide design lead case better design last advantage unit test faster written enough integration test know nearly fast unit test looking web found similar idea mine mentioned think idea edit responding question one example design good needed huge refactoring next requirement first requirement execute certain command wrote extendable command parser parsed command kind command prompt called correct one model result represented view model first design nothing wrong class independent could easily add new command show new next requirement every command view representation kind preview result command redesigned program achieve better design new requirement second design also good every command view model therefore preview thing command parser changed use token based parsing command stripped ability execute command every command got view model view model know current command view model know shown wanted know point new design break existing requirement change acceptance test refactor delete nearly every unit test huge pile work wanted show common situation happened often development problem old new design changed naturally requirement understood one advantage tdd design evolves conclusion thanks answer discussion summary discussion thought approach test next project first write test implementing anything like always requirement write first acceptance test test whole program write integration test component need implement requirement component work closely together another component implement requirement would also write integration test component tested together last least write algorithm high permutation e g serializer would write unit test particular class class tested unit test bug process simplified normally bug caused one two component case would write one integration test component test bug related algorithm would write unit test easy detect component bug occurs would write acceptance test locate bug exception