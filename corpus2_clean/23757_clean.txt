trying write montgomery exponentiation based compete mathematica powermod know powermod us square multiply technique speedup must obtained replacing modular operation mod n modular operation mod x accomplish mathematica take powermod implementation global variable rlength r rm rinverse nprime verbose false montexp b e mod n montexp b e n rlength bitlength n r rlength rm r rinverse powermod r n nprime powermod n r mod b r n result mod r n verbose print montparams r r rinverse rinverse nprime nprime result mont result result n expbit result mont result n expbit integerdigits e result mont result n return result mont function version mont u v n z mod u v rinverse n verbose print monto u v z return z mont function version mont u v n u v z bitshiftright mod nprime r n rlength verbose print monto u v z return z mont function version mont u v n u v z bitshiftright bitand nprime rm n rlength verbose print monto u v z return z timing p mathematica powermod timing powermod p p false mont v false mont v false mont v false see tried improve binary shift instead modular operation negative impact speed probably non native implementation mathematica idea improve update learnt mod b n bitand b n changed version use bitand yet gain compare original powermod update seems reliance shift speedup k number however saw amazing result simoon wood answer list range powermodtimings first timing powermod list montexptimingsv first timing montexp list mont version montexptimingsv first timing montexp list mont version plotting result listlineplot powermodtimings montexptimingsv montexptimingsv enter image description update added timing mont version based simon wood answer great timing