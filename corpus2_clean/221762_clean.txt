team done ton great work removing barrier functional programming num particular change util collection great job chaining transformation fast streamed operation considering good job done adding first function functional method collection completely failed provide immutable collection even immutable collection interface without changing existing team could time add immutable interface mutable one minus set method make existing interface extend like iterable already immutable immutablecollection collection immutablelist immutableset immutablemap list set map sure operation like list add map put currently boolean previous given key indicate whether operation succeeded failed immutable collection would treat method factory new collection containing added element incompatible current signature could worked around using different like immutablelist append immutablemap resulting verbosity would outweighed benefit working immutable collection system would prevent error calling wrong time old method could deprecated win immutable collection simplicity reasoning simpler underlying change documentation take immutable collection interface know going modify collection concurrency immutable collection shared safely across thread someone language assume immutability hard go back wild west rampant mutation clojure collection sequence abstraction already everything num collection provide plus immutability though maybe using extra memory time due synchronized linked list instead stream scala mutable immutable collection full set operation though operation eager calling iterator give lazy view way lazily evaluating see continue compete without immutable collection someone point history discussion surely public somewhere