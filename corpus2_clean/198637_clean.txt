writing module run finite state machine based content record passed initialization record describes state includes instruction act input e state s1 trigger transition state s2 fsm work correctly state need exist quandary validate transition defensive programmer say early possible fsm initialized mean raise first handed bogus avoid handing back process may fail later result rest implementation defensive table known good error erlang decides raise result implementation rather fed bad also make debugging easier using module since get something else back immediately instead source later figure mistake mine erlang philosophy seems thing left long possible failing letting supervisor take care picking piece one hand make sense given fsm could forever without encountering input would take bad transition failing late put onus caller write repetitive test something easy implement know rule business hard fast one approach would fail early implementation appear place released others use aware gen fsm behaviour comparative shortcoming learning exercise thing fsm happens something incorporates