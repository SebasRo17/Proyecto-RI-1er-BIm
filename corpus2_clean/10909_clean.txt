trying understand behavior findroot consider sample function one actually interested far complicated similar issue following argument crazyfunction x n norm x yact randomreal join randomreal gv yact randomreal join randomreal sampledata crazyfunction b c crazyfunction yact basically applying sample function particular yact value three x value setting equal function evaluated three unknown value b c solve unknown value used findroot initial guessed value gv randomly perturbed actual value sol findroot sampledata transpose b c gv maxiterations note likely throw warning findroot lstol line search decreased step size within tolerance specified accuracygoal precisiongoal evaluate quality solution compare norm difference actual yact solved normalized norm yact norm yact b c sol norm yact terrible value thinking three unknown b c three different equation different x value enough solve problem fact without three equation findroot work e findroot sampledata transpose b c gv maxiterations findroot nveq number equation match number variable instead using three different equation simply repeat equation three time sampledata table crazyfunction b c crazyfunction yact sol findroot sampledata transpose b c gv maxiterations give lstol warning actually get accurate result consider dat table yact randomreal join randomreal gv yact randomreal join randomreal sampledata crazyfunction b c crazyfunction yact sol quiet findroot sampledata transpose b c gv maxiterations norm yact b c sol norm yact datsamedata table yact randomreal join randomreal gv yact randomreal join randomreal sampledata table crazyfunction b c crazyfunction yact sol quiet findroot sampledata transpose b c gv maxiterations norm yact b c sol norm yact histogram dat datsamedata log mathematica graphic note log binning using equation three time far accurate using three different equation question repeating equation three time far accurate using three different equation