binary tree define horizontal distance follows horizontal distance hd root num go left hd hd parent num go right hd hd parent num bottom view tree consists node tree node hd greater level may multiple node given hd case belong bottom view looking algorithm output bottom view tree example suppose binary tree num num num num num num num num bottom view tree num num num num num num ok first example horizontal distance node num num level num horizontal distance node num num num num level num horizontal distance node num num num num level num horizontal distance node num num num num level num horizontal distance node num num num num level num horizontal distance node num num num num level num horizontal distance node num num num num level num horizontal distance node num num num num level num vertical hd num node appear last level hd num num hd num num hd num num num appear last level vertical hd num num hd num num one example reference num num num num num num num num num num num num num num num num num num num num num num num num num num num similarly example hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd node num num level num hd num num hd num num hd num num num num hd num num num hd num num num num hd num num hd num num ouput num num num num num num num num num num num num already know using lot extra space map num storing level last element vertical time complexity n log n implementation include iostream include cstdio include map include vector using namespace std struct node struct node left right node newnode node temp new node temp temp left temp right temp height node node node num else height node left rh height node right rh num else rh num node node level hd min map vector visited lev l node level num lev hd min num lev hd min l lev hd min l visited hd min push back node else level num node left level num hd num min visited lev l node right level num hd num min visited lev l node node min max hd node hd min min hd else hd max max hd node left min max hd num node right min max hd num node root newnode num root left newnode num root right newnode num root left left newnode num root left right newnode num root right left newnode num root right right newnode num root left left left newnode num root left left right newnode num root left right left newnode num root left right right newnode num root right left left newnode num root right left right newnode num root right right left newnode num root right right right newnode num min num max num root min max num lev max min num map vector visited map vector iterator num max min num lev num h height root h num root num min visited lev visited begin visited end num second size cout second num seeking help optimized way used less space time efficient problem