this might be a little philosophical but I hope someone can help me find a good way to think about this. I've recently undertaken a refactoring of a medium sized project in Java to go back and add unit tests. When I realized what a pain it was to mock singletons and statics, I finally "got" what I've been reading about them all this time. (I'm one of those people that needs to learn from experience. Oh well.) So, now that I'm using Spring to create the objects and wire them around, I'm getting rid of `static` keywords left and right. (If I could potentially want to mock it, it's not really static in the same sense that Math.abs() is, right?) The thing is, I had gotten into the habit of using `static` to denote that a method didn't rely on any object state. For example:               //Before     import com.thirdparty.ThirdPartyLibrary.Thingy;     public class ThirdPartyLibraryWrapper {         public static Thingy newThingy(InputType input) {              new Thingy.Builder().withInput(input).alwaysFrobnicate().build();         }     }          //called as...     ThirdPartyLibraryWrapper.newThingy(input);                    //After     public class ThirdPartyFactory {         public Thingy newThingy(InputType input) {              new Thingy.Builder().withInput(input).alwaysFrobnicate().build();         }     }          //called as...     thirdPartyFactoryInstance.newThingy(input);      So, here's where it gets touchy-feely. I liked the old way because the capital letter told me that, just like Math.sin(x), ThirdPartyLibraryWrapper.newThingy(x) did the same thing the same way every time. There's no object state to change how the object does what I'm asking it to do. Here are some possible answers I'm considering.   * Nobody else feels this way so there's something wrong with me. Maybe I just haven't really internalized the OO way of doing things! Maybe I'm writing in Java but thinking in FORTRAN or somesuch. (Which would be impressive since I've never written FORTRAN.)    * Maybe I'm using staticness as a sort of proxy for immutability for the purposes of reasoning about code. That being said, what clues _should_ I have in my code for someone coming along to maintain it to know what's stateful and what's not?   * Perhaps this should just come for free if I choose good object metaphors? e.g. `thingyWrapper` doesn't sound like it has state indepdent of the wrapped `Thingy` which may itself be mutable. Similarly, a `thingyFactory` sounds like it should be immutable but could have different strategies that are chosen among at creation.  I hope I've been clear and thanks in advance for your advice!