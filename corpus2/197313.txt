I am test-driving a method that is to generate a collection of data objects. I want to verify that the properties of the objects are being set correctly. Some of the properties will be set to the same thing; others will be set to a value which is dependent on their position in the collection. The natural way to do this seems to be with a loop. However, Roy Osherove strongly recommends against using logic in unit tests ( _Art of Unit Testing_ , 178). He says: > A test that contains logic is usually testing more than one thing at a time, > whicfh isn't recommended, because the test is less readable and more > fragile. But test logic also adds complexity that may contain a hidden bug. > > Tests should, as a general rule, be a series of method calls with no control > flows, not even `try-catch`, and with assert calls. However, I can't see anything wrong with my design (how else do you generate a list of data objects, some of whose values are depended on where in the sequence they are?--can't exactly generate and test them separately). Is there something non-test-friendly with my design? Or am being too rigidly devoted to Osherove's teaching? Or is there some secret unit test magic I don't know about that circumvents this problem? (I'm writing in C#/VS2010/NUnit, but looking for language-agnostic answers if possible.)