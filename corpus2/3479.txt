From my question about types in Mathematica, I assume that every `Symbol` in Mathematica is a type if it appears as a `Head` of some expression. So I can implement operators for monad associated with that `Symbol` (let it be `F` for instance):   1. monad _lift_ function ( _return_ in Haskell notation) is just `return[p_] = F[p]`;   2. monad _bind_ function ( _>>=_ in Haskell notation) is just a rule `bind[F[p_], f_] := F[f[p]]` (as monad Maybe is for example). From point of view of category theory, in Mathematica one can define some common rules for symbols to model monad multiplication (just flatten of repeating `Head`): `monadMultiplyRule = {p_[p_[params___]] -> p[params]}`. So expression `F[F[F[p_]]] //. monadMultiplyRule` will be just `F[p]`. Also all monad axioms are satisfied:   1. `return` acts as a neutral element of `bind`: `bind[return[p], f]` is `F[f[p]]` and `bind[F[p], Identity]` is `F[p]`;   2. sequential `bind` of two functions `f` and `q` is the same as a single `bind` with their "composition" `Bind[F[f[p]], q]`: `Bind[Bind[F[p], f], q]` and `Bind[F[f[p]], q]` produce both the same result `F[q[f[p]]]`. So, does Mathematica provide a natural maybe-like monad for every symbol and does it provide a natural framework for any explicit monadic computations?