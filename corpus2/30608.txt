I have a list of $\\{x,y,z\\}$ pairs representing points in $R^3$. For every unique value of $z$ there are many $\\{x,y\\}$ pairs defining a polygon/contour in that particular $z$-plane. My dataset looks like this:               Input:= Take[ptv, 3]     Output= {{61.52, -217.26, -80}, {63.48, -217.64, -80}, {65.43, -217.64, -80}}      These are coordinates of points residing on the $z=-80$ plane. There are other pairs for $z=-75$, $z=-70$, etc. Therefore `ptv` is of the form: ptv: {{$x_1$,$y_1$,-80}, {$x_2$,$y_2$,-80}, ..., {$x_k$,$y_k$,-80}, ..., {$x_1$,$y_1$,-75}, ..., {$x_m$,$y_m$,-75}, ...} My **goal** is to create a 3D surface where:   1. the points in every $z$-plane are connected into a polygon/contour and   2. the points in every $z$-plane are connected with their neighbors in the immediately above and below plane. I have achieved **1.** , via:               Graphics3D[Line[ptv], Point /@ ptv}]      The result looks like this: ![Plot1](http://i.stack.imgur.com/IF5Gk.png) If I, instead, use:               ListSurfacePlot3D[ptv, AxesLabel->{"x","y","z"}]      I get some ugly artifacts (edges at the boundaries of the volume) as shown here: ![Plot2](http://i.stack.imgur.com/SMwHg.png) Whereas, I was expecting a more "smooth" surface without any "openings". Any hints on:   1. Whether `ListSurfacePlot3D[]` is the proper function to use (i.e. in the documentation it is mentioned that `ListSurfacePlot3D[]` may "fold" over; perhaps this is why I'm experiencing these ruffles?) or   2. What other alternatives are there to consider ? **EDIT 1** : Minimally working example:               ClearAll["Global`*"];     ptv = Import["http://leaf.dragonflybsd.org/~beket/ag1", "Table"]     ListSurfacePlot3D[ptv, AxesLabel->{"x", "y", "z"}]      **EDIT 2** : I excluded random z-planes to explore the dependence of the produced surfaces on my dataset. There is considerable visual variability in the output, including some _very_ irregular images. Here is the code:               (* Identify the values of z-planes *)     planes = ({x, y, z} = #; z)& /@ ptv // Union;          (* Generate some random sequences with z-planes-to-be-excluded *)     excludedPlanes = Table[         RandomSample[planes, RandomInteger@{1, 4}],         {k, 1, 20}]] // Union // Reverse;          (* Filter data by discarding points residing on excluded planes *)     FilterData[p_] := Select[ptv,         Function[v, And@@(Unequal[v, #]& /@ p)][Last[#]]&]          (* Generate the 3D surfaces *)     ListSurfacePlot3D[#, AxesLabel->{"x","y","z"}]& /@ FilterData/@ excludedPlanes      And here is a screenshot: ![enter image description here](http://i.stack.imgur.com/Bs47c.png)