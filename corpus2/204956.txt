I am currently working on a collection implementation in JavaScript. I need a mutable and an immutable version of that. So what I thought of first was something like:   * _Collection_   * _MutableCollection_ extends _Collection_   * _ImmutableCollection_ extends _Collection_. My main issue with this is that if I want to implement more specific collections like _List_ or _Set_ , they could still inherit from _Collection_ while their Mutable/Immutable implementations could not inherit from _MutableCollection_ / _ImmutableCollection_. So this made me think whether having all three, _Collection_ , _MutableCollection_ and _ImmutableCollection_ would actually bring any significant benefit. An alternative approach which came to me would be to only have _Collection_ and then have a _Collection.prototype.makeImmutable_ or _freeze_ there. I would then also introduce a _Collection.requireMutableInstance( collectionInstance )_ which can be used in functions explicitly requiring a mutable collection. Here are my main concerns about putting everything into just _Collection_ :   * The prototype definition is getting much bigger compared to defineing a _MutableCollection_ prototype as well which would then hold the code of all the operations for alteration. I guess I could solve this by just defining a second file anyhow which would then just extend the basic _Collection_ definition with those additional operations and the _makeImmutable_ operation.   * Documentation of those function signatures that actually care about mutable vs. immutable and not just require the basic collection would look less pretty. Take:               /**      * @param {MutableCollection} collection     /*     function messAroundWithSomeCollection( collection ) { /* ... */ }      vs.               /**      * @param {Collection} collection A collection not yet made immutable.     /*     function messAroundWithSomeCollection( collection ) { /* ... */ }      What would be the more _natural_ way of doing this in JavaScript? Especially without having interfaces I can check against and considering the flatter chains of inheritance if I would also implement a _Set_ and _Map_ collection, the everything-in-one approach seems more intuitive to me.