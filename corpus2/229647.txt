Usually I use std::unique_ptr to convey ownership and pass in raw pointers as parameters when no ownership is implied. However, I almost never consider a nullptr to be acceptable as an argument, so it would be nice to use references to avoid this, but I'm not sure most people would expect that the object the parameter references needs to exist for the lifetime of the struct A without looking at the source code.               struct A {         A(B& b)         :  bPtr(&b) {;}              void method() {             // use bPtr         }              B* bPtr;     };      The questions are: 1) Is the only option here to stick with pointers and always check for nullptr? 3) Does the fact that A needs bPtr to be valid mean it should take a shared_ptr? If so I feel like I would use shared pointers practically everywhere. 2) Are there conventions that can help convey lifetime requirements for parameters to users besides comments and documentation?