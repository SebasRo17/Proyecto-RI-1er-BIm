I would like to create a data structure of the type "header[pointer]" where pointer would point to a list. I will shown on an example how I'd like this to work, and where the problems are.               In[1]:= pointer = Unique[storage];     Out[1]= storage$113      So far so good. Now I want to assign some values to the storage               In[3]:= Evaluate[pointer] = {v1, v2, v3}     Out[1]={v1,v2,v3}      Evaluate is needed in order to enforce evaluation of the left hand side of the assignment. The pointer has not been touched/changed which is good:               In: Trace[pointer]     Out: {pointer, storage$113, {v1,v2,v3}}      it still points to the storage, which in turn points to the list with the actual data. Yet, now it starts evaluating to something beyond storage$113. This will turn up later as the main problem. Now I'd like to have something like header[storage$113] as a wrapper to pass this around functions, and here the problems start. If one tries               In: header[pointer]     Out: header[{v1,v2,v3}]      the pointer evaluates down to the values. Thus we get bust since pointer evaluates way to much. If one tries               In: SetAttributes[header, HoldAll]      to prevent its evaluation one gets, alas, that it evaluates too little:               In: header[pointer]     Out: header[pointer]      I found a way               In: header[tmp] /. tmp -> Trace[pointer][[2]]     Out: header[storage$113]      that finally does the trick. I really do not understand why this works, actually. Trace[pointer][[2]] should also evaluate down to values v1, v2, ... This implementation might be problematic for several reasons: Trace might come up with a rather long list, and I just need the second element of it! Another problem, I suppose that the output of the Trace command might change dynamically depending on whether one puts in some extra definitions. I suppose that this is theoretically possible. Another way would be to issue header[pointer] command while pointer is still unspecified as               pointer = Unique[storage];     object = header @@ {pointer}     ... fix storage here...      but this forces me to do something I potentially might not want to do. For example, what if the command object = header... has to come at the end for whatever reasons? Anyway, I feel these both constructs looks very fragile I think and I'd like to understand how to controll these things better. Are there better ways?