I have a function that takes two parameters, `del` and `nu`, and returns a list `npoints` long with a bin-width of `dt`:               ktDynaList[npoints_?NumericQ, dt_?NumericQ, del_?NumericQ, nu_?NumericQ] :=       Module[{alphaN, Npad, tt, expwei, gg, padgg, ff, FF, dkt},       alphaN = 10;       Npad = 2*npoints;       tt = Table[dt i, {i, 0, Npad - 1}];       expwei = Exp[-(alphaN/(npoints*dt))*tt];       gg = (1/3)*(1 + 2*(1 - del^2*tt^2)*Exp[-0.5 del^2 *tt^2]);       padgg = PadRight[Take[gg, npoints], Npad];       ff = Fourier[padgg*expwei*Exp[-nu*tt], FourierParameters -> {1, 1}];       FF = Exp[-nu dt]*ff/(1 - (1 - Exp[-nu dt])*ff);       dkt = Take[InverseFourier[FF, FourierParameters -> {1, 1}]/expwei, npoints];       dkt      ]      I want to fit this function to a dataset using `NonlinearModelFit`, so I have an edited version that returns one value from this array at a particular abscissa `t`:               ktDyna[npoints_?NumericQ, dt_?NumericQ, del_?NumericQ, nu_?NumericQ, t_?NumericQ] :=       Module[{alphaN, Npad, tt, expwei, gg, padgg, ff, FF, dkt},       alphaN = 10;       Npad = 2*npoints;       tt = Table[dt i, {i, 0, Npad - 1}];       expwei = Exp[-(alphaN/(npoints*dt))*tt];       gg = (1/3)*(1 + 2*(1 - del^2*tt^2)*Exp[-0.5 del^2 *tt^2]);       padgg = PadRight[Take[gg, npoints], Npad];       ff = Fourier[padgg*expwei*Exp[-nu*tt], FourierParameters -> {1, 1}];       FF = Exp[-nu dt]*ff/(1 - (1 - Exp[-nu dt])*ff);       dkt = Take[InverseFourier[FF, FourierParameters -> {1, 1}]/expwei, npoints];       dkt[[ Round[t/dt] ]]      ]      Now, this can be passed to `NonlinearModelFit`, and will fit a dataset rather successfully. However, the problem is that in its current state it is incredibly inefficient, as the `dkt` list is recalculated for every single abscissa. I'm trying to find a way of storing the `dkt` array such that it does not need to be fully recalculated for each `t` value, and am wondering if anyone in the community has encountered a problem of this type before? My current thoughts are either   1. An If statement at the beginning of the function which checks if the parameters `del` or `nu` have been varied since the last iteration - if they haven't then one can just return the list element from the previously calculated `dkt` list and avoid a lot of calculation steps. My problem here is that _Mathematica_ doesn't appear to have static variables (that I know of). Is there any way around this?   2. Some sort of flag system that can be passed between function calls which indicates if the full calculation needs to be performed, or if a previously stored list element can be returned. Or is there some other solution that doesn't require the use of `NonlinearModelFit`?