I've been reading up on using the `p`-iteration method to solve Lambert's problem for choosing the correct interplanetary trajectory between two planets given the initial position of the source planet, final position of the target planet as well as a time of flight of the spacecraft. I can solve the equations manually, but what I wanted was to make a while loop in _Mathematica_ that would automatically find the required time of flight. As an example, here is what I have so far (which I got from http://www.braeunig.us/space/interpl.htm):               G = 6.672*10^-11;     M = AstronomicalData["Sun", "Mass"];     m = AstronomicalData["Earth", "Mass"];     deltat = 207*86400; (*seconds*)     r[1] = {0.473265, -0.899215, 0};     r[2] = {0.066842, 1.561256, 0.030948 };          Subscript[μ, s] = G M/(149.597870*10^9)^3 (*In AU^3/s^2*)          (*p-iteration constants*)     r1 = Sqrt[r[1].r[1]]     r2 = Sqrt[r[2].r[2]]     deltaA = ArcCos[r[1].r[2]/(r1 r2)]/Degree     k = r1 r2 (1 - Cos[deltaA Degree])     l = r1 + r2     m = r1 r2 (1 + Cos[deltaA Degree])          (*p-iteration calculations*)     a = (m k p)/((2 m - l^2) p^2 + 2 k l p - k^2)     f = 1 - r2/p (1 - Cos[deltaA Degree])     g = (r1 r2 Sin[deltaA Degree])/Sqrt[Subscript[μ, s] p]     fdot = Sqrt[Subscript[μ, s]/p]     Tan[(deltaA Degree)/2] ((1 - Cos[deltaA Degree])/p - 1/r1 - 1/r2)     gdot = 1 - r1/p (1 - Cos[deltaA Degree])     deltaE = ArcCos[1 - r1/a(1 - f)] (*In radians*) (*used if a is positive*)     deltaF = ArcCosh[1 - r1/a(1 - f)] (*In radians*) (*used if a is negative*)     t = g + Sqrt[a^3/Subscript[μ, s]] (deltaE - Sin[deltaE ]) (*used if a is positive*)     t = g + Sqrt[(−a)3/Subscript[μ,s]](Sinh[deltaF]−deltaF) (*used if a is negative*)      I've been trying to make a while loop to perform iterations on the above calculations that will choose a value for `p` in order to match t as close as possible to `deltat` but have so far been unable to get a working solution. The way to choose a new value for p for each new iteration is done using the following equation:               p[n+1]=p[n]+(deltat-t[n])(p[n]-p[n-1])/(t[n]-t[n-1])      where `t[n-1]` and `t[n]` are the first and second iterations of the above algorithm respectively. Does anyone know how I could do something like this in a while loop? Any help would be great appreciated. EDIT: With regards to using the FindRoot function, this is what I tried (I essentially replaced g, a and deltaE in                t = g + Sqrt[a^3/Subscript[μ, s]] (deltaE - Sin[deltaE ])       with the basic equations I started with) which unfortunately brought up a few errors: ![enter image description here](http://i.stack.imgur.com/P3JmX.png)