Context: I'm studying non-linear dynamics. As part of a bigger problem, I'd like to generate lists of the form `{{deq, ic1}, {deq, ic2}, ...}`, where `deq` is a differential equation and `ic` are initial conditions. **EDIT** : (Use `r` instead of `t` for the tuples as per @Kuba's suggestion *)               ClearAll["Global`*"];     deq = x''[t] == x[t] - x[t]^3 + x[t]^2 + Cos[t];     r = Tuples[{Hold@deq, {{x[0] == 0, x'[0] == 0}, {x[0] == 0, x'[0] == 1}}}]     NDSolve[First@r, {x, x'}, {t, 0, 1000}]      I have the following related questions:   1. ~~Why do I need to`Hold[]` `deq` at the first place ? If I don't use it, `Tuples[]` will "break" `deq` in == and combine all the `{lhs, rhs}` with all the `ic`'s.~~ It's due to the fact that `deq` isn't list which is what `Tuples[]` expects. See @Kuba's answer.   2. Why when later on I pass the result of to `NDSolve[]`, `Hold@deq` is evaluated without me releasing it first ? I checked the documentation of `Hold[]` and it says that this should happen only when the held expression is of the form `f[args]` and UpValues have been defined for f. I don't mind that it does, but I'm trying to understand the logic.   3. How would using `Unevaluated@deq` differ compared to `Hold@deq` ?