When you attempt to define a `SparseArray` with elements that have the head `List` it complains:               SparseArray[{1 -> {1, 2, 3}, 2 -> {"a", "b"}}]      > SparseArray::valnl: The value specified by the rule 1->{1,2,3} should not be > a List. >> >   >   >     SparseArray[{1 -> {1, 2, 3}, 2 -> {"a", "b"}}] >   Nevertheless (other) arbitrary expressions are accepted:               SparseArray[{1 -> foo[1, 2, 3], 2 -> bar["a", "b"]}]      ![enter image description here](http://i.stack.imgur.com/aW617.png) There does not appear to be any actual limitation of `SparseArray` that prevents it from storing `List` elements. In fact with a bit of fiddling we _can_ get `SparseArray` to hold `List` elements! First wrap the Lists an additional head so that `SparseArray` accepts them, then use `Part` to extract the first part of every element, essentially stripping the arbitrary extra heads (`foo`):               sa1 = SparseArray[{1 -> foo@{1, 2, 3}, 2 -> foo@{"a", "b"}}];          sa2 = sa1[[All, 1]];      We now have a `SparseArray` with `List` elements:               sa2 // Head     sa2[[1]] // Head     Head /@ Normal[sa2]     sa2["NonzeroValues"]      > >     SparseArray >   >     List >   >     {List, List} >   >     {{1, 2, 3}, {"a", "b"}} >   However if we try to use the `InputForm` of the expression (as input) it does not work:               ToString[sa2, InputForm] // ToExpression      > >     SparseArray[Automatic, {2}, 0, {1, {{0, 2}, {{1}, {2}}}, {{1, 2, 3}, > {"a", "b"}}}] >   Sadly this false equivalence breaks the use of `Save` and pattern-based manipulation of the object. Why would `SparseArray` be blocking the use of `List` when apparently any other head is accepted, and when there is internal support for `List` itself?