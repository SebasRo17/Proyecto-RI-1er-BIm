I am currently checking through the syllabus for the ISTQB "Technical Test Analyst" certification. This syllabus (henceforth called "TTA syllabus") contains a chapter dedicated to _"condition testing"_ (apparently this is also called _"condition coverage"_ or _"condition coverage testing_ ".) _Condition testing_ as defined in the TTA syllabus strikes me as an exceedingly strange and possibly anachronistic thing that has more to do with Grandma's Ham Story than with software testing. Let me explain... **What is "condition testing" according to the TTA syllabus?** Referring to the "Advanced Level Syllabus - Technical Test Analyst, Version 2012" of the ISTQB, available here, "condition testing" is defined as follows on page 12: > Compared to decision (branch) testing, which considers the entire decision > as a whole and evaluates the TRUE and FALSE outcomes in separate test cases, > condition testing considers how a decision is made. Each decision predicate > is made up of one or more simple “atomic” conditions, each of which > evaluates to a discrete Boolean value. These are logically combined to > determine the final outcome of the decision. _Each atomic condition must be > evaluated both ways by the test cases to achieve this level of coverage._ > > _Applicability_ > > Condition testing is probably interesting only in the abstract because of > the difficulties noted below. Understanding it, however, is necessary to > achieving greater levels of coverage that build upon it. **So let's clarify the words** Suppose we have some software-under-test on which we want to do _whitebox testing_ (i.e. we have the source code). The code naturally contains many of those _decision predicates_ that we all know and love and that show up after strings like `if`, `while`, `until` etc. An example of the decision predicate might be: > `((x>y+z) AND (y<-3)) OR ((z²+x²<4) AND (z≤y))` ![An example of a decision predicate](http://i.stack.imgur.com/HlZtV.png) This decision predicate accepts a triple _(x,y,z)_ of integer values (say) and outputs a boolean, _b_out_. The first-level functions which map _(x,y,z)_ to {TRUE,FALSE} are called _conditions_ (also _atomic conditions_ ) in the TTA syllabus. **Condition testing coverage** One attains _"condition testing coverage"_ by running test cases until all the _conditions_ found in the _decision_ yielded at least once _true_ and at least once _false_. One can thus achieve condition testing coverage by running the following five test cases (for example): ![Truth table achieving condition testing coverage](http://i.stack.imgur.com/nO80z.png) Each of the the _b0_ , _b1_ , _b2_ , _b3_ shows up at least once with _true_ and at least once with _false_. In some test cases, we do not care about a given value as it has no influence on the condition whose output we want to get right. **Addendum: Decision coverage** Incidentally, the truth table shows also that _"decision coverage"_ has been attained for this decision, as _b_out_ shows up at least once with _true_ and at least once with _false_ , so both branches of any code would be covered. **And now the question** What is "condition testing" as defined above actually good for? It won't help you ascertain the correctness of the decision predicate at all. _That_ is best done by a code inspection, letting a second team write the same expression and comparing outputs or running test cases at "boundary values" (e.g. here, for y = -4, -3, -2). Checking the individual conditions strikes me to be more about testing the CPU's ALU or maybe testing the compiler output. It is certainly suitable for checking manually written assembler code or verifying manually assembled logic. And this makes me think that "condition testing" could well be a leftover from the days where conditions were actually wired up on panels (for example in the ENIAC) and might thus be subject to wiring bugs. These days, the condition is written in high-level code and is _exactly_ the one you conceptually want. While review might be useful, a testing of the condition is just a waste of time. Or am I missing something? **Addendum: Literature Search** A search of the IEEE Xplore library for "condition testing" yields only two papers relevant to software (all the others seem relevant to hardware only), both by K.C. Tai of the Department of Computer Science of North Carolina State University. Checking one of those, Condition-based software testing strategies reveals that the author uses the term _condition_ in the sense of _decision_ above, i.e. in this paper "condition testing" is actually "decision testing". The _condition_ as used in the TTA syllabus is called _simple condition_. It seems the TTA syllabus definitions are not widely used. From the abstract: > A computer program consist of statements, such as IF and WHILE statements, > that contain conditions, which are combinations of Boolean and relational > expressions. A testing approach, referred to as _condition testing_ , is to > test a program by focusing on testing the conditions in this program. A > number of condition testing strategies have been developed, but they are not > effective for detecting errors in complicated conditions. In this paper, we > define two condition testing strategies, based on the detection of Boolean > and relational expression [i.e. expression of the form E1 _op_ E2, where E1 > and E2 are arithmetic expressions and _op_ is one of six possible relational > operators: < <=, =, !=, >, >=] errors in a condition. For these two > condition testing strategies, we show some theoretical properties and > explain why they are practical and effective for testing programs containing > complicated conditions.