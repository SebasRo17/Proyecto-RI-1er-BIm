I am trying to solve the following polynomial equations in Mathematica:               e= {-1 + c[1]^2 + s[1]^2, -1 + c[2]^2 + s[2]^2, -1 + c[3]^2 + s[3]^2, -1 +            (-0.70873 c[1] + c[2] - 0.70548 s[1]) y1[ 1], -1 + (-0.916596 c[2] + c[3] +           0.399814 s[2]) y1[ 2], -1 + (c[1] + 0.808085 c[3] + 0.589066 s[3]) y1[ 3],          -1 + (c[1] + 0.808085 c[3] + 0.589066 s[3]) y2[ 1], (-0.70548 c[1] +          0.70873 s[1] + s[2]) y1[ 1] - (-0.589066 c[3] + s[1] + 0.808085 s[3])         y2[1], -1 + (-0.70873 c[1] + c[2] - 0.70548 s[1]) y2[ 2], (0.399814 c[2] +        0.916596 s[2] + s[3]) y1[ 2] - (-0.70548 c[1] + 0.70873 s[1] + s[2]) y2[ 2],         -1 + (-0.916596 c[2] + c[3] + 0.399814 s[2]) y2[ 3], (0.589066 c[3] - s[1] -       0.808085 s[3]) y1[ 3] - (0.399814 c[2] + 0.916596 s[2] + s[3]) y2[3]}      using `NSolve` command. i.e.,               sol = NSolve[e==0, Variables[e]]      I am only interested in real solutions, so in principle I could also use               NSolve[e==0, Variables[e], Reals].      The command indeed solves this system and gives me 8 solutions, all real. However, when I insert them back to the equations to check if the solutions satisfy the equations, they don't!               Do[ Print[eatsol[i] = e /. Thread[var -> sol[[i]]]], {i, lrealsol}]      gives > >     {-1.,-1.,-1.,-1.,-1.,-1.,-1.,0.,-1.,0.,-1.,0.} >     {-1.,-1.,-1.,-1.,-1.,-1.,-1.,0.,-1.,0.,-1.,0.} >     {-1.,-1.,-1.,-1.,-1.,-1.,-1.,0.,-1.,0.,-1.,0.} >     {-1.,-1.,-1.,-1.,-1.,-1.,-1.,0.,-1.,0.,-1.,0.} >     {-1.,-1.,-1.,-1.,-1.,-1.,-1.,0.,-1.,0.,-1.,0.} >     {-1.,-1.,-1.,-1.,-1.,-1.,-1.,0.,-1.,0.,-1.,0.} > > {0.,6.93889*10^-17,7.97973*10^-17,0.,-1.11022*10^-16,-1.11022*10^-16,-1.11022*10^-16,-4.47201*10^-17,0.,1.4905*10^-17,-1.11022*10^-16,-1.82678*10^-18} > > {0.,6.93889*10^-17,7.97973*10^-17,0.,-1.11022*10^-16,-1.11022*10^-16,-1.11022*10^-16,-4.47201*10^-17,0.,1.4905*10^-17,-1.11022*10^-16,-1.82678*10^-18} >   Thus, the first 6 solutions don't even remotely satisfy the equations! I would be fine with some numerical errors etc. but it seems that the infinite solutions also appear here. Do you know what is going on here? Is there any problem with `NSolve`? Update: Please run the below code in Mathematica:               Clear["Global`*"];     e = {-1 + c[1]^2 + s[1]^2, -1 + c[2]^2 + s[2]^2, -1 + c[3]^2 +          s[3]^2, -1 + (-0.5646917067485537` c[1] + c[2] -             0.8253019304045068` s[1]) y1[1], -1 + (0.5033628291371058` c[2] + c[3] -             0.8640751484929357` s[2]) y1[2], -1 + (c[1] - 0.47880555467239877` c[3] +             0.877920976406679` s[3]) y1[3], (-0.8253019304045068` c[1] +             0.5646917067485537` s[1] + s[2]) y1[1] - (-0.877920976406679` c[3] + s[1] -             0.47880555467239877` s[3]) y2[1], -1 + (c[1] - 0.47880555467239877` c[3] +             0.877920976406679` s[3]) y2[1], -1 + (-0.5646917067485537` c[1] + c[2] -             0.8253019304045068` s[1]) y2[2], (-0.8640751484929357` c[2] -             0.5033628291371058` s[2] + s[3]) y1[2] - (-0.8253019304045068` c[1] +             0.5646917067485537` s[1] + s[2]) y2[2], -1 + (0.5033628291371058` c[2] + c[3] -             0.8640751484929357` s[2]) y2[3], (0.877920976406679` c[3] - s[1] +             0.47880555467239877` s[3]) y1[3] - (-0.8640751484929357` c[2] -             0.5033628291371058` s[2] + s[3]) y2[3]};     var = Variables[e];     sol = NSolve[e == 0, var];     lsol = Length[sol];     Do[      Print[Chop[e /. sol[[i]]]],      {i, lsol}]      > >     {-1.,-1.,-1.,-1.,-1.,-1.,0,-1.,-1.,0,-1.,0} >     {-1.,-1.,-1.,-1.,-1.,-1.,0,-1.,-1.,0,-1.,0} >     {-1.,-1.,-1.,-1.,-1.,-1.,0,-1.,-1.,0,-1.,0} >     {-1.,-1.,-1.,-1.,-1.,-1.,0,-1.,-1.,0,-1.,0} >     {-1.,-1.,-1.,-1.,-1.,-1.,0,-1.,-1.,0,-1.,0} >     {-1.,-1.,-1.,-1.,-1.,-1.,0,-1.,-1.,0,-1.,0} >     {0,0,0,0,0,0,0,0,0,0,0,0} >     {0,0,0,0,0,0,0,0,0,0,0,0} >   Basically, the problem is that the solutions given by the `NSolve` command are not actually the solutions of the equations!