In OOP, **static scope** means the scope is linked to the class, and **instance scope** is linked to a specific instance of the class. Some languages support **static locals** , which allow a value to be retained from one call of a function to another, however still in static scope. As you might conclude from some other posts by me here, you can tell I'm a big fan of **encapsulation**. Sometimes I use a certain **instance** variable within a class, **only within one method**. E.g. a flag indicating whether a certain method has already been called. My convention (following good standards) is to place these variables right before the function, close to their usage. Ideally, I would be able to place them **within the function scope**. Following the naming scheme of static locals, let's call this hypothetical scope **function locals**. Darien reworded this very clearly in a comment: > Ah, so what you really want is something beyond even private protection, > which is so closely protected that it is only visible to a single method > within a single instance. Now I know you could say, following the Single Responsibility Principle, this method and the associated variables should most likely be split into a separate class. To verify this - and I challenge you to do the same - I looked into some random code files and quickly found source files (even < 100 lines) where such a 'function local' could be used. Actually, C# offers a solution to this for one common scenario out of the box. Auto-implemented properties hide the backing field. This idea might be far-fetched, but somehow I feel it would make sense. Does anybody know of any language which supports this?