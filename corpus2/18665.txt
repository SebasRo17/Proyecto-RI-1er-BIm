I have a set of set of nested Do loops that require data from three different arrays (though the position from each array is fixed per cycle of the outer Do loop). Let's call these arrays: ListA, ListB, ListC. My attempts at parallelizing the outer Do loop (i.e. using ParallelDo) seem to work, but there is a ~100x slowdown on a 12 core processor. I was hoping someone here could help me understand why. Here's some nonsense pseudocode that should capture the structure of the bit of code I evaluated:               Do[        Do[           Do[              ListA[[i]] = Append[ListA[[i]], ListB[[i, a]] + ListB[[i, b]]];             , {b, (a+1), M}             ];          , {a, 1, M}          ];               ListA[[i]] = Sort[ListA[[i]]];                  Do[             If[Abs[ListA[[i, j]] - ListA[[i, j + 1]]] < ListC[[i]],                  ListC[[i]] = Abs[ListB[[i, j]] - ListB[[i, j + 1]]];               ];           , {j, 1, Length[PairwiseSums[[i]]] - 1}          ];               , {i, 1, Length[AllSubsets]}     ];      Previously defining ListA, ListB, and ListC, and writing:               SetSharedVariable[ListA]     SetSharedVariable[ListB]     SetSharedVariable[ListC]          ParallelDo[        Do[           Do[              ListA[[i]] = Append[ListA[[i]], ListB[[i, a]] + ListB[[i, b]]];             , {b, (a+1), M}             ];          , {a, 1, M}          ];               ListA[[i]] = Sort[ListA[[i]]];                  Do[             If[Abs[ListA[[i, j]] - ListA[[i, j + 1]]] < ListC[[i]],                  ListC[[i]] = Abs[ListB[[i, j]] - ListB[[i, j + 1]]];               ];           , {j, 1, Length[PairwiseSums[[i]]] - 1}          ];               , {i, 1, Length[AllSubsets]}     ];      Yields the ~100x slowdown on a 12 core processor. Why?