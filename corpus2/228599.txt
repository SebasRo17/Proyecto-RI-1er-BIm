I was bitten by using the `is` operator when i should have been using `==`. Am aware that the former tests for equality of the objects' identities and that the latter tests for equality of the objects' contents. Using `is`, i thought, also implicitly tests for the equality of the contents. For example `if a is b` is true, then the contents must be the same. This was the working assumption and i believe that it's still true. But what was discovered, and should have been known, is that if `if a is b` is false, then the contents of a and b may or may not be the same. Example (Python 3.3.3):               class Food:         def favourite_restaurant(self):             return "the foo diner"               if __name__ == '__main__':              fr = "the juice bar"         print('%r  is  %r: %r' % (fr, 'the juice bar', (fr is 'the juice bar')))         print('%r  ==  %r: %r' % (fr, 'the juice bar', (fr == 'the juice bar')))              f = Food()         result = f.favourite_restaurant()         print('%r  is  %r: %r' % (result, 'the foo diner', (result is 'the foo diner')))         print('%r  ==  %r: %r' % (result, 'the foo diner', (result == 'the foo diner')))      The first print block says:               'the juice bar'  is  'the juice bar': True     'the juice bar'  ==  'the juice bar': True      The second print block says:               result: 'the foo diner'     'the foo diner'  is  'the foo diner': False     'the foo diner'  ==  'the foo diner': True      It seems that objects instantiated within the instance of a class have their own group of ids, separate from objects outside the class. My understanding that encapsulation in python is really a matter for 'consenting adults'. Do we actually have encapsulation at some lower level?