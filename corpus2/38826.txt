So I had been looking to solve a little tiling problem and Google turned up this Mathematica Journal Article and I noticed the code was both incomplete and incorrect, so... My Question is, What is missing to make this code actually work? To make this process slightly less time consuming, Here's a rough interpretation of the journal post in actual code form. Some things were changed that were obvious errors like undeclared variables and punctuation. Also there were functions inside of functions, and where it was clear (to me) that method was wrong, they were moved.               lexic[p_] := Sort[p, (Im[#1] < Im[#2]) || ((Im[#1] == Im[#2]) && (Re[#1] <= Re[#2])) &];          tess[{n_, m_}, poly_, justOneSolution_: False] := Module[{avail, pieces, i, j, ans = {}, tessAux, na, ma},tessAux[partial_] := Module[{f, c, candidates, newp, k},     candidates = Complement[avail, Flatten@partial];     If[candidates == {},     AppendTo[ans, partial]; If[justOneSolution, Throw[1]],     k = First@lexic@candidates;     Map[(newp = k + # - First[#];      If[(Complement[newp, avail] == {}) && (f =           Flatten[{partial, newp}];         Length@f == Length@Union@f),        tessAux[Append[partial, newp]]]) &, pieces]]];     {na, ma} = If[n < m, {m, n}, {n, m}];     pieces = lexic /@ Union[Flatten[pieces /@ poly, i]];     avail = Flatten[Table[i + j*i, {j, 0, na - i}, {i, 0, ma - 1}]];     Catch[tessAux[{}];     If[n < m, Map[m - 1 + i # &, ans], ans]];          getLines[tiling_] := Module[{p},     Partition[Flatten[Map[(p = #;      Map[{If[Not[MemberQ[p, # + 1]], {# + 1 + i}, {}],     If[Not[MemberQ[p, # + i]], {# + i, # + 1 + i}, {}]} &, p]) &, tiling]], 2]];          tile[{n_, m_}, poly_, r_, justOneSolution_: False] := Module[{t, u, g},     t = tess[{n, m}, poly, justOneSolution];     g = Map[Graphics[Append[{{LightBlue, Rectangle[{0, 0}, {m, n}]},     Line[{{0, n}, {0, 0}, {m, 0}}]},     lexic /@ getLines[#]]] &, t];     Show[GraphicsArray[Partition[If[Mod[Length[t], r] == 0, g,          Join[g,Table[Graphics[Point[{0, 0}]], {r - Mod[Length[t], r]}]]], r]]]      ]