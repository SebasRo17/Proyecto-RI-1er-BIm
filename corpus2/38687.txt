Consider this three-body system:               g = 10; (* gravitational constant *)     m = {100, 1, 1}; (* masses *)     μ0 = g*m; (* gravitational parameters *)     r0 = {{0, 0, 0}, {1, 0, 0}, {-1.1, 0, 0}}; (* initial location vectors *)     v0 = {{0, 0, 0}, {0, 30, 0}, {0, -30.1, 0}}; (* initial velocity vectors *)      Differential equations for velocities and positions:               jmax = Length[m];     v = Evaluate[#] & /@      Table[ToExpression["v" <> ToString[j]], {j, jmax}];     r = Evaluate[#] & /@      Table[ToExpression["r" <> ToString[j]], {j, jmax}];     eqns[μ_List] := Flatten[Table[{     v[[j]]'[t] ==       Sum[(-Normalize[r[[j]][t] - r[[i]][t]]*μ[[i]])/       EuclideanDistance[r[[j]][t], r[[i]][t]]^2, {i,         Delete[Range[jmax], j]}],     r[[j]]'[t] == v[[j]][t],     v[[j]][0] == v0[[j]],     r[[j]][0] == r0[[j]]     }, {j, jmax}]]     fns = Flatten[Table[{v[[j]][t], r[[j]][t]}, {j, jmax}]]      The numerical integration stops when two bodies collide:               μ = μ0;     sol = NDSolve[eqns[μ], fns, {t, 0, 10}][[1]]     vel = (fns /. sol)[[1 ;; -2 ;; 2]];     pos = vel = (fns /. sol)[[2 ;; -1 ;; 2]];      > NDSolve::ndsz: At t == 2.393483348087306`, step size is effectively zero; > singularity or stiff system suspected. >> The solution:               tmax = 2.393483348087306;     ParametricPlot3D[pos, {t, tmax - .1, tmax},       PlotRange -> {All, All, {-.01, .01}}, ImageSize -> 800,       PlotPoints -> 500, MaxRecursion -> 15]      ![collision plot](http://i.stack.imgur.com/yAqA5.png) I would like to detect collisions and modify the computation so that the masses (and in effect, gravitational parameters) and velocities of the collided bodies change: one body's new mass becomes the sum of both masses and the new velocity becomes the sum of both velocities; the other body's new mass and velocity become zero. I have tried to do it with `WhenEvent`:               μ = μ0;     sol = NDSolve[     Append[eqns[μ],      WhenEvent[Length[$MessageList] > 0, Print[tmax = t];      dist =        Table[EuclideanDistance[r[[j + 1]][t], r[[j]][t]], {j,          Length[r] - 1}];      distDif = Table[Abs[dist[[n + 1]] - dist[[n]]], {n, Length[dist] - 1}];      p = Position[distDif, Min[distDif]][[1, 1]];      μ[[p]] += μ[[p + 1]]; μ[[p + 1]] = 0;      v[[p]][t] += v[[p + 1]][t]; v[[p + 1]][t] = 0;      "RestartIntegration"]], fns, {t, 0, 10}][[1]]     vel = (fns /. sol)[[1 ;; -2 ;; 2]];     pos = vel = (fns /. sol)[[2 ;; -1 ;; 2]];      However, this does not work. It seems that I do not catch the error properly, the program aborts before the message can be caught. How to catch this properly?