> Backtracking is a general algorithm for finding all (or some) solutions to > some computational problem, that incrementally builds candidates to the > solutions, and abandons each partial candidate _c_ ("backtracks") as soon as > it determines that _c_ cannot possibly be completed to a valid solution. > (from Wikipedia) In pseudo-code, a backtracking algorithm looks something like this:                procedure bt(c)        if reject(P,c) then return        if accept(P,c) then output(P,c)        s ← first(P,c)        while s ≠ Λ do          bt(s)          s ← next(P,s)      Here,   1. `root(P)`: return the partial candidate at the root of the search tree.   2. `reject(P,c)`: return `true` only if the partial candidate `c` is not worth completing.   3. `accept(P,c)`: return `true` if `c` is a solution of `P`, and `false` otherwise.   4. `first(P,c)`: generate the first extension of candidate `c`.   5. `next(P,s)`: generate the next alternative extension of a candidate, after the extension `s`.   6. `output(P,c)`: use the solution `c` of `P`, as appropriate to the application. The backtracking algorithm then starts with the call `bt(root(P))`. I'm trying to program this as efficiently as possible in Mathematica. I have already coded the pertinent `root`, `reject`, `accept`, `first`, and `next` functions. Since I only need to obtain one solution, I am doing the `output` through a `Throw`, `Catch` combo. Given that one has the basic logic of `root`, `reject`, ..., already coded, are there alternative ways to program the backtracking loop (procedure `bt` above) in Mathematica? What I have in mind is a substitution of `while` with something more Mathematica friendly, such as `Fold` or `Map`, but I have no idea of how to do this.