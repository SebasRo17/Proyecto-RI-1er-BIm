There has been a great deal of discussion on local variables in Modules and Manipulate. If I am reading this correctly, local variables in a language such as C++ or C# are not exactly analogous to local variables in a Mathematica Module or Manipulate. Developers such as myself who come from a C++, C# background find the ability to restrict the scope of variables to a function very useful. These are often used because they minimize the risk of unintended changes to variable values. This is especially true if writing Modules or Custom Controls that other Mathematica developers may use. I don't want to run the risk of stepping on someone else's variable when they use my code. Is there a way to implement local variables in Modules or DynamicModules so they are not accessible and visible to the notebooks or code calling the Mathematica code? I have noticed that if I use the option LocalizeVariables->True in a Manipulate, the variables used by Manipulate as parameters that set the range and step value of the variable that as soon as the Needs[] is executed on the .m file containing my Module that all variables are visible and settable. I don't have to call the Module[] - just execute the Needs[] for the package or nb that contains the Module. This is a popular topic and with good reason. Below is an example:               BeginPackage["MyPackage`"]            LocalTestModule[]=Module[{localX, localY},                 localX=1; localY=2;]          EndPackage[]      I open a Mathematica notebook and issue the following command:               Needs["MyPackage`"]      My expectation is that I should not be able to set the value of the `localX` variable from the notebook because it is local to `LocalTestModule`. If it is truly local to LocalTestModule[], it should not be visible outside of `LocalTestModule[]`. However:               Information[localX]      returns `MyPackage`localX` And:               MyPackage`localX = 10      returns `10` In C or C++, a calling function would not have access to localX.