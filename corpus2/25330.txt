This is something that got me curious while I was playing around with _Mathematica_. Consider the following (contrived) example:               Clear[x,y];     {{1, 2}, {3, 4}, {5, 6}} /. {x_, y_} :> {x, #} & /@ {y, y^2, y^3}     (* {{{1, 2}, {3, 4}, {5, 6}}, {{1, 4}, {3, 16}, {5, 36}}, {{1, 8}, {3,      64}, {5, 216}}} *)      No problems there. Now suppose `y` has been defined globally, so               y = 10;     {{1, 2}, {3, 4}, {5, 6}} /. {x_, y_} :> {x, #} & /@ {y, y^2, y^3}     (* {{{1, 10}, {3, 10}, {5, 10}}, {{1, 100}, {3, 100}, {5, 100}}, {{1,      1000}, {3, 1000}, {5, 1000}}} *)      The problem is that y gets evaluated to 10 before getting mapped to the delayed rule's rhs. I realised I could do               {{1, 2}, {3, 4}, {5, 6}} /. {x_, y_} :> {x,       ReleaseHold[#]} & /@ Thread[Hold[{y, y^2, y^3}]]     (* {{{1, 2}, {3, 4}, {5, 6}}, {{1, 4}, {3, 16}, {5, 36}}, {{1, 8}, {3,      64}, {5, 216}}} *)      which looks kinda complicated, but works. So, is there any better way to "shield" the `y` in the list being mapped over, from the global variable `y`? I sort of randomly tried   Module[{y}, {{1, 2}, {3, 4}, {5, 6}} /. {x_, y_} :> {x, #} & /@ {y, y^2, y^3}] but in this case the temporary variable's name(?) got substituted               (* {{{1, y$119596}, {3, y$119596}, {5, y$119596}}, {{1, y$119596^2}, {3,         y$119596^2}, {5, y$119596^2}}, {{1, y$119596^3}, {3,         y$119596^3}, {5, y$119596^3}}} *)