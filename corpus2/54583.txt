I have written a small Mathematica package that contains a module that solves some differential equation with initial conditions. Suppose that the solution to this differential equation defines some other functions _y(t)_ and _z(t)_. I want this function to return these functions _y_ and _z_ as rules, much as NDSolve returns a rule for evaluating a function. Here is my first naive attempt to do this:               SolveEquation[x_, xp0_, x0_] := Module[{y, z},       sol = Flatten[         NDSolve[{x''[t] + x'[t]^3 == x[t]^2, x'[0] == xp0,            x[0] == x0}, {x}, {t, 0, 100}]];       y[t_] := (x[t] /. sol)^1/2;       z[t_] := y'[t] /. y[t];       Return[Join[sol, {Symbol["y"] -> Function[t, y[t]],Symbol["z"] -> Function[t, z[t]]}]]]      ` I can then correctly access the values of these functions with               rules=SolveEquation[x,0,100];     y[3]/.rules     9.89546      ` However, a call to _rules_ itself gives me:               {x -> InterpolatingFunction[{{0.,100.}},<>],y -> Function[t$, y$5338[t$]],       z -> Function[t$, z$5338[t$]]}      ` This is okay but in terms of human readability (the code will be used by individuals besides myself), I would much prefer:               {x -> InterpolatingFunction[{{0.,100.}},<>],y -> Function[t, y[t]],       z -> Function[t,z[t]}      ` or even better:               {x -> InterpolatingFunction[{{0.,100.}},<>],y -> x[t]^1/2,       z -> y'[t]/y[t]}      ` or some other way in which the dependence of each function on the others is made explicit. Is it possible to achieve this result by somehow changing the scoping of these variables or do I need to just settle for my method that works but appears sloppy?