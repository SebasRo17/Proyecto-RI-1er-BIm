I've got a few files which are used in several of my repos:   * `functions.sh`, shell library to for example print a colored warning/error message or the documentation of a script file.   * `Makefile`; a standardized one which installs the file `$(CURDIR)/[dirname].sh` to `$(PREFIX)/[dirname]` and references a test script.   * `LICENSE`.   * `tools.mk`; Makefile commands to for example print all the variable definitions in the parent `Makefile`. These are more or less stable, and some are used in probably over a dozen repos. I've been thinking _how to keep this DRY_ , but none of the options so far seem satisfactory:   1. Keep doing it like now, creating a **copy for each new repo.** This keeps the code together with all its dependencies (avoiding bugs when the general solution is not general enough), but changes which are applicable in multiple places have to be applied in each separately.   2. Add an **executable** to each of the repositories to **download the files** needed. This means that developers and end users will have to run an extra command to get all the relevant files, and it breaks the possibility for developers to modify and `commit`/`push` the included files.   3. Use **`git submodule` or equivalent.** This at least keeps the repositories connected, but in the Git case it seems like it's restricted to "a dedicated subdirectory", so no top-level files, and no mixing with parent repository files which belong in the same directory. This could be circumvented with symlinks, but that's an ugly workaround for the obvious ideal situation. The _ideal solution_ should:   1. **Communicate with the correct repository** when doing an operation on a file.   2. Allow includes in the **same directories as the parent directory**.   3. **A single, simple command** should be enough to update the entire repository and all includes, no matter how many or how deeply nested.   4. Allow includes in the **top-level directory**.   5. **Not incur** significant developer or user **constraints** (must be online while installing) or **extra work** (running a "pre-install" command separately from the "install" command).   6. Allow **"cherry-picking" of files** to include. Many projects might need a different `Makefile`, for example, and including one which is not used is just ugly (and would get uglier as more files are added). Is this sort of thing possible with current software?