Word clouds are ~~rather useless~~ fancy and visually appealing plots, where words are plotted with different sizes according to their frequency in a corpus. Many applications exist out there (Wordle, Tagxedo, etc.) that can give an example. I am interested in the algorithm that achieves the closest possible packing of words or other irregular shapes. There is a method for defining the convex hull of an object (in the Computational geometry package), but I think one needs here the boundary that closes the least area. If this is calculated, perhaps the packing method of graph layout can be exploited by assuming that points on the hull of a word correspond to graph vertices... but this is just speculation. So far I could only list and style the words (that was the easy part):               tally = Tally@        Cases[StringSplit[ExampleData[{"Text", "AliceInWonderland"}],           Except@LetterCharacter], _?(StringLength@# > 4 &)];     tally = Cases[tally, _?(Last@# > 10 &)];     range = {Min@(Last /@ tally), Max@(Last /@ tally)};          words = Style[First@#, FontFamily -> "Cardinal", FontWeight -> Bold,           FontColor ->            Hue[RandomReal[], RandomReal[{.5, 1}], RandomReal[{.5, .8}]],           FontSize -> Last@Rescale[#, range, {12, 70}]] & /@ tally;          Framed[Grid@Partition[words, 10, 10, {1, 1}, {}],       FrameStyle -> {Gray, Thick}, RoundingRadius -> 10, ImageMargins -> 5]      ![Mathematica graphics](http://i.stack.imgur.com/VMSYz.png) Some possible specifications of the algorithm:   * According to this link (shared by cormullion) identifying the closest boundary of each word is not enough as words can appear **inside** other glyphs with holes, like P, A, etc. Thus indeed intersection of words must be tested.   * According to Szabolcs, the code might be able to **resize words** to fit them better   * Many applications are able to arrange the cloud to **fill up a user-specified shape** (e.g. ellipse, apple, Che Guevara, etc.) instead of being casually positioned along the ever-increasing spiral.   * It would be nice to allow individual words to have **different rotations**.   * As usually, a fully **vectorized** version is preferred over image-processing methods (if the former is faster).   * Also it would be nice to have post-rendering effects, like clickable words, mouseover effects, etc. One way to convert strings to vector graphics is:               First@ImportString[      ExportString[        Style["SomeText", Italic, FontFamily -> "Times", FontSize -> 36],         "PDF"], "PDF", "TextMode" -> "Outlines"]      Some related questions for those who want to do further research:   * Computing Text bounding boxes   * How to determine the convex hull of some text?   * How to partition a disk into individually spaced bricks?   * Character edge finding   * Intersecting graphics   * Algorithm to implement a word cloud like Wordle (thanks to cormullion for the link)