I have a conceptual problem with a proper implementation of code which seems require multiple inheritance, that would not be a problem in many OO languages, but as the project is for Android, there is no such thing like multiple `extends`. I have a bunch of activities, derived from different base classes, such as simple `Activity`, `TabActivity`, `ListActivity`, `ExpandableListActivity`, etc. Also I have some code fragments which I need to place into `onStart`, `onStop`, `onSaveInstanceState`, `onRestoreInstanceState` and other standard event handlers in all activities. If I have a single base class for all activities, I'd place the code into a special intermediate derived class, and then create all activities extending it. Unfortunately, this is not the case, because there are multiple base classes. But placing the same portions of code into several intermediate classes is not a way to go, imho. Another approach could be to create a helper object and delegate all calls of the abovementioned events to the helper. But this requires the helper object to be included, and all handlers to be redefined in all intermediate classes. So there is no much difference to the first approach here - still a lot of code duplicates. If a similar situation occured under Windows, I'd subclass base class (something that "corresponds" to the `Activity` class in Android) and trap appropriate messages there (in a single place). What can be done in Java/Android for this? I know there is interesting tools such as Java instrumentation (with some real examples), but I'm not a Java guru, and not sure if it's worth trying in this specific case. If I missed some other decent solutions, please, mention them. **UPDATE:** For those who may be interested in solving the same problem in Android I've found a simple workaround. There exist the Application class, which provides, among other things, the interface ActivityLifecycleCallbacks. It does exactly what I need allowing us to intercept and add some value into important events for all activities. The only drawback of this method is that it's available starting from API level 14, which is not enough in many cases (support for API level 10 is a typical requirement today).