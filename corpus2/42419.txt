I noticed an over 10x performance drop on Mathematica v9.0.1 (as Oleksandr R. commented, also v8) compared with v7.01 for this code:               SetSystemOptions["CatchMachineUnderflow" -> False];     AbsoluteTiming@       Fold[{(#[[1]] Sin[10.5])/(#2 + 1), #[[2]] + Tan[#[[1]]]} &,        {Sin[10.5], 1.0}, N@Range[10^6]]       I got `{0.184287, {0., 0.105747}}` on v7, but got `{2.311755, {0., 0.105747}}` on v9. Note that the Do[...] version of above code needs about 2 seconds. Thus I suspect that on v9 the Fold code is not properly auto-compiled. Is this a regression? (Also is there a way to see if auto-compile worked or not?) **Additional information** I compared that in v7 and v9 the CompileOptions are the same (except that v9 has some options that are not present in v7):               SystemOptions[CompileOptions]      > {"CompileOptions" -> {"ApplyCompileLength" -> [Infinity], > "ArrayCompileLength" -> 250, "AutoCompileAllowCoercion" -> False, > "AutoCompileProtectValues" -> False, "AutomaticCompile" -> False, > "BinaryTensorArithmetic" -> False, "CompileAllowCoercion" -> True, > "CompileConfirmInitializedVariables" -> True, > "CompiledFunctionArgumentCoercionTolerance" -> 2.10721, > "CompiledFunctionMaxFailures" -> 3, "CompileDynamicScoping" -> False, > "CompileEvaluateConstants" -> True, "CompileOptimizeRegisters" -> False, > "CompileParallelizationThreshold" -> 10, "CompileReportCoercion" -> False, > "CompileReportExternal" -> False, "CompileReportFailure" -> False, > "CompileValuesLast" -> True, "FoldCompileLength" -> 100, > "InternalCompileMessages" -> False, "ListableFunctionCompileLength" -> 250, > "MapCompileLength" -> 100, "NestCompileLength" -> 100, > "NumericalAllowExternal" -> False, "ProductCompileLength" -> 250, > "ReuseTensorRegisters" -> True, "SumCompileLength" -> 250, > "SystemCompileOptimizations" -> All, "TableCompileLength" -> 250}} To compare, I also tried the following code, where the performance on v7 and v9 are roughly the same (v9 is on average 5% more slowly though).               AbsoluteTiming@Fold[# + Sin[#2] &, 1.0, Range[10^6]]      A difference is that here the first argument of function in Fold is a number, and in the problematic example, the first argument is a list. PS: I noticed this issuee during a discussion at About auto-compiling and performance between Do and Fold . But considering this regression issue is a different question, I ask here separately.