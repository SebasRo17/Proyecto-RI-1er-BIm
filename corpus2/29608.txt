This example works to define `InverseFunction` on the first argument of a function               f = Function[{##} /. {x_, y_} :> Beta[x, y] - x + y];     g = InverseFunction[f, 1, 2];     g[3, 4]     (*Root[{1 + Beta[#1, 4] - #1 &, 1.17659010788279817113535497590}]*)     N[%]     (* 1.17659 *)      When changing the definition of `f` to use `x_Integer` instead of `x` it no longer works               f = Function[{##} /. {x_Integer, y_Integer} :> Beta[x, y] - x + y];     g = InverseFunction[f, 1, 2];     g[3, 4]      Returns unevaluated               InverseFunction[{##1} /. {x_Integer, y_Integer} :> Beta[x, y] - x + y &, 1, 2][3, 4]      How to make `InverseFunction` work on functions defined with restrictions on its arguments? I looked at `ConditionalExpression` but could not figure how to use it here. V 9.01 on windows