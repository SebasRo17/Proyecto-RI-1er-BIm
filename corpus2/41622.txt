Assume I have a complicated integral $I$ which can feature all kinds of difficulties like infinite interval, rapidly oscillatory integrand, integrable singularities and numerically almost singular points in the integrand. Assume further that I need to compute it many times, so I need to optimize speed. I figured that I need to help Mathematica a bit to avoid problems such as `NIntegrate::slwcon` if I do not want to increase `MaxIterations`, `MinIterations`, `WorkingPrecision` a lot, which would decrease speed. So I decompose the domain of integration into several $I=I_1+I_2+I_3\ldots I_n$ ($n$ finite). `NIntegrate` behaves better now and I can manually perform integral transformations and choose well suited Methods for the different domains. However: With fixed `AccuracyGoal` and `PressicionGoal` for each of $I_i$ `NIntegrate` will choose sufficiently many sampling points and iterations to achieve these error levels, even if the total contribution of $I_i$ is negligibly small. How would you proceed (how would you choose `AccuracyGoal` and `PressicionGoal` for the individual integrands) to reduce the total number of integrand evalutations to the minimum required as to achieve given global values of `AccuracyGoal` and `PressicionGoal`? Since the integrand of $I$ is fixed I can reorder $I_i$ such that difficult but possibly small ones appear late and I can use the previous results as estimates for the total value of $I$. However assume that I do not have any analytic estimates for $I_i$.