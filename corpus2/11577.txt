I was recently introduced to the `LetL` macro thanks to Leonid's answer to one of my prior questions. I was, needless to say, impressed by the simplicity of its recursive definition. However, I noticed that it may not necessarily be optimized. As it is defined, if my `LetL` statement contains a definition which does not need to be nested, then it will call `With` unnecessarily:               testLetL := LetL[{x = 1, y = 2, z = 2 x y}, {x, y, z}]     ?testLetL     (* testLetL:=With[{x=1},With[{y=2},With[{z=2 x y},{x,y,z}]]] *)      So I compared it to `Module`.               testModule := Module[{x = 1, y = 2, z}, z = 2 x y; {x, y, z}]     (Do[#, {i, 5000000}] // AbsoluteTiming) & /@ {testLetL, testModule}     (* {{0.9390537, Null}, {0.9270530, Null}} *)      As you can see, there doesn't seem to be much speed gained in using `LetL` \- essentially nested `With`s - instead of `Module`. I thought perhaps that it was the extra `With` being called that was slowing things down. So I tried another test:               testLetL2 := LetL[{x = 1, y = 2 x }, {x, y}]     testModule2 := Module[{x = 1, y}, y = 2 x ; {x, y}]     (Do[#, {i, 5000000}] // AbsoluteTiming) & /@ {testLetL2, testModule2}     (* {{0.9270531, Null}, {0.9120521, Null}} *)      This again showed that they were pretty much the same, if not `Module` being a bit faster. * * * My question is, then, is `LetL` simply used for convenience or are my tests missing something?