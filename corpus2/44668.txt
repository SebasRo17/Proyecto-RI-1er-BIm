Given a large (say 10x10) sparse Hermitian matrix with symbolic entries, I need four specific entries of the inverse matrix. It seems wasteful to me to compute 100 entries of which I only need a few in the end. Is there a way to compute a small number of specific entries of the inverse matrix that is significantly more efficient than finding the inverse matrix and then extracting the elements? Here's an example. N is half the dimension of the matrix. For N = 8, inverting takes 51 seconds on my university's computer, and we would ideally like to reach much larger N.               A = Table[If[Abs[i - j] == 1, (j - i) a, 0], {i, #}, {j, #}] &;     B = Table[If[Abs[i - j] == 1, b, 0], {i, #}, {j, #}] &;          \[Sigma]1[N_] := B@N + Table[         If[Abs[i - j] == 0, 2 \[Mu], 0] + If[i == j == 1, -x, 0] +           If[i == j == N, -x, 0]         , {i, N}, {j, N}];     \[Sigma]2[N_] := -B@N + Table[         +If[i == j == 1, -y, 0] + If[i == j == N, -y, 0]         , {i, N}, {j, N}];          (* Elements of M *)     el[N_, i_, j_] := Which[i <= N && j <= N,       \[Sigma]1[N][[i, j]], i > N && j > N,       \[Sigma]2[N][[i - N, j - N]], i > N && j <= N,       A[N][[i - N, j]], i <= N && j > N,       -A[N][[i, j - N]]]           M[N_] := Table[el[N, i, j], {i, 2 N}, {j, 2 N}];      Daniel Lichtblau's idea `LinearSolve[M@8,UnitVector[16,8]]` takes 4.1 seconds, so it is certainly much faster than inverting the entire matrix, even if it has to be done seperately for each entry.