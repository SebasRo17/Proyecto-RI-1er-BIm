Is it possible to write a function in such manner, that it can be either evaluated or left unevaluated? This is a general question. Sample below is just a sample. No need to find solution for this sample. Need a general solution. Hypothetical sample:               F[x_] := If[x>=0,         Sqrt[x],         Fail[]     ];      So that it gives               F[4]     (* ==> 2 *)      But               F[-4]     (* ==> F[-4] *)      I.e. hypothetical function `Fail[]` stays for "drop evaluation and leave expression unevaluated". I know I can use `Condition`               F[x_] := Sqrt[x] /; x >= 0      But I wish to do that in imperative programming way. Is this possible? **UPDATE** I don't understand why this is not working:               F[x_] := Block[{fail},       (If[x >= 0,          fail = False;          Sqrt[x],          fail = True          ]) /; ! fail]      **UPDATE 1** Manual has a good example               f[x_] := Module[{a}, a = Prime[10^x];       (FactorInteger[a + 1]) /; a < 10^6]      which is checking internal variables, not arguments. But why my version above not works then?