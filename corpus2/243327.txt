_Disclaimer: I'm sure someone is going to moan about easy-of-use, for the purpose of this question consider readability to be the only factor that matters_ So I found this site that converts to easting northing, **it's not really important what that even means** but here's how the piece of javascript looks.               /**      * Convert Ordnance Survey grid reference easting/northing coordinate to (OSGB36) latitude/longitude      *      * @param   {OsGridRef} gridref - easting/northing to be converted to latitude/longitude      * @returns {LatLonE} latitude/longitude (in OSGB36) of supplied grid reference      */     OsGridRef.osGridToLatLong = function(gridref) {         var E = gridref.easting;         var N = gridref.northing;              var a = 6377563.396, b = 6356256.909;         // Airy 1830 major & minor semi-axes         var F0 = 0.9996012717;                        // NatGrid scale factor on central meridian         var φ0 = 49*Math.PI/180, λ0 = -2*Math.PI/180; // NatGrid true origin         var N0 = -100000, E0 = 400000;                // northing & easting of true origin, metres         var e2 = 1 - (b*b)/(a*a);                     // eccentricity squared         var n = (a-b)/(a+b), n2 = n*n, n3 = n*n*n;    // n, n², n³              var φ=φ0, M=0;         do {             φ = (N-N0-M)/(a*F0) + φ;                  var Ma = (1 + n + (5/4)*n2 + (5/4)*n3) * (φ-φ0);             var Mb = (3*n + 3*n*n + (21/8)*n3) * Math.sin(φ-φ0) * Math.cos(φ+φ0);             var Mc = ((15/8)*n2 + (15/8)*n3) * Math.sin(2*(φ-φ0)) * Math.cos(2*(φ+φ0));             var Md = (35/24)*n3 * Math.sin(3*(φ-φ0)) * Math.cos(3*(φ+φ0));             M = b * F0 * (Ma - Mb + Mc - Md);              // meridional arc              } while (N-N0-M >= 0.00001);  // ie until < 0.01mm              var cosφ = Math.cos(φ), sinφ = Math.sin(φ);         var ν = a*F0/Math.sqrt(1-e2*sinφ*sinφ);            // nu = transverse radius of curvature         var ρ = a*F0*(1-e2)/Math.pow(1-e2*sinφ*sinφ, 1.5); // rho = meridional radius of curvature         var η2 = ν/ρ-1;                                    // eta = ?              var tanφ = Math.tan(φ);         var tan2φ = tanφ*tanφ, tan4φ = tan2φ*tan2φ, tan6φ = tan4φ*tan2φ;         var secφ = 1/cosφ;         var ν3 = ν*ν*ν, ν5 = ν3*ν*ν, ν7 = ν5*ν*ν;         var VII = tanφ/(2*ρ*ν);         var VIII = tanφ/(24*ρ*ν3)*(5+3*tan2φ+η2-9*tan2φ*η2);         var IX = tanφ/(720*ρ*ν5)*(61+90*tan2φ+45*tan4φ);         var X = secφ/ν;         var XI = secφ/(6*ν3)*(ν/ρ+2*tan2φ);         var XII = secφ/(120*ν5)*(5+28*tan2φ+24*tan4φ);         var XIIA = secφ/(5040*ν7)*(61+662*tan2φ+1320*tan4φ+720*tan6φ);              var dE = (E-E0), dE2 = dE*dE, dE3 = dE2*dE, dE4 = dE2*dE2, dE5 = dE3*dE2, dE6 = dE4*dE2, dE7 = dE5*dE2;         φ = φ - VII*dE2 + VIII*dE4 - IX*dE6;         var λ = λ0 + X*dE - XI*dE3 + XII*dE5 - XIIA*dE7;              return new LatLonE(φ.toDegrees(), λ.toDegrees(), GeoParams.datum.OSGB36);     }      I found that to be a really nice way of writing an algorythm, at least as far as redability is concerned. Is there any way to easily write the special symbols. And by easily write I mean NOT copy/paste them.