I'm thinking about building an Open Source, serverless, offline-replicated p2p CMS, but I'm concerned about it really working in a real environment. How would you go about doing that, reducing the exposition to risks/bugs? _I've thought about this schema for now._ On the local device we have a folder called "cmsfiles" containing the software's files and a subfolder "database-shards", inside this subfolder we have: shard0.sqlite, shard1.sqlite, shard2.sqlite and so on.. each shard has a cap of 50GB. Inside these shards we'll assign the tables in a random way, being: comments, posts, answers, users etc. If a device visits a portal, it has read-only access and to interact it has to have a locally installed instance, with the same content as explained above. When he installs the software, he's asked for a nick and a password, that will then be saved on a private key for later verification. When a device does an insert (an answer to a post in this case), it has to send other information as well. _**Locally, the request is processed in the following way:_** The remote peer is asked for his ip address/proxy/tor-node and hardware UUID. A check is then done to determine if the remote peer is in the blacklist list, if TRUE, the whole operations/negotiations are discarded, but if it evaluate FALSE, a checking is done to see if it's present in the "breaking attempt log" list and if the number is less than 5 && not equal to 0, the number is ++incremented, at the same time all the operations are discarded with the remote peer. Else, if the number equal 0, we proceed to further verification. The remote peer's message (answer), private key and files in the "cmsfiles" folder are fetched. The files are now being compressed locally to cmsfiles.lz, hashing and comparing. This hash is then compared to the local one and if they're not equal, the number in the "breaking attempt log" list is ++incremented and all the operations being done discarded. But if they match, we proceed signing the remote private key with the public key, if it signs successfully, we check if the post (the answer) already exists. If it exists (if TRUE), the number in the "breaking attempt log" is ++incremented and any operation discarded, else (if FALSE) we check if post votes equal 0 (a new post cannot have more than 0 votes!), if it doesn't, the number in "breaking attempt log" list is ++incremented and any operations discarded. Otherwise, if it indeed equals 0 we can finally add the message (answer) to the local database. I'm including a tree schema representation just in case: ![example tree](http://i.stack.imgur.com/7m7Xe.jpg)