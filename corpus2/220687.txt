I have just realized something disturbing. Every time I have written a method that accepts a `std::string` as a paramater, I have opened up myself to undefined behaviour. For example, this...               void myMethod(const std::string& s) {          /* Do something with s. */     }      ...can be called like this...               char* s = 0;     myMethod(s);      ...and there's nothing I can do to prevent it (that I am aware of). So my question is: How does someone defend themself from this? The only approach that comes to mind is to always write two versions of any method that accepts an `std::string` as a parameter, like this:               void myMethod(const std::string& s) {         /* Do something. */     }          void myMethod(char* s) {         if (s == 0) {             throw std::exception("Null passed.");         } else {             myMethod(string(s));         }     }      Is this a common and/or acceptable solution? **EDIT:** Some have pointed out that I should accept `const std::string& s` instead of `std::string s` as a parameter. I agree. I modified the post. I don't think that changes the answer though.