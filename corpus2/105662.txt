One thing that I've never quite come to terms with in Haskell is how you can have polymorphic constants and functions whose return type cannot be determined by their input type, like               class Foo a where         foo::Int -> a      Some of the reasons that I do not like this: **Referential transparency:** "In Haskell, given the same input, a function will always return the same output", but is that really true? `read "3"` return 3 when used in an `Int` context, but throws an error when used in a, say, `(Int,Int)` context. Yes, you can argue that `read` is also taking a type parameter, but the implicitness of the type parameter makes it lose some of its beauty in my opinion. **Monomorphism restriction:** One of the most annoying things about Haskell. Correct me if I'm wrong, but the whole reason for the MR is that computation that looks shared might not be because the type parameter is implicit. **Type defaulting:** Again one of the most annoying things about Haskell. Happens e.g. if you pass the result of functions polymorphic in their output to functions polymorphic in their input. Again, correct me if I'm wrong, but this would not be necessary without functions whose return type cannot be determined by their input type (and polymorphic constants). So my question is (running the risk of being stamped as a "discussion quesion"): _Would it be possible to create a Haskell-like language where the type checker disallows these kinds of definitions? If so, what would be the benefits/disadvantages of that restriction?_ I can see some immediate problems: If, say, `2` only had the type `Integer`, `2/3` wouldn't type check anymore with the current definition of `/`. But in this case, I think type classes with functional dependencies could come to the rescue (yes, I know that this is an extension). Furthermore, I think it is a lot more intuitive to have functions that can take different input types, than to have functions that are restricted in their input types, but we just pass polymorphic values to them. The typing of values like `[]` and `Nothing` seems to me like a tougher nut to crack. I haven't thought of a good way to handle them. I doubt I am the first person to have had thoughts like these. Does anybody have links to good discussions about this Haskell design decision and the pros/cons of it?