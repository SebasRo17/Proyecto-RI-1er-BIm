I am putting this question to C++ programmers because: a) Only a C++ programmer can judge the technical merits of the examples; b) Only a programmer will have a feel for the temperament of another programmer who writes code like this. HR and the directors are aware there is a problem simply because they see evidence in the field. It's my call whether we give the programmer in question more time. Many of the errors are at a very basic level - my question (to programmers) is whether someone who professes to be a senior C++ developer should be given a benefit of a doubt based on samples of their current code. Non-programmers - even people outside C++ programming - can't make any judgement on this. For background, I've been assigned the task of managing developers for a well- established company. They have a single developer who specialises in all their C++ coding (since forever), but the quality of the work is abysmal. Code reviews and testing have revealed many problems, one of the worst being memory leaks. The developer has _never_ tested his code for leaks, and I discovered that the applications could leak many MBs with only a minute of use. User's were reporting huge slowdowns, and his take was, "it's nothing to do with me - if they quit and restart, it's all good again." I've given him tools to detect and trace the leaks, and sat down with him for many hours to demonstrate how the tools are used, where the problems occur, and what to do to fix them. We're 6 months down the track, and I assigned him to write a new module. I reviewed it before it was integrated into our larger code base, and was dismayed to discover the same bad coding as before. The part that I find incomprehensible is that some of the coding is worse than amateurish. For example, he wanted a class (Foo) that could populate an object of another class (Bar). He decided that Foo would hold a reference to Bar, e.g.:               class Foo {     public:         Foo(Bar& bar) : m_bar(bar) {}     private:         Bar& m_bar;     };      But (for other reasons) he also needed a default constructor for Foo and, rather than question his initial design, he wrote this gem:               Foo::Foo() : m_bar(*(new Bar)) {}      So every time the default constructor is called, a Bar is leaked. To make matters worse, Foo allocates memory from the heap for 2 other objects, but he didn't write a destructor or copy constructor. So every allocation of Foo actually leaks 3 different objects, and you can imagine what happened when a Foo was copied. And - it only gets better - he repeated the same pattern on three other classes, so it isn't a one-off slip. The whole concept is wrong on so many levels. I would feel more understanding if this came from a total novice. But this guy has been doing this for many years and has had very focussed training and advice over the past few months. I realise he has been working without mentoring or peer reviews most of that time, but I'm beginning to feel he can't change. So my question is, would you persist with someone who is writing such obviously bad code?