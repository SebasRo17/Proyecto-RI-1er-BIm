I just read one of Joel's articles in which he says: > In general, I have to admit that **I’m a little bit scared of language > features that hide things**. When you see the code >   >   >     i = j * 5; >   > > … in C you know, at least, that j is being multiplied by five and the > results stored in i. > > But if you see that same snippet of code in C++, you don’t know anything. > Nothing. **The only way to know what’s really happening in C++ is to find > out what types i and j are, something which might be declared somewhere > altogether else. That’s because j might be of a type that has`operator*` > overloaded and it does something terribly witty when you try to multiply > it.** (Emphasis mine.) Scared of language features that hide things? How can you be scared of that? Isn't hiding things (also known as **abstraction** ) one of the key ideas of object-oriented programming? Everytime you call a method `a.foo(b)`, you don't have any idea what that might do. You have to find out what types `a` and `b` are, something which might be declared somewhere altogether else. So should we do away with object-oriented programming, because it hides too much things from the programmer? And how is `j * 5` any different from `j.multiply(5)`, which you might have to write in a language that does not support operator overloading? Again, you would have to find out the type of `j` and peek inside the `multiply` method, because lo and behold, `j` might be of a type that has a `multiply` method that does something terribly witty. "Muahaha, I'm an evil programmer that names a method `multiply`, but what it actually does is totally obscure and non-intuitive and has absolutely nothing to do whatsoever with multiplying things." Is that a scenario we must take into consideration when designing a programming language? Then we have to abandon identifiers from programming languages on the grounds that they might be misleading! If you want to know what a method does, you can either glance at the documentation or peek inside the implementation. Operator overloading is just syntactic sugar, and I don't see how it changes the game at all. Please enlighten me.