In my Domain I have an entity `Activity` which has a list of `ITask`s. Each implementation of this task has it's own properties beside the implementation of `ITask` itself. Now each operation of the `Activity` entity (e.g. `Execute()`) only needs to loop over this list and call an ITask method (e.g. `ExecuteTask()`). Where I'm having trouble is when a specific tasks' properties needs to be updated, as in configuring the task (not as part of the execute method). How do I get an instance of that task? The options I see are:   * Get the Activity by Id and cast the task I need. This'll either sprinkle my code with:      * `Tasks.OfType<SpecificTask>().Single(t => t.Id == taskId)`     * or `Tasks.Single(t => t.Id == taskId) as SpecificTask`   * Make each task unique in the whole system (make each task an entity), and create a new repository for each ITask implementation I don't like either option, the first because I don't like casting: I'm using NHibernate and I'm sure this'll come back and bite me when I start using Lazy Loading (NHibernate currently uses proxies to implement this). I don't like the second option because there are/will be dozens of different kind of tasks. Which would mean I'd have to create as many repositories. Am I missing a third option here? Or are any of my objections to the two options not justified? How have you solved this problem in the past?