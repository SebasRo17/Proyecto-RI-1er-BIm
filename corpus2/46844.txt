I'd quite like to be able to automatically generate C++ versions of certain mathematical expressions that I've manipulated in Mathematica. The resultant C++ code fragment is then going to be used independently of Mathematica. Mathematica provides a `CForm` function, which almost seems like what I want, but I can't get it to do basic conversions nor tell it how to convert Mathematica symbols into my C++ identifiers. **For example, I would like the output from`CForm[x[0]^2]` or `ToString[x[0]^2, CForm]` to be `"std::pow(obj.x_[0], 2)"`.** This can be a string; it doesn't need to be usable in Mathematica any more. Of course, my actual expressions of interest are a lot more complicated than this. But:   * I don't have a way of telling Mathematica that symbol `x` is to be renamed to `obj.x_` (not a valid symbol name in Mathematica so can't use it directly). String manipulation after conversion is too unreliable for this so a more direct method is preferred.   * I can't tell Mathematica that `x` is an array, not a function, so it gives me `x(0)` instead of `obj.x_[0]`.   * Mathematica thinks I want to use its own `Power` function, but I'd really like to use `std::pow`. Perhaps `CForm` isn't suited to this task, but I would still appreciate a solution using any other available method if possible. I really think that Mathematica should be able to help me here, because it knows where I need brackets and so on. I've tried:               Format[x[a_], CForm] :=         "obj.x_[" <> ToString[a, CForm] <> "]"          Format[Power[a_, b_], CForm] :=          "std::pow(" <> ToString[a, CForm] <> ", " <> ToString[b, CForm] <> ")"          ToString[x[0]^2, CForm]      but of course `Power` is protected so the second `SetDelayed` gives me an error, and my `ToString[x[0]^2, CForm]` output is really weird (`Power("obj.x_[0]",2)`) because I've tried to use strings in the `Format`.