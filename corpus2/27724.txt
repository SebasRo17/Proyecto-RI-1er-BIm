I have a simple SDE with white noise:               mysde[q_, I_, n0_, sd_] :=        ItoProcess[         \[DifferentialD]n[t] ==            ( I - q n[t]) \[DifferentialD]t + sd \[DifferentialD]w[t], n[t],          {n, n0}, t, w \[Distributed] WienerProcess[]]      I want to impose a condition that n[t] cannot fall below zero. At below zero, or an arbitrarily low value of n[t], it is considered zero. I am not sure how to implement this in the ItoProcess function and/or in the numerical solution:               sol[q_, I_, n0_, sd_] := RandomFunction[mysde[q, I, n0, sd], {0, 100, 0.1}, 1]      The variable drops below zero many times, which is not a desired behaviour:               With[{q = 2, I = 0.1, n0 = 1, sd = 0.1},        Show[ListLinePlot[sol[q, I, n0, sd]], ImageSize -> 400]]      What are some ways to implement such a condition? I have tried various functions on `n[t]` within the `ItoProcess[]`, to attempt to re-set negative values of `n[t]` to zero, like `If[]`, `Max[]`, `Clip[]`, and `Piecewise[]` to no avail. Any reasons why these functions do not dynamically work within the solver? Also is there a way to extract the values of the noise, `w[t]`, in a particular simulated path of the temporal data timeseries object? One potential solution, which is not confirmed to be correct, is to write the equation for the log of my variable, `ln[t]` and to use the Geometric Brownian motion random process formulation, obtaining:               logsde[q_, I_, ln0_, sd_] :=        ItoProcess[         \[DifferentialD]ln[t] ==            ( I - q ln[t] - sd^2/2) \[DifferentialD]t + sd \[DifferentialD]w[t], ln[t],         {ln, ln0}, t, w \[Distributed] GeometricBrownianMotionProcess[I - q ln[t], sd, n0]]          logsol[q_, I_, ln0_, sd_] := RandomFunction[logsde[q, I, ln0, sd], {0, 100, 0.1}, 1]      Then I extract the simulated values, and exponentiate them to obtain the time series or path in the original scale:               td = With[{q = 0.1, I1 = 0.1, ln0 = 1, sd = .1},        logsol[q, I1, ln0, sd]];     ListLinePlot[Exp[td["States"]]]      However I have lost the stochastic signal in this model; the simulation smooths out and looks continuous with no noise, except at the beginning of the simulation. This is obviously an incorrect formulation. What did I do here? How might I formulate this properly? Are there other approaches? So overall I have three questions:   1. How to implement a boundary condition in `ItoProcess[]` for one of the state variables?   2. How to recover the simulated values of the random variable? <\- self-answered below   3. How to properly specify a log-transformed version of the `ItoProcess[]`?