I am currently working on a numerical processing system that will be deployed in a performance-critical environment. It takes inputs in the form of numerical arrays (these use the `eigen` library, but for the purpose of this question that's perhaps immaterial), and performs some range of numerical computations (matrix products, concatenations, etc.) to produce outputs. All arrays are allocated statically and their sizes are known at compile time. However, some of the inputs _may_ be invalid. In these _exceptional_ cases, we still want the code to be computed and we still want outputs not "polluted" by invalid values to be used. To give an example, let's take the following trivial example (this is pseudo- code):               Matrix a = {1, 2, NAN, 4}; // this is the "input" matrix     Scalar b = 2;     Matrix output = b * a; // this results in {2, 4, NAN, 8}      The idea here is that 2, 4 and 8 are usable values, but the NAN should signal to the recipient of the data that that entry was involved in an operation that involved an invalid value, and should be discarded (this will be detected via a `std::isfinite(value)` check before the value is used). Is this a sound way of communicating and propagating unusable values, given that performance is critical and heap allocation is not an option (and neither are other resource-consuming constructs such as `boost::optional` or pointers)? Are there better ways of doing this? At this point I'm quite happy with the current setup but I was hoping to get some fresh ideas or productive criticism of the current implementation.