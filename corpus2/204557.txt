A common operation in JavaScript is to replace an object method with a new one while still calling the original method. This is often done like this:               var originalMethod = obj.method;     obj.method = function(arg) {         // call original method         originalMethod.call(this, arg);         // do my stuff new stuff     }      I'd like to create a utility function for a specific object method that handles the chaining part so that the user doesn't need to be concerned about it. One option is to use the above design, in which each added function is wrapped in a new function that calls the previous one. Another option is to create an array of functions and make the object method just iterate over the array, calling each function in turn.               function addXyzMethod1(fn) {         if (obj.method) {             var previousMethod = obj.method;             obj.method = function(value) {                 value = previousMethod.call(this, value);                 return fn.call(this, value);             };         } else {             obj.method = fn;         }     }          function addXyzMethod2(fn) {         if (obj._methodList) {             obj._methodList.push(fn);         } else if (obj.method) {             obj._methodList = [obj.method, fn];             obj.method = function(value) {                 for (var i = 0, n = obj._methodList.length; i < n; i++) {                     value = obj._methodList[i].call(this, value);                 }                 return value;             };         } else {             obj.method = fn;         }     }      At this point, I can't decide which method to use since I feel the trade-offs of each are about even. So my question here is: Which of these method is better (more natural, or accepted, or quicker) or is there another method that improves on both of these?