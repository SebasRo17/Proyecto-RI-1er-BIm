I'm working on an implementation of a multivariate FFT, which is (or at least should be) highly parallelizable due to the row-column-algorithm. However, i can't figure out how to implement that. The serialized idea looks like the following               MFFTs[dims_,data_] := Block[{e,f,locdat=data},       If[Dimensions[dims] == {1}, Return[Fourier[locdat]];       , (*else: row column*)         Do[locdat[[e,All]] = Fourier[locdat[[e,All]]], {e,1,dims[[1]]}];         Do[locdat[[All,f]] = Fourier[locdat[[All,f]]];,{f,1,dims[[2]]}];         Return[locdat];       ]     ];      which would take on a sample of e.g. $2^{14}$ data points on a grid of $4\times2^{12}$ samples (quite anisotrope) about `0.089` seconds. Note that the operations in the first loop work on complete distinct sets of data. After that the second `Do`-Loop does also never write on an array entry twice. So that should be parallelizable quite far. However even for that short set of data the code               MFFTp[dims_, data_] := Block[{e, f, locdat = data},       If[Dimensions[dims] == {1},Return[Fourier[locdat]];       ,       locdat = ParallelTable[Fourier[a],{a,locdat}];       Do[locdat[[All, f]] = Fourier[locdat[[All, f]]];, {f, 1, dims[[2]]}];       Return[locdat];      ]     ];      would need about `0.0549` seconds (running on 4 subkernels). Do you know a way to do something similar with the second one (or in more dimensions that would be encapsulated `Do`s) ? Any Usage of `ParallelDo` would require to `SetSharedVariable` the `locdat`, which kills any timing due to synchronization (about `4` seconds in this example using 4 subkernels). Due to the distinct write access it would be nice to be able to write in parallel onto an array in the Master kernel or something like that. ### Edit: Update One little improvement - at least limited to the 2D-FFT is using twice the command `locdat = Transpose[ParallelTable[Fourier[a],{a,locdat}]];` to perform the FFT on each row and column. That won't work for a 3DFFT though. And it doesn't improve the timing that much. As @Ajasja pointed out the bottleneck is the collection of the results, so some kind of `Parallelwrite` would be really great.