On the surface, `Check` looks like a good method to use when you need to abort the evaluation of an expression whenever a `Message` is emitted. Unfortunately, as the following code demonstrates, the evaluation of the expression is completed after a `Message` has occurred.               (* the test message *)     Test::wrpt = "Negative point at `1`";          dat = RandomReal[1, 500];          (* without Check *)     woCheck = MapIndexed[        If[# < 0,           Message[Test::wrpt, #2[[1]]]; Unevaluated[Sequence[]],           #] &,        {-1}~Join~dat];          (* with Check *)     res = {};     Check[      MapIndexed[       If[# < 0,          Message[Test::wrpt, #2[[1]]]; Unevaluated[Sequence[]],          res = {res, #}; #] &,       {-1}~Join~dat],      $Failed      ]      (* Test::wrpt: Negative point at 1       $Failed      *)      But, when comparing the two               woCheck == Flatten@res     (* True *)      This implies, that for long running computations `Check` is not a good solution to abort a computation if an error `Message` is emitted. Can this be fixed?