In Java, C# and many other strongly-typed, statically checked languages, we are used to write code like this:               public void m1() { ... }     protected void m2() { ... }     private void m2() { ... }     void m2() { ... }      Some dynamically checked languages don't provide keywords to express the level of "privateness" of a given class member and rely on coding conventions instead. Python for example prefixes private members with an underscore:               _m(self): pass      It can be argued that providing such keywords in dynamically checked languages would add little use since it is only checked at runtime. However, I can't find a good reason to provide these keywords in statically checked languages, either. I find the requirement to fill my code with rather verbose keywords like `protected` both annoying and distracting. So far, I have not been in a situation where a compiler error caused by these keywords would have saved me from a bug. Quite in contrary, I have been in situations where a mistakenly placed `protected` prevented me from using a library. With this in mind, my question is: **Is information hiding more than a convention between programmers used to define what is part of the official interface of a class?** Can it be used to secure a class' secret state from being attacked? Can reflection override this mechanism? What would make it worthwhile for the compiler to **enforce** information hiding?