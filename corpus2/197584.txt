I'm trying to make a case for not putting the structure in the parent BaseModule class I've shown below. I'm more for a Strategy Pattern, and minimizing inheritance in favor of has-a relationships, but I am not really sure of what principle of OOAD this pattern is breaking. What principle of OOAD is this pattern breaking? Potential Pattern:               public interface IStringRenderer     {         string Render();     }          public class BaseModel : IRequestor     {         public abstract void  Init();         public abstract void Load();     }          public class BaseModule<TModel> : IStringRenderer where TModel : BaseModel     {         public TModel Model { get; set; }              public override string Render()         {             return             string.Join(                 "",                 new string[]                 {                     "<header/>",                     "<main-container>",                         "<side-nav>",                             "<side-navigation/>",                         "</side-nav>",                         "<main-content>",                             RenderMainContent(),                         "</main-content>"                 });         }              public abstract string RenderMainContent();     }          public class MyModuleModel : BaseModel     {         public List<int> Ints { get; set; }                      ...     }          public class MyModule : BaseModule<MyModuleModel>     {         public override string RenderMainContent()         {             return             string.Join(",", Model.Ints.Select(s => s.ToString()).ToArray());         }     }      Preferred Pattern (duplicated some code to be clear):               public interface IStringRenderer     {         string Render();     }          public class BaseModel : IRequestor     {         public abstract void Init();         public abstract void Load();     }          public class MyModuleModel : BaseModel     {         public List<int> Ints { get; set; }              ...     }          public class MyModule : IStringRenderer     {         public MyModuleModel Model { get; set; }              public MyModule(MyModuleModel model)         {             this.Model = model;         }              public override string Render()         {             return             string.Join(                 "",                 new string[]                 {                     "<header/>",                     "<main-container>",                         "<side-nav>",                             "<side-navigation/>",                         "</side-nav>",                         "<main-content>",                             RenderMainContent(),                         "</main-content>"                 });         }              public string RenderMainContent()         {             return             string.Join(",", Model.Ints.Select(s => s.ToString()).ToArray());         }     }      There are parts of this pattern that I'm not trying to focus on, but instead I am thinking about where the 'structure', or the 'tags' are living. In the first example they live in the parent, but in the second example they have been pushed into the derived class. Right now, the examples are pretty simple, but something like 'side-nav' could potentially get complicated, and may need to be controlled by the child anyway. I feel the principle here is that I don't feel like the 'tag' structure shouldn't be in the parent class as in the first example. There are other things I've removed in my 'preferred version' -- namely the generics. (Any suggested reading on good/bad for that choice is welcome). Proponents of the first example's embedded structure like the fact that they can wield changes to large amounts of child classes. I feel offering the flexibility to derived classes is the way to go, and if there needs to be a parent that parent only offers functionality and cross-cutting features, but does not bottle up canned structure.