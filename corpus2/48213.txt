Potential duplicate, but doesn't seem to solve my problem: Using patterns in pure functions I have a function that returns an `InterpolatingFunction`, and it works exactly the way I needed for passing to `NIntegrate` etc.: if I pass on a symbolic argument, the function returns itself; if the argument is numeric, it evaluates and gives a number.               func := Module[{...}, ... (y /. First@NDSolve[{y[1] == 1, y'[x] == x}, y, {x, -1, 1}])]     func[x] (* gives InterpolatingFunction[(-1. 1.),<>](x) *)     func[0.5] (* gives 0.625 *)       I need a slightly modified behavior: the returned function should return 0 if outside the range instead of attempting to interpolate. Seems easy enough:               func := Module[{interpolation,...}, ...             interpolation = (y /. First@NDSolve[{y[1] == 1, y'[x] == x}, y, {x, -1, 1}]);             Function[x,If[Not@IntervalMemberQ[Interval[interpolation[[1, 1]]], x], 0,                      interpolation[x]]]]     func[0.5] (* gives 0.625 *)      func[2] (* gives 0 since it's outside the interpolation interval *)     func[x] (* gives 0!! *)      How can one mimic the behavior of `InterpolatingFunction` such that `func[x]` for non-numeric `x` gives something like `Function[<>](x)` instead?