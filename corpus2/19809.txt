This question is related to Evaluation order of Button[]'s action Concusion was, `Button[]'s` actions are evaluated in preemptive link so "the code that needs to be run for the new cells to be created and formatted needs to wait until the preemptive evaluation has finished". To deal with it we only have to add `Method -> "Queued"` for `Button`. I've thougth that in case:               Button[ "X", x = 3; Pause @ 1; y = 4]     Dynamic @ x     Dynamic @ y      where cells for `x` and `y` are created before pushing `Button` I don't have to use `Method -> "Queued"`. However it seems I have to because `Pause` is again evaluated at the first place. This is not a big problem since I know how to deal with it but I like to know why something works not the way I thought it would. There is something more: What if I'm working with customized `button` based on `EventHandler`, let's take basic case:               SetAttributes[ GButton, HoldRest]     GButton[ob_, proc_] := DynamicModule[{},       EventHandler[        Framed[ob, Alignment -> Center],            {"MouseDown" :> (proc)}, PassEventsUp -> False,        PassEventsDown -> False]];      This kind of `button` works as a standard `Button` but how can I add anything that works as `Method -> "Queued"` in `Button`? I need something opposite to `PreemptProtect` function.