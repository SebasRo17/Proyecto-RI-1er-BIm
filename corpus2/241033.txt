I am implementing a binary search tree in java. Inside the BST class I have a protected class Node (in case I want to extend to an AVL tree). The code is below. I had a problem, both conceptually and aesthetically, implementing empty nodes as null pointers. So instead I opted for the null object pattern and created an EmptyNode object, the code for which is also below. However, even though this gives me prettier code and something more conceptually pleasing (to me), I now have the problem that when I'm working with a tree of height n, I can have as many as 2^{n+1} - 2^{n} instances of this EmptyNode class floating around, which takes up space for no good reason. How should I fix this code to avoid this overhead while still implementing the null object pattern? I feel like the EmptyNode should be something conceptually similar to a constant field of Node, but I can't implement that. I also feel like there should be only one copy of EmptyNode being referenced anywhere, but I can't figure out how to implement that either. Any help or recommendations are appreciated.               protected class Node<Key,E>{         protected Key key;         protected E value;         protected Node<Key,E> left;         protected Node<Key,E> right;         protected int height;         protected int balanceFactor;         public Node(){}         public Node(Key k, E v){             key = k;             value = v;             left = new EmptyNode<Key,E>();             right = new EmptyNode<Key,E>();             height = 0;             balanceFactor = 0;         }         public Node(Key k, E v, Node<Key,E> l, Node<Key,E> r){             key = k;             value = v;             left = l;             right = r;             height = Math.max(l.height(), r.height())+1;             balanceFactor = l.height() - r.height();         }         public Key getKey(){return key;}         public E getValue(){return value;}         public Node<Key,E> getLeft(){return left;}         public Node<Key,E> getRight(){return right;}         public int height(){return height;}         public int balanceFactor(){return balanceFactor;}         public void setKey(Key k){key = k;}         public void setValue(E v){value = v;}         public void setLeft(Node<Key,E> l){             left = l;             height = Math.max(l.height(), this.right.height())+1;             balanceFactor = left.height() - this.right.height();         }         public void setRight(Node<Key,E> r){             right = r;             height = Math.max(this.left.height(), r.height())+1;             balanceFactor = this.left.height() - right.height();         }         public boolean isEmpty(){return false;}         public boolean isLeaf(){             return (left.isEmpty()) && (right.isEmpty());         }         public boolean hasLeft(){             return !left.isEmpty();         }         public boolean hasRight(){             return !right.isEmpty();         }     }     protected final class EmptyNode<Key,E> extends Node<Key,E>{         public EmptyNode(){             key = null;             value = null;             left = right = null;             height = -1;             balanceFactor = 0;         }         @Override         public void setKey(Key k){}         @Override         public void setValue(E v){}         @Override         public void setLeft(Node<Key,E> l){}         @Override         public void setRight(Node<Key,E> r){}         @Override         public boolean isEmpty(){return true;}         @Override         public boolean isLeaf(){return false;}         @Override         public boolean hasLeft(){return false;}         @Override         public boolean hasRight(){return false;}     }