"The Interface-Segregation Principle (ISP) states that no client should be forced to depend on methods it does not use." The decorator pattern is a design pattern to decorate a method of a class. For this, the decorator implements the same interface as the decorated object, so it can take its place. But doesn't this mean that it has to implement all of the methods in the interface, when it uses only one of them, the one it decorates? So I guess it violates the ISP. The only case it doesn't it is when the decorated interface only contains the method that needs to be decorated, but I see it as a rather rare case. An example would be that there are pages in a book. Some pages have footnotes, other pages have titles at the top. So we implement these extras as decorators of a method, let's say draw(). But a page has other methods as well, let's say: fold() and tear() and other methods can come in later. But if we want to use decorated versions of pages inserted in a book, and working the same way, we end up implementing in every decorator every method of a page, where the only thing happening is that the decorator passes the call to the page it's containing.               interface IPage {         public ITearResult tear();         public void draw();     }          class FooterDecorator implements IPage {         private IPage page;              public FooterDecorator(IPage page) {             this.page = page; //the object it decorates         }              //violates the ISP, because it has to implement it, but it's not using it,         //just passes the operation         public ITearResult tear() {             return page.tear();         }              //decorated method         public void draw() {             page.draw();             ... draw footer - the decoration         }     }      Am I not understanding the decorator pattern or the ISP correctly? Is it an acceptable violation or do these two really contradict each other?