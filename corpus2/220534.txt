I recently came across an internal project where they were using DTOs throughout the solution, and when I sat down to implement a new MVC controller with a JSON REST endpoint I decided to use an anonymous object convention instead of declaring a discrete DTO class solely for the purpose of this API endpoint.               public JsonResult GetSomeSuch()     {         // .. do work              return Json(new {             PropA = domainObj1.PropA,             PropB = domainObj2.PropB         });     }      .. as opposed to the team convention, ..               public JsonResult GetSomeSuch()     {         // do work ..              return Json(new SomeSuchDTO2 {             PropA = domainObj1.PropA,             PropB = domainObj2.PropB         }     }          // in some other file off in some other project and folder     public class SomeSuchDTO2 {         public int PropA { get; set; }         public string PropB { get; set; }     }      Setting aside that I should have used a DTO here purely because it was already a team convention, team conventions trump best practices until team conventions change by team leadership, of which I was not yet a part. I'm not concerned about the social / team dynamic and consistency aspects so much as the technical value of details in specifically that point at which an action in C# becomes serialized to Javascript, as I have since moved on from that company. The team convention was to return only DTOs and the DTOs were managed in a completely different project (among about 50 projects in the solution), I felt that in this case perpetuating that pattern was excessive and difficult to maintain. Further, my belief is that DRY must correlate with YAGNI; only refactor when you're repeating the same thing twice, as such you would only refactor to use a DTO if that same return object structure reflecting the same context is in fact needed elsewhere, not just possibly but actually, but since this is being serialized to Javascript where it will be consumed anyway there is really no point anyway. I suppose a case can be made for DTOs as specification documentation, but when it becomes more of a maintenance chore to declare them and to look them up in their special folder in a project I would argue that there are more appropriate places and means to document the interface; indeed the anonymous object declaration seems to be documentation enough. I should also add that in our case everything was internal, this was a standalone project, so it's not like this was an externally exposed API. I was wondering if there are other angles to this that I didn't consider as to why I should use DTOs, something reasonably convincing?