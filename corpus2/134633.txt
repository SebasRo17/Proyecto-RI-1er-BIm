As I understand, top-down design is by refining the abstract high level concept into smaller concrete and comprehensible parts, until the smallest building block is defined. On the other hand, bottom up defines low level parts, then gradually build up higher level blocks until the whole system is formed. In practice, it is said best to combine the two methods: starts with high level specification to fully specify the domain knowledge, its relationship and constraints. Once the problem is well understood, smallest building blocks are created to build up the system. The process of:   * Creating requirement spec   * Create a design spec (with diagrams)   * Implement   * Deliver   * Repeat (in iterative development, rather than doing a whole chunk in each phase, we do a little bit each repeatedly, and got daily meeting to adapt to customer's dynamic requirement) looks perfectly normal to me (with specs as plans). It has its flaws but that's why we got iterative development: instead of spending time on one phase, says, requirement analysis to study every possible thing in domain knowledge which is subjected to changes (possibly daily), we do a little bit of analysis, a little bit of design and then implement it. Another way is that each iteration is a mini-waterfall fashion, where analysis is done in a few days (or a week). The same applies for design. The rest of time is spent for implementation. Is there something inherently wrong with top-down approach in combination with iterative development? In his essay Programming Bottom Up, Paul Graham seems to encourage build from bottom up completely, or program it from bottom up, but not the requirement analysis/design phase: > Experienced Lisp programmers divide up their programs differently. As well > as top-down design, they follow a principle which could be called bottom-up > design-- changing the language to suit the problem. As far as I get, what he meant is that Lisper still performs top-down design, but program bottom up, is that true? Another point he wrote: > It's worth emphasizing that bottom-up design doesn't mean just writing the > same program in a different order. When you work bottom-up, you usually end > up with a different program. Instead of a single, monolithic program, you > will get a larger language with more abstract operators, and a smaller > program written in it. Instead of a lintel, you'll get an arch. Does this means that during the period of writing a program in Lisp, you end up with a generic tool?