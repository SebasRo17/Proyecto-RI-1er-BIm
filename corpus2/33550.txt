I'm interested in transforming a piecewise defined function into a sum of indicator functions, ultimately with the aim to be better able to integrate them. As an example I would like to transform the function               f = Piecewise[{{x, 3*x > y && x < 2*y}, {y, 2*x > y && x < 3*y}}, 0]      into               x Boole[3 x > y && x < 2 y] + y Boole[x >= 2 y && x < 3 y].      For this specific example, this could be achieved by               f[[1,1,1]]Boole[f[[1,1,2]]] + f[[1,2,1]]Boole[f[[1,2,2]] && !f[[1,1,2]]]      but I don't know how to efficiently generalize this to functions with more than two cases, in particular how to ensure that the term corresponding to the $n$th case contains the negated conditions of the first $n-1$ cases. In a second step, assuming that the conditions of the piecewise function are linear inequalities, I would like to decompose each Boole[] into a sum of Boole[]'s of disjoint intervals for, say, the variable $x$. In my example above this would mean               Boole[3 x > y && x < 2 y] == Boole[y/3 < x < y/2]     Boole[x >= 2 y && x < 3 y] == Boole[2y < x < 3y]      This is maybe a trivial example, but in more complex situations one will have to deal with more than one disjoint interval. In non-Mathematica notation I'd like a decomposition of the form $$ f(x) = \sum_i f_i(x) \sum_j\mathbf{1}_{\left\\{x_{i,j}^{\min}<x<x_{i,j}^\max\right\\}}(x). $$ where the $f_i$ are given by `f[[1,All,1]]`.