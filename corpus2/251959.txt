Once you create separate components that need to communicate with each other you enter the realm of systems programming where you have to assume that errors could originate at any step in the process. You throw `try-catch` blocks out the window and have to develop robust alternatives for error handling yourself. We have two systems both with REST apis. Both systems have GUIs that users can use to add/update information. When information is added to one system it must be propagated to the other. We have integration software (the middleman) that polls on a minute-by-minute basis, picks up adds/edits and translates them from one system to the other. Each invokation keeps track of the timestamp of the last successful run--we have one timestamp for communication in either direction. In this way, if any part of the system fails, we can resume right where we left off when the issues are corrected. I have heard bad things about poll-based approaches: namely the fact that it runs without regard to whether there is actually work. I have heard that push- based approaches are more efficient because they are triggered on demand. I am trying to understand how a push-based approach might have worked. If either system attempts to push an add/edit, we have to assume that it could fail because the other system is down. It would seem to me that either system would need to maintain its own outgoing queue in order to resume once the issue with the other system is corrected. It seems to me that using a push approach eliminates the middleman, but heaps more responsibility on each system to manage its messages to the other system. This seems to not be a clean way of separating concerns. Now both systems have to take on middleman responsibilities. I don't see how you would redesign the middleman for a push-based architecture. You run the risk that messages are lost if the middleman himself fails. Is there a fault-tolerant architecture that could be used to manage system interactions without the polling? I'm trying to understand if we missed a better alternative when we devised/implemented our poll-based middleman. The software does the job, but there's some latency.