I have an interface method that states in documentation it will throw a specific type of exception. An implementation of that method uses something that throws an exception. The internal exception is caught and the exception declared by the interface contract is thrown. Here's a little code example to better explain. It is written in PHP but is pretty simple to follow.               // in the interface          /**      * @return This method returns a doohickey to use when you need to foo      * @throws DoohickeyDisasterException      */     public function getThatDoohickey();          // in the implementation          public function getThatDoohickey() {              try {             $SomethingInTheClass->doSomethingThatThrowsAnException();         } catch (Exception $Exc) {             throw new DoohickeyDisasterException('Message about doohickey failure');         }              // other code may return the doohickey          }      I'm using this method in an attempt to prevent the abstraction from leaking. My questions are: Would passing the thrown internal exception as the previous exception be leaking the abstraction? If not, would it be suitable to simply reuse the previous exception's message? If it would be leaking the abstraction could you provide some guidance on why you think it does? Just to clarify, my question would involve changing to the following line of code               throw new DoohickeyDisasterException($Exc->getMessage(), null, $Exc);