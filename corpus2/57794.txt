With Mathematica 10, I wanted to overload `Lookup` using `TagSetDelayed`, but it doesn't work. For instance, if I define two objects with head `TempHead`               t1 = TempHead[a -> 1, b -> 2, c -> 3];     t2 = TempHead[c -> 3, d -> 4, e -> 5];      I can overload `Plus` as usual:               TempHead /: Plus[t1_TempHead, t2_TempHead] := TempHead @@ Join[List @@ t1, List @@ t2]      So:               t1 + t2     (* TempHead[a -> 1, b -> 2, c -> 3, c -> 3, d -> 4, e -> 5] *)      But, if I do the same thing with Lookup, it doesn't work:               TempHead /: Lookup[t1_TempHead, t2_TempHead] := TempHead @@ Join[List @@ t1, List @@ t2]     Lookup[t1,t2]     (* Lookup::invrp: The argument TempHead[a->1,b->2,c->3] is not a valid Association or a list. >> *)      Further, you cannot even use `Unprotect` to overload `Lookup`. I thought this was a bug, but when I reported it to Wolfram, they said `Lookup` was designed to give an error on all objects that aren't `Associations`. Certainly there are Mathematica functions that give errors (e.g. `Part`, when you try to access outside the length of a `List`), but you can usually still overload them. Does anyone know if there is a good reason for implementing `Lookup` this way? It seems to break with the "Everything is an expression" principle that Wolfram is always touting. Are there other symbols that act like `Lookup`?