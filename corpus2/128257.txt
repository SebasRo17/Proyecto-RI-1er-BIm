Currently, I'm following a course on embedded software development. The lecturer has chosen J as an architecture language for model-driven software development. J itself is a very terse programming language and one of his main arguments for this language is its terseness. For instance, this is a Quicksoft implementation in J:               quicksort=: (($:@(<#[) , (=#[) , $:@(>#[)) ({~ ?@#)) ^: (1<#)      Another argument is that through such a language and the reduced number of characters, you introduce less bugs and the time to fix bugs is reduced. Since I have a strong software engineering background and through various books like Clean Code, Pragmatic Programmer and others, I feel that these arguments aren't valid. I find that there is a strong movement towards descriptive names and code that reads like natural language (alright, this might only be related to applications with lots of business logic and less math). The question therefore is, can you really argue that usage of a terse programming language will result in less errors and that time to fix a bug is reduced? Also, since the language is terse, the number of lines of code is reduced and you would get a better COCOMO rating. But can this be applied in the first place or does the COCOMO model use the number of lines of code as a way to estimate a project's overall size (project size should be the same whether you implement it in a terse language or in an imperative one, but again, maybe I didn't understand the COCOMO model correctly)? **Update** Thank you all for your answers. Admittedly, I should have stated more clearly that my intention was to get more information on the COCOMO model (again, sorry S.Lott). As such, I feel that Thomas Owens's extensive answer and comments are the best fit for this question. Thanks again! :-)