I am currently experiencing a problem when I try to use `FindRoot` with an interpolating function that outputs a vector. I have constructed a minimal example that illustrates the problem. Consider the following function, that parametrizes a circle in the plane.               circle[t_] := {Cos[t], Sin[t]};      Suppose you want to find the point at which the x coordinate of the circle equals one half.               FindRoot[ circle[t][[1]] - 0.5, {t, 0.1, 0, Pi/2}]      Of course, `FindRoot` finds the root: > >     {t -> 1.0472} >   However, sometimes you do not have an exact function, and you need to use an `InterpolatingFunction` instead. The function `circleInterpol` is an interpolation of $100$ points sampled from the circle. Although the interpolation of lists of the type `{ t, {x,y}}` is not considered in the reference, _Mathematica_ does not issue any warnings and plotting using `ParametricPlot` works fine.               circleInterpol = Interpolation[ Table[{t, circle[t]}, {t, 0, Pi/2, Pi/200}]]     ParametricPlot[{circle[t], circleInterpol[t]}, {t, 0, Pi/2}]      However, when I try to use `FindRoot` in the same way as before:               FindRoot[circleInterpol[t][[1]] - 0.5, {t, 0.1, 0, Pi/2}]      but with circle replaced by `circleInterpol`, I get a completely different (and obviously wrong) result: > >     {t -> 0.5} >   `FindRoot` does not issue any warnings at this point. Changing the syntax to (I realize that `{0.5, 0.1}` is not a point on the circle, but since you take the first part anyway, this should not matter.)               FindRoot[(circleInterpol[t] - {0.5, 0.1})[[1]], {t, 0.1, 0, Pi/2}]      issues the warning: > >     FindRoot::nveq: The number of equations does not match the number of > variables in >     FindRoot[(circleInterpol[t] - {0.5, 0.1})[[1]], { t, 0.1, 0, Pi/2}]. >> >   Replacing the interpolating function by the exact function still gives the correct result. So it seems to me that something is going wrong with the combination of `FindRoot` and `InterpolatingFunction`. An obvious solution to the problem is to construct two interpolating functions; one for each coordinate (`x` and `y`). Although this would solve the problem, I do not understand why this extra step is necessary. Could someone help me to understand what is going wrong here?