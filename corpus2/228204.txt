I currently have a class `Foo`, i've decided I need a second type of `Foo` where I want to test out a significantly different implementation. It will no doubt share some functionality with `Foo` so I'll need to create a Abstract Class parent for both of them. At the end of the process I want to have:   * `AbstractFoo`: an abstract class   * `FooBoo`: functionaly identical to the original `Foo`   * `FooBar`: the new subclass of AbstractFoo I've created. There are two ways I could go about this: **Copy Paste, then Refactor**   1. Create a copy of `Foo`, and name it `FooBar` and rename `Foo` to `FooBoo`   2. Edit `FooBar` with the new implementation   3. Inspect, `FooBar` and `FooBoo`, move methods that are the same between them into a abstract class `AbstractFoo`, which both inherit from **Refactor, then Implement**   1. Rename `Foo`, `FooBoo`   2. Consider what methods are not related to the part of the implementation that `FooBoo` and `FooBaz` are going to be different in. Move these to `AbstractFoo`   3. Create `FooBaz` and reimplement all the methods that remain within `FooBoo` **Which is to be preferred?** * _Is there another method?_ * Last time I had to do this, it was because the I decided that `Foo` had 2 different modes, that was determined by a boolean passed into the constructor. This time (on a different class), it is because I want to try out using a different engine underneath that might be faster. I want to keep `FooBoo` around because it has a subclass that I think will be much harder to implement for `FooBaz`, and I also want to be able to check that in the end they behave the same.