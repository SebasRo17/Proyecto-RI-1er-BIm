What are the potential pitfalls of combining related class like objects (interfaces, traits, custom exceptions) in the same source file? For code reuse and only loading what I need I always separate out full class's into separate files. But interfaces, traits, and extended exceptions don't seem to need that same level of granularity. I have been trained that all classes and class like objects (interfaces, extended exceptions, etc.) should be given their own source files. But now I am starting to work with traits and after getting advice about combining traits and interfaces, to have the ability to have something along the lines of multiple inheritance, I am combining the interface and the trait in the same source file. That way the only way to access traits is to implement the corresponding interface. Once the class calls the autoloader to get the source for the interface it also loads the trait. Not all classes that implement the interface will use the trait for functionality, but most will, and those that don't will just not _use_ the trait. I also will use extended Exceptions for an interface along the lines of PDOException. These are exceptions only thrown by classes that extend or implement a class. So now my **Stackable.php** interface file looks like:               interface Stackable{       public function add($content);       public function _registerParent($parent);       public function _checkLoop($child);     }          trait StackableTrait{       private $containter_contents = array();       private $container_parent = NULL;            public function add($content){         if(is_a($content, "Stackable")){            $content->_registerParent($this); //prevents adding twice and creating loops.         }elseif(!is_string($content)){            $this->_checkLoop($content);         }         return $this->container_contents[] = $content;       }       public function _registerParent($parent){         if(empty($this->container_parent)){           $this->container_parent = $parent;           return;         }         throw new StackableException("Object has already been added to a parent");       }       public function _checkLoop($child){         if(in_array($child,$this->container_contents,TRUE){           throw new StackableException("Object has already been added to a parent");         }elseif(!empty($this->container_parent)){           $this->container_parent->_checkLoop($child);         }       }     }          class StackableException extends Exception{}      As you can see all of the contents of the file are interrelated, any class that wants to use the StackableTrait will need to also implement the interface so the class checking in the trait functions will work. And only things using _StackableTrait_ or implementing _Stackable_ will have access to throw _StackableException_.