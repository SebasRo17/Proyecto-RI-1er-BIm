I am trying to define a notation rule so that for selected symbols subsripts will be equivalent to function parameters. My understanding of the docs suggests the following               << Notation`          sub[f_] := Notation[ParsedBoxWrapper[\(Subscript[\(f, \(\ x_\)\)]\)]          \[DoubleLongLeftRightArrow] ParsedBoxWrapper[\(f[x_]\)]]      The idea is to be able to do the following               sub[P]     Subscript[P, i] := F[i]     Subscript[P, a]      and have Mathematica treat it the same as               P[i] := F[i]     P[a]      But `Subscript[Q, i]` should remain as a just a subscript expression Mathematica throws the following error on the definition of `sub`:               Notation::expatnf: Pattern 'x' appearing in the external representation 'Notation`Private`identityForm[RowBox[{OverBar,[,x_,]}]]' cannot be filled since 'x' does not appear in the internal representation 'Notation`Private`identityForm[RowBox[{mean,[,x,]}]]'. >>      I would like to understand what the problem is and fix it. I am also interest in alternative approaches to achieving the same effect. I am also interested finding more documantation for the Notation package then is in the standard documentation, particularly extended examples and conceptual overviews. ** EDIT Here is what I get with Leonid's approach               In[1]:=     Remove[P, F]     Clear[Subscript, MakeExpression, makeExpression];      MakeExpression[expr_, form_] :=         With[{result = makeExpression[expr, form]},          result /; Head[result] === HoldComplete];      ClearAll[sub];      sub[f_] := With[{boxed = MakeBoxes[f]},          makeExpression[RowBox[{"Subscript", "[",              RowBox[{boxed, ",", arg_}], "]"}], form_] :=           MakeExpression[RowBox[{boxed, "[", arg, "]"}], form]];           In[6]:= sub[P]          In[7]:= Subscript[P, i]:= F[i]      I would really prefer the rule to be interpreted as `P[i] := F[i]`. I want the subscripts to be purely cosmetic. On my system the `Subscript[P, i]` on the LHS does not get interpreted that way:               In[8]:= DownValues[Subscript]          Out[8]= {HoldPattern[Subscript[P, i]] :> F[i]}          In[9]:= DownValues[P]          Out[9]= {}      The following shows that the parsing of the notation works, but I actually want the rendering to reverse the parsing when in StandardForm.               In[10]:= Subscript[P, a]          Out[10]= P[a]      However the `:=` definition does not work as kick in:               In[11]:= Subscript[P, i]          Out[11]= P[i]      Also the parsing code only works on code that was entered after the notation related code was evaluated. Expressions entered before the notation code was evaluated are not effected, even after restarting Mathematica. The following expression is in the same notebook but was in there from before Leonids answer and is identical to the first expression above:               In[12]:= Subscript[P, a]          Out[12]= Subscript[P, a]      In other words the notebook is somehow remembering which expressions were entered before the notation code and which were entered after even across Mathematica restarts.