I am interested in calculating how the roots of an equation change as one of the variables does, when the equation is evaluated numerically rather than symbolically. I have edited this code to be simpler than the original one.               Remove["Global`*"]     d = 1/1000; mig = 1/500; kappa = 1/10;     N1[x_] = 50*(1 + 17/100*x - mig);     Estar[x_] = (d)/(kappa*mig*N1[x]);     lambda[x_] = mig*N1[x]*(1 - Estar[x]);     I1star[x_] = kappa*Estar[x]*(1 - Estar[x])*mig*N1[x]/d;     M1[q_, t_, z_] = Sum[z^(n)*d*E^(-t*d)*E^(-N1[q]*mig*t)*(N1[q]*mig)^n*t^n/n!, {n, 0,      Infinity}];     Part1[q_, z_] := NIntegrate[M1[q, t, z], {t, 0, Infinity}]     RootFcn[q_, z_] := (1 - Estar[1]) + Estar[1]*((1 - kappa) + kappa*Part1[q, z]) - z      The question I'm interested in is how the solutions for z of (RootFcn[q,z]=0) change as q increases at the point q=1. There are two roots, 1 and a value between 0 and 1; the smaller value is the one that I'm interested in. If one uses Integrate in the above instead of NIntegrate, they can simply take the solution of Solve[RootFcn[q, z] == 0, z], and use D[] to get the derivative where q=1 (which yields -0.00124613). However unfortunately in my actual problem this is not possible to do as it's more complicated and cannot be evaluated symbolically; and NIntegrate must be used. Also I cannot use the definition of a derivative (Solving for RootFcn at arbitrarily close values and divide by some epsilon), because in my problem it is too time-consuming due to the very high precision required to get a reasonable answer. So each time I numerically evaluate Solve[RootFcn[q, z] == 0, z] it takes a few minutes but since I will have to solve an equivalent problem to this derivative question thousands of times, this is prohibitive. It seems like this is probably possible using numerical derivatives, but I'm not sure. Any help would be very appreciated.