This is a follow-up to my (solved) question How to distribute a generic function of two arguments (without evaluating the arguments) Say, I have a binary function               f[x : a_List, y : b_List] := g[a, b]      Now if               u={u1,u2};     v={v1,v2};     w={w1,w2};      I want do distribute `f[u,v+w]` prior to evaluating `v+w` which works fine with the solution proposed by Mr. Wizard to my previous question               Distribute[Unevaluated@f[u,v+w]]     (** g({u1,u2},{v1,v2})+g({u1,u2},{w1,w2}) **)      But now what if I do               expr = v + w;      and try to distribute f[u,expr]? I would like to get the same result as before, however this yields               f[u,expr]        (** g({u1,u2},{v1+w1,v2+w2}) **       as of course `v+w` is evaluated when assigning to `expr`. Now a SetDelayed approach `expr := v+w` also doesn't help. I then thought of doing               expr = Hold[v+w];     Distribute[Unevaluated@ftest[u, ReleaseHold[expr]]]     (** g({u1,u2},{v1+w1,v2+w2}) **)      but this also gives the wrong (i.e. not the desired) result. So, how do I do this?