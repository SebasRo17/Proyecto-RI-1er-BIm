I am re-writing the question using a very simple example so not to confuse matters with the another question being asked where I used the example from there. In general, how to add logic to switch between one `TransformationFunctions` or another inside `Simplify` or any function that uses `TransformationFunctions`? For example,               ClearAll[n, tf, e, cf];     cf[e_] := LeafCount@e     tfForIntegerOnly[e_] := If[MatchQ[e, 2 n], n, e]     tfForRealOnly[e_] := If[MatchQ[e, 2 n], n^2, e]          Assuming[Element[n, Integers],       Simplify[2 n, TransformationFunctions -> {Automatic, tf}, ComplexityFunction -> cf]]      How to make it use `tfForIntegerOnly` when `Element[n, Integers]` and use `tfForRealOnly` when `Element[n, Reals]` **Where to add this logic**? How to pass the assumptions around or check for it and what it contains? Since Mathematica does not have types (in traditional sense) associated or attached with the symbols themselves (other than looking at Head, which in this case provides no information), one needs a general way to handle this. ## Original question below I'd like to simplify an expression under one set of assumptions using one `TransformationFunctions` function and use another `TransformationFunctions` function (or use `Automatic`) for different set of assumptions. The problem is that the `TransformationFunctions` itself has no access to these `Assumptions` used before in calling `Simplify` and hence it is hard to find a way to add logic to detect which assumptions is used at that level. To explain, I want to apply `TransformationFunctions` to transform `Gamma[1/2 + n]` to `Sqrt[Pi] (Factorial2[2 *(n - 1/2) - 1])/2^(n - 1/2)` but only when `Element[n, Integers] && n > 1`. I am not able to find a way to pass these assumptions from the `Assuming` call to the `TransformationFunctions` or a way to make 2 different `TransformationFunctions` and use vs. the other inside `Simplify` itself. Here an example               ClearAll[n, tf, e, cf];     cf[e_] := Count[e, Gamma, Infinity, Heads -> True] 1000 + LeafCount@e      tf[e_] := If[MatchQ[e, Gamma[1/2 + n]],Sqrt[Pi] (Factorial2[2 *(n - 1/2) - 1])/2^(n - 1/2), e]          Assuming[Element[n, Integers] && n > 1,Simplify[Gamma[1/2 + n] + Gamma[1/3 + n],      TransformationFunctions -> {Automatic, tf},ComplexityFunction -> cf]]      ![Mathematica graphics](http://i.stack.imgur.com/X6AVz.png) But now if I assume `n` is `Real`, I do not want to modify the code above, but I want the `TransformationFunctions` to automatically to detect this and in this case not apply this transformation rule or add some logic inside `Simplify` to use one `TransformationFunctions` vs. the other based on `Assumptions`               ClearAll[n, tf, e, cf];     cf[e_] := Count[e, Gamma, Infinity, Heads -> True] 1000 + LeafCount@e      tf[e_] := If[MatchQ[e, Gamma[1/2 + n]], Sqrt[Pi] (Factorial2[2 *(n - 1/2) - 1])/2^(n - 1/2), e]          Assuming[Element[n, Reals], Simplify[Gamma[1/2 + n] + Gamma[1/3 + n],        TransformationFunctions -> {Automatic, tf},        ComplexityFunction -> cf]]      ![Mathematica graphics](http://i.stack.imgur.com/xM5b0.png) which is wrong since now `n` is not an integer now. I'd like to be able to write               Assuming[Element[n, Reals], Simplify[Gamma[1/2 + n] + Gamma[1/3 + n],     TransformationFunctions ->Cases[Element[n, Reals], Automatic, Element[n, Integers] && n > 1,tf],       ComplexityFunction -> cf]      ]      But the above is not valid syntax. * * *