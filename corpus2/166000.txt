Say we have a task logging system, when a task is logged, the user specifies a category and the task defaults to a status of 'Outstanding'. Assume in this instance that Category and Status have to be implemented as entities. Normally I would do this: **Application Layer:**               public class TaskService     {         //...              public void Add(Guid categoryId, string description)         {             var category = _categoryRepository.GetById(categoryId);             var status = _statusRepository.GetById(Constants.Status.OutstandingId);             var task = Task.Create(category, status, description);             _taskRepository.Save(task);         }     }      **Entity:**               public class Task     {         //...              public static void Create(Category category, Status status, string description)         {             return new Task             {                 Category = category,                 Status = status,                 Description = descrtiption             };         }     }      I do it like this because I am consistently told that entities should not access the repositories, but it would make much more sense to me if I did this: **Entity:**               public class Task     {         //...              public static void Create(Category category, string description)         {             return new Task             {                 Category = category,                 Status = _statusRepository.GetById(Constants.Status.OutstandingId),                 Description = descrtiption             };         }     }      The status repository is dependecy injected anyway, so there is no real dependency, and this feels more to me thike it is the domain that is making thedecision that a task defaults to outstanding. The previous version feels like it is the application layeer making that decision. Any why are repository contracts often in the domain if this should not be a posibility? Here is a more extreme example, here the domain decides urgency: **Entity:**               public class Task     {         //...              public static void Create(Category category, string description)         {             var task = new Task             {                 Category = category,                 Status = _statusRepository.GetById(Constants.Status.OutstandingId),                 Description = descrtiption             };                  if(someCondition)             {                 if(someValue > anotherValue)                 {                     task.Urgency = _urgencyRepository.GetById                         (Constants.Urgency.UrgentId);                 }                 else                 {                     task.Urgency = _urgencyRepository.GetById                         (Constants.Urgency.SemiUrgentId);                 }             }             else             {                 task.Urgency = _urgencyRepository.GetById                     (Constants.Urgency.NotId);             }                  return task;         }     }      There is no way you would want to pass in all possible versions of Urgency, and no way you would want to calculate this business logic in the application layer, so surely this would be the most appropriate way? So is this a valid reason to access repositories from the domain? **EDIT: This could also be the case on non static methods:**               public class Task     {         //...              public void Update(Category category, string description)         {             Category = category,             Status = _statusRepository.GetById(Constants.Status.OutstandingId),             Description = descrtiption                  if(someCondition)             {                 if(someValue > anotherValue)                 {                     Urgency = _urgencyRepository.GetById                         (Constants.Urgency.UrgentId);                 }                 else                 {                     Urgency = _urgencyRepository.GetById                         (Constants.Urgency.SemiUrgentId);                 }             }             else             {                 Urgency = _urgencyRepository.GetById                     (Constants.Urgency.NotId);             }                  return task;         }     }