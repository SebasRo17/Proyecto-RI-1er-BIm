I see myself using more and more immutable types _when the instances of the class are not expected to be changed_. It requires more work (see example below), but makes it easier to use the types in a multithreaded environment. At the same time, I rarely see immutable types in other applications, even when mutability wouldn't benefit anyone. **Question:** Why immutable types are so rarely used in other applications?   * Is this because it's longer to write code for an immutable type,   * Or am I missing something and there are some important drawbacks when using immutable types? ## Example from real life Let's say you get `Weather` from a RESTful API like that:               public Weather FindWeather(string city)     {         // TODO: Load the JSON response from the RESTful API and translate it into an instance         // of the Weather class.     }      What we would generally see is (new lines and comments removed to shorten the code):               public sealed class Weather     {         public City CorrespondingCity { get; set; }         public SkyState Sky { get; set; } // Example: SkyState.Clouds, SkyState.HeavySnow, etc.         public int PrecipitationRisk { get; set; }         public int Temperature { get; set; }     }      On the other hand, I would write it this way, given that getting a `Weather` from the API, then modifying it would be weird: changing `Temperature` or `Sky` wouldn't change the weather in real world, and changing `CorrespondingCity` doesn't make sense neither.               public sealed class Weather     {         private readonly City correspondingCity;         private readonly SkyState sky;         private readonly int precipitationRisk;         private readonly int temperature;              public Weather(City correspondingCity, SkyState sky, int precipitationRisk,             int temperature)         {             this.correspondingCity = correspondingCity;             this.sky = sky;             this.precipitationRisk = precipitationRisk;             this.temperature = temperature;         }              public City CorrespondingCity { get { return this.correspondingCity; } }         public SkyState Sky { get { return this.sky; } }         public int PrecipitationRisk { get { return this.precipitationRisk; } }         public int Temperature { get { return this.temperature; } }     }