In a traditional GoF Proxy, you have an Interface, an Implementation, that implements the Interface, and a Proxy that also implements the Interface, references an instance of Implementation, and delegates the calls on the Interface methods to the same methods in the Implementation instance. Say you would call the Interface/Implementation pair a "Fragment", and you would have several different such pairs. Now imagine you create a Whole Interface that implemented all those Fragment interfaces, and a single Whole Proxy that implemented the Whole Interface, and delegated to the appropriate Fragment Implementation instance. A code (Java) example:               // Fragment A:     interface FragmentA { ... }     class FragmentAImpl implements FragmentA { ... }     // Whole A. That is the interface that "clients use"     interfaces WholeA extends FragmentA { // EMPTY! }     // *automatically generated* Proxy:     class ProxyA implements WholeA {         private FragmentA implA;         // Implements FragmentA through delegation to implA     }          // Fragment B:     interface FragmentB { ... }     class FragmentBImpl implements FragmentB { ... }     // Whole B. That is the interface that "clients use"     interfaces WholeB extends WholeA, FragmentB { // EMPTY! }     // *automatically generated* Proxy:     class ProxyB extends ProxyA implements WholeB {         private FragmentB implB;         // Implements FragmentB through delegation to implB     }          // Fragment C: similar to Fragment B, but with different *added behavior*.      Is this pattern at all (since Patterns must be common solution to common problems)? And if so, as it got a name? Or could it be cleanly defined as a combination of patterns? Being able to clearly describe how this code works in terms of patterns would make it much easier to explain to others how create compatible code, and help to find a framework that already implements this pattern. A _Proxy_ normally delegates to _a single instance_. A _Facade_ normally offers _a different interface_ to that _multiple objects_ it hides. A _Bridge_ also offers _a different interface_ to that the _single instance_ it hides. A _Composite_ expects all components to _share the same base interface_. A _Decorator_ extends the interface of the wrapped object, like here, but normally _implements the additional functionality itself_ , instead of delegating to another objects. A Whole that implements a single Fragment is just a Proxy pattern, but a Whole that extends another Whole is closest to a Decorator pattern. There are several reasons to do it this way. Firstly, client code should see WholeB as extending WholeA, although the implementer of FragmentB cannot extend FragmentA (which was implemented by someone else). Secondly, references to WholeX (ProxyX) stay valid, even if implementation of FragmentX is replaced a runtime. Thirdly, both ProxyB and ProxyC can share _the same instance_ of FragmentAImpl.