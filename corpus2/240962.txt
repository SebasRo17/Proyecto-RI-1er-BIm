I primarily work with .Net WPF MVVM applications. I've used several frameworks, MVVM Light, Prism, etc, and I've been able to break the implementation of CRUD MVVM into three scenarios. **Scenario 1:** A web service returns a paged collection of small objects with no navigation properties, I whirl through these wrapping them with DetailVM's, because of other needed logic, and I place it in a ListCollectionView. My DetailVM's implement IEditableObject, now every Crud operation I want to do can be done through ListCollectionView, and I can keep my ListView in the UI in sync with the current CRUD operation. That is to say, if the user adds an item, it is immediately added to the ListCollectionView and reflected in the UI, and if they cancel the edit, it is removed. If they save the added item it stays in the list and is persisted to the server. This can all be done with two simple view models, and some data templates, thanks to IEditableObject and ListCollectionView. **2 & 3: These are more complex, because the initial call to the web service returns a list of reference dto containing a few simple properties like Name & Id.** **Scenario 2:** In the MasterViewModel call to the web service and load quick models. When an item is selected, a second call is made to the web service to retrieve the actual object and its object graph. This is then mapped and messaged (pub/sub) over to a separate detail view model. **Scenario 3:** On the MasterViewModel have a DetailViewModel property. This couples the view models together, which seems alright as they really can't work without each other. Managing the list becomes easier as things are all in the same spot, no messaging... It's still hard to achieve what is so simple with a ListCollectionView, but I can do it without messaging between view models. \----- Summary ------ Scenario 1 = Easy to implement, works well requires minimal code. Scenario 2 & 3 = Harder to implement, becomes somewhat less clear where all the CRUD operations should be. Keeping items in the reference list in sync is harder. I only update the information in the list when an edit is successfully completed and saved back to the web service. Currently I keep all my crud operations in one view model. I have created a base view model for paged data, which I inherit into a CRUD view model base, and add in the commands for Add, Edit, Remove, & Cancel. So far this has been working well.