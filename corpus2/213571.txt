In the book "Clean Code" Robert Martin makes a statement regarding the following code:               public Money calculatePay(Employee e) throws InvalidEmployeeType {   switch (e.type) {         case COMMISSIONED:           return calculateCommissionedPay(e);         case HOURLY:           return calculateHourlyPay(e);         case SALARIED:           return calculateSalariedPay(e);         default:           throw new InvalidEmployeeType(e.type);   } }      Statement: The solution to this problem (see Listing 3-5) is to bury the switch statement in the basement of an ABSTRACT FACTORY,9 and never let anyone see it. What I don't understand is why does he call it an Abstract Factory? If the solution is to create 3 Employee subclasses each implementing it's own CalculatePay method then the logic is moved up to let's say the controller. But then we have to create a "Simple Factory (Idiom)" not an Abstract Factory as presented in the original book from the GOF. The Abstract Factory has the intent to: "Provide an interface for creating families of related or dependent objects without specifying their concrete classes." but this is clearly not the case.