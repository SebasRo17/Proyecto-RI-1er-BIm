I have a program which has a GUI and performs some very heavy mathematical computations for a couple of minutes and then outputs a result. When I try to directly interface it through its DLL's, it runs fine, but it doesn't run at 100% CPU usage like the GUI does. Why is this? I understand the reason why computational heavy program might not run at 100% is due to I/O that it might be doing but this program doesn't do any, not even a single printf(). Files are being generated at the end of execution in both the GUI and DLL versions of the program. The interface program makes mulitple calls to the DLL during execution as well. It is written in C, compiled using VS2008 CL compiler running in Release mode. Running on Intel i5 CPU with 4GB RAM (60% utilization average, never above 70%). When I set affinity to the process to one CPU (in this case, 1/4 "CPU's", 2 cores with 2 threads each), the GUI uses 100% of that dedicated CPU for about 2 min. My interfacing application uses anywhere from 60-80% CPU for about 5 minutes. I use Window's Performance Tab upon performing `CTRL`+`SHFT`+`ESC`. \---EDIT--- I found that database calls (there are a few specific ones) are being preempted a lot for extended periods of time (usually 5 times slower). Using Process Explorer I was able to find out that each program uses exactly the same amount of CPU time -> leading to my conclusion about preemption. For anyone that doesn't know about this tool, download Process Explorer from SysInternals, very useful. \---EDIT--- I found that the GUI opens a single static connection to the database. While my interface doesn't do that, leading to opening and closing the connection thousands of times. Opening it once for the lifetime brought the CPU up to 100%.