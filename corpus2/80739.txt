When developing in OOP, sometimes an interface / contract is given by a library that you cannot alter. Let's call this interface J. Now you have an object of class A that consumes objects that implements this interface. Inside A only a small part of the interface's definitions are needed. Some of the object classes are created by me during the project (let's call one of them type D), so there's an overhead in the implementation of everything inside interface J. I want to implement a subset of the functionality in interface J, but my solutions so far do not satisfy me:   * implementing every aspect of J and then throwing "notImplementedExceptions" misinforms the user of my objects: it would seem my objects of type D do conform to interface J, but they don't - and other consumers of my objects (that accept objects implementing interface J) can't rely on the integrity of my objects.    * Implementing a newly defined interface prohibits me from using objects that implement only interface J, although interface J is fully compatible with my own interface.   * Letting my custom objects implement interface J would create significant overhead, because they don't need all this functionality. When I was able to alter interface J, I would create a "super-interface" K that had this subset of the functionality of interface J, and make interface J inherit from interface K. But I cannot alter interface J. What is an object-oriented solution to this problem? Is the best solution still implementing "just" interface J? Or are there OOP-ways to "superclass" an interface without altering it?