I work for an analog company on a proprietary sequencer having a few bytes of free RAM (maybe 20 bytes, not kB, bytes); maybe 500 bytes statically allocated; 8 registers including PC; no indirection (in C, a "pointer"); no stack. We write 100% of our application code in assembly, and 95% of our business depends on legacy code, meaning any new code must neatly fit into the existing assembly code. I write assembly code and verify/debug code written (and _not_ tested) by my superiors. The sequencer would have been considered primitive in the 70's. There is no `MOV` instruction: to move `M` into `K`, you must write `CLX A; ORX M; STX K` which much complicates dependency resolution, or at least optimization. Many operations work only on specific registers: for example, a 32-bit right shift uses `K` in the upper word and M in the lower word. This sequencer is used for extremely low-power applications, and has a ROM program. The chip sells for under $0.50 in unfathomably large quantities. I hope I need not justify a higher level language to you; however, my management is not convinced it will be "worth the effort" of developing it, or porting an existing compiler. I feel confident I could write a little Lisp evaluator to produce machine code, but what would that get me? I feel like what I'm doing is an immense waste of time, money, not to mention my own professional development. Is there some authoritative resource I can show my boss and his boss to make them understand? All of this seems like common sense to me (having studied software, my superiors having studied analog, and not being able to write a single line of C), and it's very hard to convey the idea that "if you put a round block into a square hole, it will not fit" to somebody who doesn't know what a block, hole, round, or square is.