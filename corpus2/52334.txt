In recreational number theory, a narcissistic number (also known as a pluperfect digital invariant (PPDI), an Armstrong number(after Michael F. Armstrong) or a plus perfect number) is a number that is the sum of its own digits each raised to the power of the number of digits. For example,the three digits armstrong number: ![enter image description here](http://i.stack.imgur.com/dXNC5.jpg) Now I want to find the 21 digits armstrong number.I know the answer is {449177399146038697307, 128468643043731391252}. Better code to find Narcissistic number.In this post,they use brute force method to test all number.It is impossible to use this method to find 21digits armstrong number. My thought is just consider the count of numbers. For example, there are two 2, two 7,one 9.Since 2*2^5+2*7^5+1*9^5=92727,so {{2,2,1},{2,7,9}} is correct combination and 92727 is 5 digits armstrong number. My code is:               Clear["Global`*"]     n = 21;     counts = IntegerPartitions[n, 10];     test1 = Compile[{{counts, _Integer, 1}, {num, _Integer, 1}},          10.^(n - 1) < counts.num^(1. n) < 10.^n];     test2 = Compile[{{list, _Integer, 1}, {counts, _Integer, 1}, {num, _Integer, 1}},         Catch[          Do[If[Count[list, num[[i]]] != counts[[i]], Throw[False]], {i, Length[counts]}];               Throw[True]]];     f[counts_] := Module[{allpossible, allnum},       allpossible = Permutations@counts;       allnum = Subsets[Range[0, 9], {Length[counts]}];       Select[Join @@ Outer[List, allpossible, allnum, 1],           test1 @@ # && (test2[IntegerDigits[#1.#2^n], #1, #2] & @@ #) &]       ]     Length@counts     Monitor[#1.#2^n & @@@ Join @@ Table[f@counts[[i]], {i, %}], 1.i/%] // AbsoluteTiming      It will take about 6~10 minutes to find 21digits armstrong number.But the maximal armstrong number is 39 digits, so my code is not enough high efficiency.How can I increase of efficiencyï¼Ÿ