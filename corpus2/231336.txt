There are many useful functions in `<algorithm>`, but all of them operate on "sequences" - pairs of iterators. E.g., if I have a container and like to run `std::accumulate` on it, I need to write:               std::vector<int> myContainer = ...;     int sum = std::accumulate(myContainer.begin(), myContainer.end(), 0);      When all I intend to do is:               int sum = std::accumulate(myContainer, 0);      Which is a bit more readable and clearer, in my eyes. Now I can see that there might be cases where you'd only want to operate on parts of a container, so it's definitely useful to have the _option_ of passing ranges. But at least in my experience, that's a rare special case. I'll usually want to operate on whole containers. It's easy to write a wrapper function which takes a container and calls `begin()` and `end()` on it, but such convenience functions are not included in the standard library. I'd like to know the reasoning behind this STL design choice.