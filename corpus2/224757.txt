I am doing research on squares, and I thought of using constraint- satisfaction-problems solvers for proving or disproving some conjectures. As a simple example problem, consider the following task:               Draw two green squares and two red squares, such that:      - All squares of the same color are interior-disjoint;      - All squares of different colors are interior-intersecting.      To solve this problem, I wrote the following script in the Minion language. To make the program shorter, I used C-style macros:               MINION 3          **VARIABLES**     // There are 2 red squares and 2 green squares.     // for every square, x and y are the south-west corner, and s is the side-length:     DISCRETE xred[2] {1..100}     DISCRETE yred[2] {1..100}     DISCRETE sred[2] {1..100}          DISCRETE xgrn[2] {1..100}     DISCRETE ygrn[2] {1..100}     DISCRETE sgrn[2] {1..100}          **CONSTRAINTS**     // The following macros handle intersection relations between squares.      // Let a and b be names of squares.      // intersect(a,b) defines constraints meaning "rectangle a intersects rectangle b".     // disjoint(a,b) defines constraints meaning "rectangle a does not intersect rectangle b".          // a and b interior-intersect, if ALL the following equalities hold:     //  a.x + a.s > b.x     //  b.x + b.s > a.x     //  a.y + a.s > b.y     //  b.y + b.s > a.y     #define intersect(a,b) \     watched-and({\         sumgeq([x##a,s##a,-1], x##b), \         sumgeq([x##b,s##b,-1], x##a), \         sumgeq([y##a,s##a,-1], y##b), \         sumgeq([y##b,s##b,-1], y##a)})          // a and b are interior-disjoint if they do not interior-intersect.     // We need a special macro for this because Minion does not support negation of constraints.     #define disjoint(a,b) \     watched-or({\         sumleq([x##a,s##a], x##b), \         sumleq([x##b,s##b], x##a), \         sumleq([y##a,s##a], y##b), \         sumleq([y##b,s##b], y##a)\         })          // Squares of the same color must be disjoint:     disjoint(red[0],red[1])     disjoint(grn[0],grn[1])          // Squares of the different colors must intersect:     intersect(red[0],grn[0])     intersect(red[0],grn[1])     intersect(red[1],grn[0])     intersect(red[1],grn[1])          **EOF**      I ran the solver using the following shell command:               cpp myfile > myfile.tmp     minion myfile.tmp      Minion returned the following result               Sol: 1 1      Sol: 1 4      Sol: 3 3           Sol: 1 3      Sol: 3 1      Sol: 2 4       read:   * red #0 starts at (1,1) with side 3;   * red #1 starts at (1,4) with side 3;   * grn #0 starts at (1,3) with side 2;   * grn #1 starts at (3,1) with side 4; This is what it looks like on the plane: ![enter image description here](http://i.stack.imgur.com/GYIgN.png) Indeed, squares of the same color are interior-disjoint while squares of different colors intersect! (Of course there are many other solutions. Minion returns the first solution it finds, which is OK for my needs). Now, my questions are:   * First, do I use the right tool for the task? Is there a way to do what I just did without the need to explicitly define what "intersect" means?   * Second, do I use the Minion language correctly?