I wish to color a 2-dimensional lattice grid according to the value of a function at each lattice-node. More specifically, if I have 9 angles in a 3x3 array,               angles={{0, π, π}, {0, 0, π/2}, {π/2, 0, 3 π/3}}      then one can plot these angles on a lattice-grid by the following code in Mathematica:               angles = {{0, π, π}, {0, 0, π/2}, {π/2, 0, 3 π/3}};     GraphicsGrid[      Map[Graphics[{         LightGray, Circle[{0, 0}, 1],          Hue[#/(2 π), .6, .8], Thick, Arrowheads[Medium], Arrow[{{0, 0}, {Cos[#], Sin[#]}}]}] &,        angles, {2}]]      Here, the colouring is done using the Hue command according to the value of each angle. However, now I want to compute a function `f[i,j]`; to be more specific,               f[i_,j_]:=Cos[angles[[i + 1, j]] - angles[[i, j]]] + Cos[angles[[i, j+1]] - angles[[i, j]]];       with               angles[[n+1,i_]]:=angles[[1,i]];     angles[[i_,n+1]]:=angles[[i,1]];       i.e., the boundary conditions. In the first code, Hue is used with the `angles[[i,j]]` (through `#`), which is probably straightforward. But is it possible to use `f[i,j]` instead, where `f[i,j]` is defined as above? P.S. This question is related to: data visualization on a lattice grid Thanks! ## dbm P.S. The final code, thanks to BoLe's answers:               Clear["Global`*"];     n := 10     angles = Table[RandomReal[{-Pi, Pi}], {i, n}, {j, n}];     f[here_, down_, right_] := Cos[down - here] + Cos[right - here]     g[list_, {i_, j_}] :=       Module[{m, n}, {m, n} = Dimensions[list]; {list[[i, j]],         If[i != m, list[[i + 1, j]], -list[[1, j]]],         If[j != n, list[[i, j + 1]], -list[[i, 1]]]}]     GraphicsGrid[      MapIndexed[       Graphics[{LightGray, Circle[{0, 0}, 1],           Hue[Rescale[f @@ g[angles, #2], {-2, 2}, {0, 1}]], Thin,           Arrowheads[Small], Arrow[{{0, 0}, {Cos[#], Sin[#]}}]}] &,        angles, {2}]]