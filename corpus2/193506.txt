I have the following type hierarchy:               interface I:         ----+class B implements I         ----+class C implements I         ----+class D implements I      I have another class `Consumer1` that supports types `C` and `D` but not `B` (in its various methods) and a class `Consumer2` that supports type `B`. I have total control over `Consumer1` and `Consumer2` so I can choose how to implement them. Now, at runtime I expect my callers to give me a collection of `I`s and I will decide internally whether to route them to `Consumer1` or `Consumer2`. Now, a very bad non-OOP way is to do an `if instanceof` check all over the place and mess things up. One alternative is to register a supporting class `Map<Class<?>, Class<?>>` that shall contain `{{B,Consumer2}, {C,Consumer1}, {D,Consumer1}}`. This is as bad as the previous one because I shall have to cast objects after figuring out whether to send them to `Consumer1` or `Consumer2`. A second alternative is to apply a `Visitor` pattern which would solve this rather neatly but prevent my interface from being extended further (unless I modify the visitor). Is there a neater alternative?