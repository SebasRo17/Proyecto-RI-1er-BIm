I have some code inside a `Manipulate`, whose goal is to allow the user to edit the upper half of the matrix while keeping it symmetric at all time. The minimal code is the following:               Manipulate[      Refresh[         i = i + 1;         Do[Cmat[[i, j]] = Cmat[[j, i]], {i, 2, 6}, {j, 1, i - 1}];       , TrackedSymbols -> {Cmat}];      {i, Grid[Array[InputField[Dynamic[Cmat[[#1, #2]]], FieldSize -> 5, Enabled -> #1 <= #2] &, {6, 6}]]}      ,      Initialization :> (        i = 0;        Cmat = ConstantArray[0, {6, 6}];        )]      I added the `i` variable as a counter, and I expected it to be only incremented when I actually change the value of one of the `Cmat` elements. What actually happens is that `i` increases near the speed of the runloop, and that code actually hogs the CPU (one core of it, anyway). I suppose what happens is that the modification of the tracked value inside `Refresh` actually triggers `Refresh` itself, hence the loop. How can I prevent this? I thought restricting `TrackedSymbols` to the upper half of `Cmat` would do the trick, but it changes nothing. Is there a way, inside of `Refresh`, to change `Cmat` without it being tracked? The opposition functionality exists, in the form of `Update`.