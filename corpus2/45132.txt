I have one longer string, `longString`, and a set $S$ of shorter strings `{ss1,ss2,ss3,...}`. I'd like to print out `longString` but where the positions of the shorter strings are indicated in some nice way. For example, perhaps we could color the characters in the longer string with a specific specified color for each shorter string. I.e. where would would have an array like `{{ss1,'Red'},{ss2,'Green'},{ss3,'Blue'},...}` and would then color words appearing in `longString` `Red` if the word is `ss1`, `Blue` if the word is `ss2`, and so forth. The idea would be to shade `Brown` / etc. overlap regions if they occur. Is this possible? One can use `StringPosition` to return the first and last character position for a set of substrings or words appearing in a larger string, for example:               StringPosition["TheBrownFox", {"Brown","Fox"}]          out: {{4, 8}, {9, 11}}      Now, one of the more interesting parts of this question, IMO, is how we handle overlaps between substrings / words (i.e. `ss1`, `ss2`, `ss3`, etc.). For example, if we add the nonsense word "wnFo" to the previous example, we have overlapping words:               testString = TheBrownFox;     StringPosition[testString, {"Brown","Fox","wnFo"}]          out: {{4, 8}, {7, 10}, {9, 11}}      So we need to do a kind of "surgery" on the output list for `StringPosition` s.t. there is never a situation where we have `{..., {integerOne, intTwo}, {intThree, intFour}, ...}` where it is NOT the case that `intOne < intTwo < intThree < intFour`. Update: Please see Kuba's very slick answer to my question concerning how one might do this: Identifying and isolating sections of overlap in a set of integer intervals * * * I am inspired by this example https://reference.wolfram.com/mathematica/example/HighlightWordsOfAGivenLength.html where words of a certain length are highlighted and bolded.