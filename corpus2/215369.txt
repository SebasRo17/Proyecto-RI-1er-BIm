I'm currently working on a project where I'm receiving an object via web service (WSDL). The overall process is the following: Receive object -> add/delete/update parts (or all) of it -> and return the object with the changes made. The thing is that sometimes these changes are complicated and there is some logic involved, other databases, other web services, etc. so to facilitate this I'm creating a custom object that mimics the original one but has some enhanced functionality to make some things easier. So I'm trying to have this process: Receive original object -> convert/copy it to custom object -> add/delete/update -> convert/copy it back to original object -> return original object. Example:               public class Row     {         public List<Field> Fields { get; set; }         public string RowId { get; set; }         public Row()         {             this.Fields = new List<Field>();         }     }          public class Field     {         public string Number { get; set; }         public string Value { get; set; }     }      So for example, one of the "actions" to perform on this would be to find all `Fields` in a `Row` that match a `Value` equal to something, and update them with some other value. I have a `CustomRow` class that represents the `Row` class, how can I make this class unit testable? Do I have to create an interface `ICustomRow` to mock it in the unit test? If one of the actions is to sum all of the `Values` in the `Fields` that have a `Number` equal to `10`, like this function, how can design the custom class to facilitate unit tests. Sample function:               public int Sum(FieldNumber number)     {         return row.Fields.Where(x => x.FieldNumber.Equals(number)).Sum(x => x.FieldValue);     }      Am I approaching this the wrong way?