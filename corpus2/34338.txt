On searching Mathematica.SE for information about overloading functions, I came across several threads about `PatternTest` and `Condition`, and I understand the basic examples like matching by `EvenQ`. However I'm having trouble imagining how I'd use these features to implement checks having to do with "whole" lists. * * * For example, I'd like to define a function `Convert` of the form               Convert[quantities_, prices_] :=      _only_ if `quantities` and `prices` are equal-length lists. In other words, if `Length[quantities] != Length[prices]` then `Convert` should behave as if undefined. * * * For a more complex example, I'd like to define an overloaded version,               Convert[dateQuantityList_, datePriceList_] :=      where `dateQuantityList` and `datePriceList` look like               {{{2012, 1, 1, 9, 30, 7}, 150},      {{2012, 1, 1, 9, 30, 12}, 130},      {{2012, 1, 1, 9, 30, 33}, 470},      ...     }      and               {{{2012, 1, 1, 9, 30, 7}, 24.56},      {{2012, 1, 1, 9, 30, 33}, 24.58},      ...     }      such that the function is only defined if all elements in `dateQuantityList[[All, 1]]` and `datePriceList[[All, 1]]` are valid `DateList`s. (Is there something like a `DateListQ`? But even supposing so, again, I'm not clear on how to apply `PatternTest` or `Condition` to a property of an entire list, not its elements...) (The goal of the latter overload is to do a "left join" based on the date, _i.e._ discard prices that don't have corresponding dates in the quantities list, and calling the original form, `Convert[q_, p_]`. I know how to do that part using `GatherBy`--it's the `PatternTest`/`Condition` part that's completely new to me.) I have many more overloads I'd like to write, but if I can get started with those two examples, I think I can figure the rest out.