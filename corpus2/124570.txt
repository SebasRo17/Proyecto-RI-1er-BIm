I am writing a _limited_ C/C++ code parser. Now, multiplication and pointer signs give me really a tough time, as both are same. For example,               int main ()     {       int foo(X * p); // forward declaration       bar(x * y);  // function call     }      I need to apply special rules to sort out if `*` is indeed a pointer. In above code, I have to find out if `foo()` is a forward declaration and `bar()` is a function call. Real world code can be lot more complex. Had there been different symbol like `@` for pointers, then it would have been straight forward. The pointers were introduced in `C`, then why some different symbol was not chosen for the same ? Was keyboard so limited ? [It will be an add-on if someone can throw light on how modern day parser deal with this ? Keep in mind that, in one scope `X` can be typename and another scope it can be a variable name, at the same time.]