What the Dependency Inversion Priciple implies in practice is that in a system, high level components should depend on abstractions of the low level components (instead of on the low level components directly), and the low level components should be defined in terms of these abstractions. The key point for my question is that _the low level components are defined in terms of the abstractions, which is defined in terms of the high level components_. Meaning: the high level components 'define the abstraction' in terms of what would be convenient for them, and the low level components have to be defined according to that abstraction (usually an interface). So if the high level component is a `Car`, and the low level component is the `Engine`, and an interface `IEngine` is defined - it will be defined according to the needs of the `Car`, and `Engine` will have to fit these needs. So if it's convenient for the `Car` to be able to simply start the engine, `IEngine` would feature a method `start()` and `Engine` would have to implement it. My question is: When starting programming on a project designed according to the Dependency Inversion Principle - are the high level components usually implemented before the low level ones, ie. "top to bottom" development? Since the principle implies that the low level components are designed according to what is convenient for the high level components, it makes sense to first start programming the high level components, and only then define the `ILowLevelComponent` interface, based on what we learned the high level components need when we programmed them. For example we're implementing a system that simulates a car. `Car` is the high level component, while `Engine` and `SteeringWheel` are the low level components. `Engine` and `SteeringWheel` take care of the concrete work of moving the car around, while `Car` takes care of coordinating everything and creating a functioning system. If we were designing the system according to DIP, that means that `Engine` and `SteeringWheel` are defined in terms of an abstraction, that is defined in terms of what is convenient for `Car`. So it would make sense to first implement `Car`, understand exactly how it's going to work in high level terms and what it needs to work, and only then define the `IEngine` and `ISteeringWheel` interfaces, according to what the `Car` needs. And then ofcourse implement the concrete classes that implement the interfaces. **So what I'm asking is: when working on a project that is designed in the spirit of DIP, is the "top to bottom development" approach common? Is this how work is usually done on project following the Dependency Inversion Principle?**