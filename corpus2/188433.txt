As part of my work on a legacy C# application I've come across a novel (to me) use of an interface & concrete implementations. I can't think of any reason why you'd do the following, but I'm pretty thick, so maybe someone else can?               public interface IContract     {         ContractImplementation1 Contract { get; }         bool IsCollection { get; }         bool Touched { get; set; }     }          public class ContractImplementation1 : IContract     {         public ContractImplementation1(string propertyOne, string propertyTwo, string propertyThree, string propertyFour)         {             PropertyOne = propertyOne;             PropertyTwo = propertyTwo;             PropertyThree = propertyThree;             PropertyFour = propertyFour;         }              public ContractImplementation1 Contract { get { return this; } }         public bool IsCollection { get { return false; } }         public bool Touched { get; set; }              public string PropertyOne { get; private set; }         public string PropertyTwo { get; private set; }         public string PropertyThree { get; private set; }         public string PropertyFour { get; private set; }              public override string ToString()         {             if (string.IsNullOrEmpty(PropertyFour))                 return string.Format("{0} => {1}: {2}", PropertyOne, PropertyTwo, PropertyThree);             else                 return string.Format("{0} => {1}: {2} {3}", PropertyOne, PropertyTwo, PropertyThree, PropertyFour);         }          }          public class ContractImplementation2 : IContract     {         public ContractImplementation1 Contract { get { return null; } }         public bool IsCollection { get { return true; } }         public bool Touched { get; set; }              public List<ContractImplementation1> Contracts = new List<ContractImplementation1>();     }      I can't get my head around the super-type having a property that is a sub-type of itself.   Following Cosmin's answer: I can't get my head around why you'd have the sub- type as a property given that the property returns itself on the implementation (rather than a 'parent' of the same type i.e. a different instantiation of the super-type).