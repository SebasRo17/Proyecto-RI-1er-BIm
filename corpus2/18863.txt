At first, consider integration of pure `InterpolatingFunction`. Importing some data (works in v.9, for earlier versions one can use this link to download zipped `M` file which can be imported by `data=Import["data.zip", "data.m"]`):               data = First@        Import["http://webbook.nist.gov/cgi/cbook.cgi?JCAMP=C67561&Index=17&Type=IR"];      Transforming the data according to an integrand:               integrand[ww_, k_] := k/ww     dataF = {#1, integrand[#1, #2]} & @@@ data;       Now interpolation and integration:               In[13]:= int = Interpolation[dataF, InterpolationOrder -> 1];     ni = NIntegrate[int[ww], {ww, dataF[[1, 1]], dataF[[-1, 1]]}]      > >     During evaluation of In[13]:= NIntegrate::ncvb: NIntegrate failed to >     converge to prescribed accuracy after 9 recursive bisections in ww >     near {ww} = {1053.057940138439}. NIntegrate obtained > 0.000035786622823277624 >     and 1.6106181332828143*^-6 for the integral and error estimates. >> >   >     Out[14]= 0.0000357866 >   I am confused by unexpectedly high absolute error (see next) and strange error `Message` generated by `NIntegrate` when integrating function of linearly interpolated data. Note that `NIntegrate` fails to converge on linear (!) piece of the polyline:               In[15]:= Nearest[dataF[[All, 1]], 1053.057940138439`, 2]      > >     Out[15]= {1053.0705299372542, 1053.010264968627} >   `Integrate` is able to integrate pure `InterpolatingFunction`s:               i = Integrate[int[ww], {ww, dataF[[1, 1]], dataF[[-1, 1]]}]      > >     0.00003537589327711996 >   We can check it by direct integration:               exactSum =       MovingAverage[dataF[[All, 2]], 2].Differences[dataF[[All, 1]]]      > >     0.00003537589420603186 >   The differences:               {ni, i} - exactSum      > >     {4.10729*10^-7, -9.28912*10^-13} >   One can see the large error for `NIntegate` output. Increasing `PrecisionGoal` and `MaxRecursion` does not give much:               ni = NIntegrate[int[ww], {ww, dataF[[1, 1]], dataF[[-1, 1]]},         MaxRecursion -> 25, PrecisionGoal -> 16] // Quiet     exactSum - ni      > >     0.000035342690008474926 >   >     3.32042*10^-8 >   At this point my questions are:   1. Why `NIntegrate` fails to converge when interpolating the polyline? Why it has biggest trouble not even on a node but on a linear piece of the polyline?    2. Is it possible to achieve for `NIntegrate` at least the same precision as it is for `Integrate`? Or, better, as it is for direct summation? Now I wish to integrate a function of linearly interpolated data:               int2 = Interpolation[data, InterpolationOrder -> 1];     ni2 = NIntegrate[int2[ww]/ww, {ww, data[[1, 1]], data[[-1, 1]]},         MaxRecursion -> 22, PrecisionGoal -> 19] // Quiet      > >     0.000035342690032342044 >   `Integrate` cannot work with functions of interpolated data at all. Direct summation gives:               area[{w1_, k1_}, {w2_, k2_}] =        Integrate[(a + b ww)/ww, {ww, w1, w2}, PrincipalValue -> True] /.          First@Solve[a + b w1 == k1 && a + b w2 == k2, {a, b}] // Simplify;     exactSum = Total[area @@@ Partition[data, 2, 1]]          exactSum - ni2      > >     0.000035375894186915904 >   >     3.32042*10^-8 >   Again, I get very large error. It is not always possible to get closed-form formula for direct summation. So the final question is: **what is the best way to integrate smooth functions of linearly interpolated data with high precision?**