Here is a minimal example of the problem I am having.               f[a___, b_, c_, d___] /; Not@OrderedQ[{b, c}] := h[b,c]f[a, c, b, d]     f[b, a, B, c, A]     SetAttributes[g, Flat]     g[a___, b_, c_, d___] /; Not@OrderedQ[{b, c}] := h[b,c]g[a, c, b, d]     g[b, a, B, c, A]      The `f` function works great. The `g` function goes into an infinite loop. How can I work around this problem? Perhaps an alternative to the `Flat` attribute or some other way of defining the commutation relation? By the way, I set the attribute `Flat` because `G[b, a, B, c, A]` is often built up as follows:               SetAttributes[G, Flat]     G[b, G[G[a, B, c], A]]      Thanks to @alephalpha for explaining what the problem is and suggesting the following fix. EDIT: ~~Actually the implementation below still runs an infinite loop on the second test cases below, independent of the order of definitions.~~ EDIT: found a fix for that loop.               (* Flatten g instead of declaring Flat attribute *)     (* The next line was a failed attempt and gets overwritten *)     g[a___, b_g, c___] := Flatten[g[a, b, c]]     (* This line works *)     g[a___, b_g, c___] := Module[{temp},       temp = Flatten[Hold@g[a, b, c], \[Infinity], g] // Release]     g[a___, b_, c_, d___] /; Not@OrderedQ[{b, c}] := h[b, c] g[a, c, b, d]     g[b, a, B, c, A]     g[b, g[g[a, B, c], A]]      I am not sure how this will affect the pattern matching of other definitions, so I will leave the question open to see what others come up with and possibly get a discussion of the pros and cons of `Flat` vs `Flatten`.