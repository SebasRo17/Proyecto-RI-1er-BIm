So, I've got the following problem: I have a number of ordered elements, ordered in the following way:   * Type 1: Must be the first element. (only one possible, always present)   * Type 2: Must be the second and following elements, if present.   * Type 3: Must be the ordered last. Stated a bit more succintly / pseudoregex: `12*3+` Now, when constructing these elements, I do so in a method, where it is easy to do something like:               public List<IElement> CreateElements(...)     {         var list = ...;         list.Add(new Type1());         list.AddRange(GetType2Elements());         list.AddRange(GetType3Elements());     }      However, there is no explicit semantic ordering - it's just a list, that I happen to construct in a certain way. A more explicit way is to have IElement implement IComparable, and then use an explicitly sorted list and returning that instead. That would carry the "sortedness" out of my construction method, and sort the entities irregardless how they are created. However, it is suddenly a bit less trivial, since atleast 3 different Compare methods must be implemented. What would you choose?