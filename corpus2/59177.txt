I'm trying to implement the solution to a math problem in Mathematica, but my code can't handle a particular boundary case. I think that I could implement a function that would do what I want it to, but it would be kind of ugly. Here is the problem: ![Here is the Math Problem \(Mathematical Proofs, Chartrand, Polimeni, and Zhang\)](http://i.stack.imgur.com/4mjO9.jpg)               letters = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l",     "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"};          GetIndexInAlphabet[letter_String] := Position[letters, letter][[1, 1]];          GetIndexInAlphabet["a"] (* 1 *)          AofAlpha[letter_String] := Module[{startIndex, endIndex},       startIndex = GetIndexInAlphabet[letter];       endIndex = startIndex + 2;       Take[letters, {startIndex, endIndex}]     ];          AofAlpha["a"] (* {a, b, c} *)          AofAlpha["z"] (* {z, a, b} *)      Does anyone have a clean way to implement the wrapping behavior that the function should have?