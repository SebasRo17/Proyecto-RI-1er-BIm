I would like to have a compact notation for specifying conditions and results in transformation rules. Consider `ReplaceAll`:               r=ReplaceAll;          r[1, x_/;x>0:>-x]      (* -1 *)      I'd like to avoid writing `x_/;` and `:>`. Here is what I came up with:               Clear[f];     Attributes[f] = {HoldRest};     f[val_,cond_,res_] := val /. x_ /; cond :> res      I could only get it to work thus,               f[1, x$>0, -x$]      (* -1 *)      That expression may not even be robust, because I'm not sure that the pattern always gets renamed `x$`. But what I'm really after is a notation like this:               f[1, x>0, -x]      without the `$` on the `x`. It should work even if `x` is defined (hence the `HoldRest` `Attribute`): for this purpose `x` should be interpreted simply as a notational convenience. How can we do this? My motivation is now one of curiosity, to get a better understanding of how scoping works inside patterns. Initially I was setting up conditions on a problem, for which many different replacement rules were to be used on the same expression, and I was looking for ways to simplify the notation so as not to keep writing `/.`, `x_/;`, and `:>`.