http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd > You are not allowed to write any production code unless it is to make a > failing unit test pass. So where do asserts fit into this? If you followed this rule you'd never write an assert without a unit test. But how would you test for the existence of an assert? The very nature of `assert` seems to make this idea impossible as the test would explode. And what about code meant to handle absurd conditions that are difficult or impossible to replicate? Some sort of FUBAR from a system call for example... You need to handle the error but the condition that causes the error is pretty rare and comes from the OS. How do you write a unit test to make that fail? Or say you're writing a template library and want to do some concept checks before going too deep into template vomit land? I don't know of any framework that supports compile time failure as a test PASS. I've tried to live by some of these TDD edicts, but at some point I've always run into walls I can't get around. These are some. I guess I should say that I'm talking about assert in the C/C++ sense in which a program, built without NDEBUG, will fault out if the assertion fails. Not some exception throwing mechanism that's _called_ assert. Didn't even realize someone would use that name for throwing exceptions.