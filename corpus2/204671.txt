I am working on a set implementation in JavaScript currently. This should kind of simulate generics as known from Java or C#. I need a mutable version of that (allows for adding/removing set values) and an immutable one. My constructor signature looks like this:               new GenericSet( 'number', [ 10, 20, 30 ] );      ,                // mutable set of mixed values (allows to add further values via "add")      new MutableGenericSet( '*', [ 'foo', 42, {}, /./ ] );      or               // DataValues.prototype.equals will be used by the set for determining equality.     new GenericSet( { type: DataValue, valueComparison: 'equals' }, [ dv1, dv2, dv3 ] );      ## Just GenericSet or one set implementation per type? Initially, my main purpose for this was to have sets of values of one type. E.g. a _DataValuesSet_ which would only accept data Values. I could then define interfaces with functions that require a _DataValuesSet_ instance. I could not use inheritance (and guess that would be bad anyhow), so I would use composition and have a _GenericSet_ / _MutableGenericSet_ instance internally. An alternative approach would be to always take _GenericSet_ and implement and use `GenericSet.requireSetOfType( type )` which would throw an error if the set's type was not the required one. My concern with doing it this way is that my interface definitions would look less explicit. Take               /**      * @param DataValuesSet dataValues      */     function printDataValues( dataValues ) {         if( !( dataValues instanceof DataValuesSet ) ) {             throw Error( '...' );         }         // ...     }      vs.               /**      * @param GenericSet dataValues Has to be a set of DataValue instances.      */     function printDataValues( dataValues ) {         // Throws error if dataValues is not a set or it it is a set with values of wrong type.         GenericSet.requireSetOfType( dataValues, DataValue );         // ...     }      perhaps using `@param GenericSet(DataValues) dataValues` for documenting the second choice would be alright? Does anyone see any further implications with the second approach or are there any alternative suggestions? To me the, second one looks more intuitive and my concern with the first one is that I would just create more overhead with constructors while I can not see any clear advantage right now.