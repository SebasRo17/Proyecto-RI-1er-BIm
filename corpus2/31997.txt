I currently work on an image segmentation scenario to detect cell nuclei in 3D using _Mathematica_. The data I have are image stacks in the TIFF file format. I would like to keep the sequence of image processing steps as small and simple as possible, since I expect the segmentation pipeline to work for several image stacks. I uploaded an example image stack containing several cell nuclei objects. Here is a screenshot of the image stack after creating an `Image3D` object out of it.               smallCropped = Image3D[Import["...\\smallExample.tif"],      Axes -> True, AxesLabel -> {"X", "Y", "Z"}]      ![raw image stack as Image3D object](http://i.stack.imgur.com/YFqVc.png) The image shows about 40-50 cell nuclei objects. Note that due to a different spacings in the z-dimension the objects appear flattened. However, this should not have any influence on the segmentation itself. If you have a look at the data you will find out that the signal to noise ratio (SNR) is very high. The segmentation of the cell nuclei objects should therefore be feasible. Here is a GIF animation of the image stack moving through the stack in the z-dimension: ![enter image description here](http://i.stack.imgur.com/Ecmgk.gif) I applied what seems to me as the most straight forward approach to segmentation in _Mathematica_ (Binarize and MorphologicalComponents):               Show[#, ImageSize -> 512] & /@ {binary = Binarize@smallCropped,        Image3D[Colorize@MorphologicalComponents@binary]}      ![enter image description here](http://i.stack.imgur.com/AYGmH.png) So far so good. As you can see from the colorized components matrix on the left, several cell nuclei objects are assigned the same object label ( _e.g._ the large pink object). Hence, preprocessing steps and a more sophisticated segmentation procedure seem to be required. After going through many types of image filtering and segmentation in _Mathematica_ I got lost at some point and ended up plugging together various different filtering and segmentation steps. In most of the cases, the more I tried the worse the results got ;) I know that there is no golden rule for segmentation in image processing but the task of correctly segmenting the objects in this scenario seems to me not that difficult and I wonder if there exists a nice and easy way. The WatershedComponents method tries to separate connected objects. Since this method currently only works in 2D in _Mathematica_ I implemented a method that first segments all the images of the stack slice by slice using a combination of `GradientFilter`, `WatershedComponents`, `Binarize`, `MaxDetect` and `DistanceTransform`. I then tried to merge the results from this 2D segmentation to end up with a 3D components matrix. I didn't put the code here but you can see the output of these two steps below (left: 2D `WatershedComponents` result, right: 3D result after merging).               compsMatrix =        SelectComponents[          WatershedComponents[GradientFilter[#, 1],            MaxDetect[DistanceTransform@Binarize@ImageAdjust@#],            Method -> {"MinimumSaliency", .3}], "Count",           10 < # < 2000 &] & /@ Image3DSlices[Binarize@smallCropped]      ![enter image description here](http://i.stack.imgur.com/5Ig1t.png) This is where I am at so far. The segmentation accuracy and object separation still looks poor to me and I am curious what steps might improve the results. My questions are: **1\. What preprocessing steps (e.g. filters) built in Mathematica might be suitable to increase the segmentation accuracy in this case? Is there a combination of standard filters that might work here?** **2\. How could I improve the separation of objects in 3D?** **3\. What about`WatershedComponents` for `Image3D` objects?** **Edit: response comment on Erosion** A suggestion in the comments was to use `Erosion`. I know that erosion helps to separate objects.however, in this scenario it did not help and I would lose much information about the objects. **Edit: response to answer by UDB** Thanks to the nice approach proposed by UDB I could go on with the 3D segmentation problem and try the approach with my data. At first the results looked very promising but when taking a closer look, I have to say that the solution proposed does not provide a satisfying result. I have checked the results for the test image stack provided above I then used the functions proposed by UDB:               distcompiled =        Compile[{{dist, _Integer, 3}},         Module[{dimi, dimj, dimk, disttab, i, j, k,           ii}, {dimi, dimj, dimk} = Dimensions[dist];         disttab = Table[(i - ii)^2, {ii, dimi}, {i, dimi}];         Table[          Min@Table[disttab[[i, ii]] + dist[[ii, j, k]], {ii, dimi}], {i,            dimi}, {j, dimj}, {k, dimk}]], CompilationTarget -> "C"];          Options[EuclideanDistanceTransform3D] = {Padding -> 1};     EuclideanDistanceTransform3D[im3d_Image3D, OptionsPattern[]] :=        Module[{dist3d, i, j, k, ii, dimi, dimj, dimk},         dist3d =          Developer`ToPackedArray@          ParallelMap[           Round[ImageData[               DistanceTransform[#, DistanceFunction -> EuclideanDistance,                 Padding -> OptionValue[Padding]]]^2] &,            Image3DSlices[            Image3D[ArrayPad[ImageData[im3d, "Bit"], 1,               Padding -> OptionValue[Padding]]]]];        If[OptionValue[Padding] != 0,          dist3d =            Developer`ToPackedArray@            ParallelMap[             If[Times @@ Dimensions[#] == Total[Flatten[#]], # +                 1073741822, #] &, dist3d, {1}];];        dist3d = Developer`ToPackedArray@distcompiled[dist3d];        dist3d = ArrayPad[dist3d, -1];        Image3D[Sqrt@dist3d, "Real"]];      As you can see, I changed the `CompilationTarget` to "C" and added a missing comma after the local variable disttab in the distcompiled function. I then packed the function together and gave it a name:               splitSegmentation3D[img3d_Image3D] :=       Function[{image},         Image3D[Colorize[          MorphologicalComponents[           ImageMultiply[            Binarize[             LaplacianGaussianFilter[              EuclideanDistanceTransform3D[               ColorNegate[                Binarize[                 ImageMultiply[MaxDetect[#], #] &[                  EuclideanDistanceTransform3D[image]], 5]]], 1]],             image]]]]][img3d]      As proposed I set the threshold for accepted maxima to 5 in this function. For binarization I use the proposed `TotalVariationFilter` as pre-processing step and then do a simple `Binarize`. I then do the last of the pipeline using the function `splitSegmentation3D`:               {smallCropped = Image3D[Import["...\\smallExample.tif"],     prepro = TotalVariationFilter[smallCropped],     bin = Binarize[prepro],     comps = splitSegmentation3D[Binarize[prepro]]}      ![enter image description here](http://i.stack.imgur.com/OiQL9.png) The components image looks just like the components image in the answer except for the colors...good. But when taking a closer look at the segmentation by slicing through the images in z-dimension, you see the details. I put the results of the complete image processing chain next to each other (from left to right: original, preprocessed, binary, components image): ![enter image description here](http://i.stack.imgur.com/58wvb.gif) I see multiple problems with this approach. First, using `TotalVariationFilter` as preprocessing step also blurs the image which results in many connected objects. Second, the splitting performs heavy over segmentation resulting in splitted objects. Third, many objects seem to be rounded by the segmentation. I think this results from the `EuclideanDistanceTransform3D` in combination with `ImageMultiply`. I don't think that a perfect segmentation is possible on my data, but it should work out for at least some of the objects.