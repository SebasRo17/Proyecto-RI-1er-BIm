I've just read a lot of arguments against using `Mockito.reset` and can't make much sense of it. Put differently, I agree in general, but there's always a case which looks like using `reset` is useful or even necessary. Grossly simplified, my class under test is an encapsulated map like               class Handler {         private final Map<String, String> map;              public void handle(RequestResponse rr) {             if (rr.isPut()) {                 map.put(rr.key(), rr.value());                 rr.response("OK");             } else {                 rr.response(map.get(rr.key());             }         }     }      To test it, I mock `RequestResponse` and do something like               when(rr.isPut()).thenReturn(true);     when(rr.key()).thenReturn("key");     when(rr.value()).thenReturn("value");     handler.handle(rr);     verify(rr).response("OK");          reset(rr);          when(rr.isPut()).thenReturn(false);     when(rr.key()).thenReturn("key");     handler.handle(rr);     verify(rr).response("value");          reset(rr);          when(rr.isPut()).thenReturn(false);     when(rr.key()).thenReturn("anotherKey");     handler.handle(rr);     verify(rr).response(null);      I can see, I'm testing three things at once:   * proper response after "put"   * proper value returned from get with the same key   * `null` returned from get with another key I can imagine reasons to separate the two last tests. However, they both need the first one and I still need a `reset` in between? Or don't I? ### Update In the meantime the class under test has got a bit more complicated and the need for `reset` bigger. It's sort of a state machine and the test looks like   * repeat the following accross different paths      * try an illegal step and expect an exception     * try another illegal step and expect an exception     * do a legal step and verify output I actually only need two methods, one verifying the exception for an illegal step and the other verifying correct output for a legal step. Executing an illegal step mustn't change the state, so it's safe to mix it in. Consider this example: If the only valid input sequence was `A, B, C` (three steps) and the corresponding outputs were `a, b, c`, then a test looks like               checkException("B")     checkException("C")          checkOutput("A", "a")     checkException("A")     checkException("C")          checkOutput("B", "b")     checkException("A")     checkException("B")          checkOutput("C", "c")     checkException("A")     checkException("B")     checkException("C")      walks through the whole path and verifies everything. It would take many "normal" single-condition-verifying tests to achieve the same, right?