Every so often I run into a situation where I need to map a set of properties from one object to another object of a different, unrelated class. The set of properties is large enough to make typing out the code by hand tedious. Anti- DRY principle code like this is the result:               if (objectOfType1.getPropertyA() != null){objectOfType2.setSimilarlyNamedPropertyA(someMethod(objectOfType1.getPropertyA()));}     if (objectOfType1.getPropertyB() != null){objectOfType2.setSimilarlyNamedPropertyB(someMethod(objectOfType1.getPropertyB()));}     ...skipping some lines...     if (objectOfType1.getPropertyZ() != null){objectOfType2.setSimilarlyNamedPropertyZ(someMethod(objectOfType1.getPropertyZ()));}      Writing and even looking at code like this is a huge pet peeve, but I feel like using an introspection library like BeanUtils to avoid having a couple of methods like this would irritate my coworkers. I've taken to writing one-off scripts to generate code like this for me. How have other programmers addressed this problem? **Edit** : Here's the code translated to use reflection/introspection. Sure it's DRY, but it might make an enemy out of the next programmer on the project, and I can be just as productive generating code like above with a script. That said, if this is more common than I suspect, please fill me in:                   //Is this really a common technique to use when there's a simpler method?         String[] propertyNamePartsArr = {"A","B", ...skipping some parts..., "Z"};         List<String> propertyNameParts = new ArrayList<String> (Arrays.asList(propertyNamePartsArr));              for (String propertyNamePart : propertyNameParts) {             try {                 Object originalValue = BeanUtils.getProperty(objectOfType1, "property" + propertyNamePart);                 if (originalValue != null) {                     BeanUtils.setProperty(objectOfType2, "similarlyNamedProperty" + propertyNamePart, someMethod(originalValue));                 }             } catch (IllegalAccessException e) {                 handleIllegalAccessException(e);             } catch (InvocationTargetException e) {                 handleInvocationTargetException(e);             } catch (NoSuchMethodException e) {                 handleNoSuchMethodException(e);             }         }