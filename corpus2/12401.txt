_[Disclaimer: this question is subjective, but I would prefer getting answers backed by facts and/or reflexions]_ I think everyone knows about the Robustness Principle, usually summed up by Postel's Law: > Be conservative in what you send; be liberal in what you accept. I would agree that for the design of a widespread communication protocol this may make sense (with the goal of allowing easy extension), however I have always thought that its application to HTML / CSS was a total failure, each browser implementing its own silent tweak detection / behavior, making it near impossible to obtain a consistent rendering across multiple browsers. I do notice though that there the RFC of the TCP protocol deems "Silent Failure" acceptable unless otherwise specified... which is an interesting behavior, to say the least. There are other examples of the application of this principle throughout the software trade that regularly pop up because they have bitten developpers, from the top off my head:   * Javascript semi-colon insertion   * C (silent) builtin conversions (which would not be so bad if it did not truncated...) and there are tools to help implement "smart" behavior:   * name matching phonetic algorithms (Double Metaphone)   * string distances algorithms (Levenshtein distance) However I find that this approach, while it may be helpful when dealing with non-technical users or to help users in the process of error recovery, has some drawbacks when applied to the design of library/classes interface:   * it is somewhat subjective whether the algorithm guesses "right", and thus it may go against the Principle of Least Astonishment   * it makes the implementation more difficult, thus more chances to introduce bugs (violation of YAGNI ?)   * it makes the behavior more susceptible to change, as any modification of the "guess" routine may break old programs, nearly excluding refactoring possibilities... from the start! And this is what led me to the following question: When designing an interface (library, class, message), do you lean toward the robustness principle or not ? I myself tend to be quite strict, using extensive input validation on my interfaces, and I was wondering if I was perhaps too strict.