As far as I understand it is a wide-spread opinion within the C++ community that certain features of C++ (including some features inherited directly from C), while still usable in themselves, do not fit well with the most recent C++ _best practices_. For example, I read a comment on this site stating that new / delete should be avoided altogether in favor of smart pointers. In view of this, I often wonder why backward compatibility with C and earlier C++ features is still important: to my knowledge there is no 100% compatibility, but most of C and C++ are contained in C++11 as a subset. So, maybe it would be possible / make sense to drop earlier C++ features (e.g. the mentioned new / delete) from a future C++ standard so that it is impossible to use them in new code. Existing code could still be maintained using the appropriate compiler. Interoperability between legacy and new code would be supported through separate compilation. One could continue to use the earlier standard or adopt the more recent one, only mixing the two would not be possible: a developer /team would have to **clearly choose** which programming style they want to use. The most flexible solution would be to have compiler options to switch on and off certain features (e.g. no new / delete allowed). Would this be a viable strategy for encouraging the adoption of modern C++ practices? Are there technical problems (e.g. compiling existing templates, ABI compatibility) that make such a change too difficult or even impossible? **EDIT** Following the suggestions contained in comments and answers I have shortened and partially reformulated the question. This is **NOT** a C versus C++ question. It is a question regarding C++ best practices and how they can be promoted. **EDIT 2** The number of down-votes suggests to me that the point of the question has not be understood by some. I have changed the formulation to stress the important point even more.