I am creating a flowchart for a program with multiple sequential steps. Every step should be performed if the previous step is succesful. I use a c-based programming language so the lay-out would be something like this: **METHOD 1:**               if(step_one_succeeded())     {         if(step_two_succeeded())         {             if(step_three_succeeded())             {                 //etc. etc.             }            }     }      If my program would have 15+ steps, the resulting code would be terribly unfriendly to read. So I changed my design and implemented a global errorcode that I keep passing by reference, make everything more readable. The resulting code would be something like this: **METHOD 2:**               int _no_error = 0;          step_one(_no_error);     if(_no_error == 0) step_two(_no_error);     if(_no_error == 0) step_three(_no_error);     if(_no_error == 0) step_two(_no_error);      The cyclomatic complexibility stays the same. Now let's say there are N number of steps. And let's assume that checking a condition is 1 clock long and performing a step doesn't take up time. The processing speed of Method1 can be anywhere between 1 and N. The processing speed of Method2 however is always equal to N-1. So Method1 will be faster most of the time. Which brings me to my question, is it bad practice to sacrifice time in order to make the code more readable? And why (not)?