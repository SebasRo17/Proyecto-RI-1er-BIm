Consider the following:               data = {10, 11, 15, 12, 9, 8, 7, 6, 8};          DataAll=StandardDeviation[data];     DataMost=StandardDeviation[Most@data];       DataRest=StandardDeviation[Rest@data];              DataOtherCombinations=           Table[                 Sqrt[                      (StandardDeviation@data[[1 ;; -i]])^2                     +(StandardDeviation@data[[-i + 1 ;; -1]])^2                 ],         {i, 3, 8}]          ListPlot[Join[{DataAll,DataMost,DataRest},DataOtherCombinations], Joined -> True]      The plot shows, that the combination `{{10, 11, 15, 12},{9, 8, 7, 6, 8}}` (`i=6` in `DataOtherCombinations`) has the lowest total standard deviation. (I define the total standard deviation as `Sqrt[StandardDeviation[a]^2+StandardDeviation[b]^2]`). I was hoping to find the same result with `FindClusters` but this is not the case:               In[1455]:= FindClusters[data,DistanceFunction->EuclideanDistance]     Out[1455]= {{10, 11, 15, 12, 9, 8, 7, 6, 8}}      Maybe there is a way of customising `FindClusters` or even better: an approach based on the minimisation of the total standard deviation exists already. By the way: `DataOtherCombinations` does not represent all possible combinations. I'm looking for all subsets of `data` with two restrictions: the order of numbers must not be changed (i.e. the subset must be a sequence of `data`) and the minimum length of one sequence must be greater than or equal to `3`. Hence, another possible combination would be `{{10, 11, 15},{12, 9, 8},{7, 6, 8}}`. (I tried it with `Subsets` but this function seems more to return all permutations of all subsets.)