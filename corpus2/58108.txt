I compiled a function then used it in `NMinimize`. The computation took 19 seconds. Then, I exported this compiled function and restarted MMA and imported this compiled function into my notebook. This time the computation took 30 seconds. Every time I compile the function and use it immediately the computation finishes faster. I use:                Cdiff = Compile[{a, t, mu, b, del}, Evaluate[diff]];(*diff is an expresion not shown here*)            With[{variable = Cdiff},        fun = Compile[{{a, _Real}, {t, _Real}, {mu, _Real}, {b, _Real},     {del, _Real}}, variable[a, t, mu, b, del],          "RuntimeOptions" -> {"EvaluateSymbolically" -> False},          CompilationOptions -> {"InlineCompiledFunctions" -> True},          CompilationTarget -> "C", Parallelization -> True]];          Export["Compiled.wdx",fun]      Does anybody know why this happens? Here is a mini example:                   SetDirectory[NotebookDirectory[]]              function =        Compile[{{x, _Real}}, Sum[Sin[Cos[-x^2*i]], {i, 1, 10^6}],        CompilationTarget -> "C", RuntimeAttributes -> {Listable},        Parallelization -> True]            function[Range[10]]; // AbsoluteTiming       {0.191019, Null}       Export["compiled.wdx", function]      Now restart MMA:                SetDirectory[NotebookDirectory[]]      function = Import["compiled.wdx"]      function[Range[10]]; // AbsoluteTiming          {0.310031, Null}      **Edit** **\-------------------------------------------------------------------------**               function =       Compile[{{x, _Real}}, Sum[Sin[Cos[-x^2*i]], {i, 1, 10^6}],        CompilationTarget -> "C", RuntimeAttributes -> {Listable},        Parallelization -> True]      This function now accepts lists:                function[{1, 0}]      Return:                {-0.2982909888387981, 841470.9848238959}      I have found one way to export this function:                Needs["CCodeGenerator`"]      LibraryGenerate[function, "Myfun"]      Now I load it:                myfunction1 = LibraryFunctionLoad["Myfun", "Myfun", {Real}, Real]      Although now I can export the function there are two problems: 1-It seems that even if you do not compile to c code when you export as mentioned above it compiles to c code because if the function is not compiled to c code after loading it, it gets as fast as a function compiled to c code. 2- The more important issue is that now the function won't accept list as its argument:                myfunction1[{1, 0}]      Returns:               LibraryFunction::cfsa: Argument {1,1} at position 1 should be a machine-size real number. >>