I'm writing a simple chess-related code with intention to write it clearly (performance doesn't matter at all). And this method I have doesn't look clean to me at all:                public static Piece GetClosestPiece(Square squareFrom, Direction direction)         {             //TODO: rework this mess             switch (direction)             {                 case Direction.Top:                     return                         _pieces.Where(p => p.Square.OnVerticalWith(squareFrom))                                .OrderBy(p => p.Square.Y)                                .First(p => p.Square.Y > squareFrom.Y);                 case Direction.Bottom:                     return                         _pieces.Where(p => p.Square.OnVerticalWith(squareFrom))                                .OrderByDescending(p => p.Square.Y)                                .First(p => p.Square.Y < squareFrom.Y);                 case Direction.Right:                 <...>                 case Direction.TopLeft:                     return                         _pieces.Where(p => p.Square.OnBackslashWith(squareFrom))                                .OrderByDescending(p => p.Square.X)                                .First(p => p.Square.X < squareFrom.X);                 default:                     throw new InvalidEnumArgumentException();             }         }      I store the pieces as list, so, here I'm using LINQ to find the piece closest to a given square on a given direction.   1. Do switch/if statements of this size (8 cases total here) always present a code smell?   2. Is there any way to refactor this part only, or should I consider reviewing the design of the whole solution?