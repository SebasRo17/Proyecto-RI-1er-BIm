I'm studying Types and Programming Languages, and have some trouble getting my head around the concepts of the 5th chapter, _The Untyped Lambda Calculus_. Specifically, _redex_ , _reduction_ and the various evaluation strategies are doing my head in. The following is what I understand put into my own words, in an attempt to explain things to myself and get more knowledgeable people to correct my mistakes / imprecisions. I am honestly unsure as to whether this is an acceptable format for stackexchange, and am open to suggestions to make this a better fit. Note that others have tried to answer a very similar question, but have still left me confused:   * Call by value in the lambda calculus   * Untyped lambda calculus: Why is call-by-value strict? ## Redex If my understanding is correct, a _redex_ is a reducible expression, that is, the application of a lambda term to a lambda abstraction. Or, more concretely, a redex is always of the form `(λx.s)t`. ## Redex reduction Reducing `(λx.s)t` is done by replacing all free occurrences of `x` in `s` by `t`. For example:               (λx.x + 2) 1     → 1 + 2     → 3      The process of reducing a lambda expression to its normal form is driven by an evaluation strategy: an algorithm for picking which redex to reduce first. In order to describe these however, we need some more vocabulary. ## Redex qualifications ### Leftmost and rightmost   * the _leftmost redex_ is the one whose abstraction is textually to the left of all other redexes.   * the _rightmost redex_ is the one whose abstraction is textually to the right of all other redexes. So, for example, in `(λx.x + 2) (λy.y + 1)`, we have:   * leftmost redex: `λx.x + 2`   * rightmost redex: `λy.y + 1` There can only be one leftmost and one rightmost redex in a given expression. I'm assuming that in an expression composed of a single redex, that redex is both the leftmost and the rightmost. ### Innermost and outermost   * an _innermost redex_ is one that contains no other redex.   * an _outermost redex_ is one that is contained within no other redex. So, for example, in `(λx.(λy.y + 1) x) 2`, we have:   * innermost: `λy.y + 1`, as it contains no other redex.   * outermost: `λx.[...]`, as it isn't contained in any other redex. I'm assuming that in an expression composed of a single redex, that redex is both outermost and innermost. ## Evaluation strategies Having defined this, we can talk about the two evaluation strategies that I'm struggling with: _call by name_ and _call by value_. ### Call by name In _call by name_ , the leftmost outermost redex is always picked for reduction. Additionally, no reduction can occur within a lambda abstraction. The example given by _Types and Programming Languages_ is:               id (id (λz. id z)) # the leftmost, outermost redex is the very first id     → id (λz. id z)    # the leftmost, outermost redex is still the first id     → λz. id z         # there is no outermost redex remaining, we're done.      I do not understand the need for the definition of the strategy to include _no reduction can occur within a lambda abstraction_ : is that not implied by the fact that only outermost redexes are eligible for reduction? ### Call by value In _call by value_ the rightmost outermost redex is always picked for reduction. The example given by _Types and Programming Languages_ is:               id (id (λz. id z)) # the rightmost, outermost redex is the second id     → id (λz. id z)    # the rightmost, outermost redex is the first id                        # (it's textualy on the left, but there is no redex to its right)     → λz. id z         # the only remaining redex is not outermost (it's contained within                        # an abstraction) and cannot be reduced.