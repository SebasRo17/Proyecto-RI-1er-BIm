I'm trying to solve a coupled ODE system using `NDSolve`. The coupling can turn on and off in some regions, and when the coupling is off, the solution can be written down directly in terms of simple algebraic functions. So I only need to solve the regions when the coupling is on using NDSolve. Then the solutions in different regions are put together to form a `Piecewise` function as a whole solution. This `Piecewise` function now contains several `InterpolationFunction` objects and other simple algebraic functions. Since the `InterpolationFunction` only takes a small part of the whole solution region, I'm trying to compile this `Piecewise` function so that those simple algebraic functions would benefit from compiling. Here is the simplified version of the problem: suppose we have the solution in one region as an interpolation function               s = C1 /.        First@NDSolve[{I C1'[t] == C2[t] E^(-I t),           I C2'[t] == C1[t] E^(I t), C1[0.] == 1., C2[0.] == 0.}, {C1,           C2}, {t, 0., 10.}]     (*       InterpolatingFunction[{{0.,10.}},<>]     *)      and the solution in full region is constructed as               sol[t_] :=       Piecewise[{{s[t], t <= 10.}, {Sin[t], t <= 20.}, {Cos[t], t <= 30}}, 0.]      it can compile without problem, but when executed gives error               f2 = Compile[{{t, _Real}}, Evaluate@sol[t], {{_InterpolationFunction, _Complex}}];     f2[5.]      > CompiledFunction::cfex: Could not complete external evaluation at > instruction 3; proceeding with uncompiled evaluation. >>               (*       -0.787325-0.231525 I     *)      if we compile without `Evaluate`, then there is no error               f1=Compile[{{t,_Real}},sol[t],{{_sol,_Complex}}];     f1[5.]     (*       -0.787325-0.231525 I     *)      but this seems to send the whole `sol` function to the MainEvaluator and thus those simple algebraic functions can't benefit from the compiling. Indeed if we print out the content we can see this difference.               CompilePrint@f1          "             1 argument             1 Real register             1 Complex register             Underflow checking off             Overflow checking off             Integer overflow checking on             RuntimeAttributes -> {}                  R0 = A1             Result = C0          1   C0 = MainEvaluate[ Hold[sol][ R0]]     2   Return     "          CompilePrint@f2          "             1 argument             3 Boolean registers             1 Integer register             9 Real registers             Underflow checking off             Overflow checking off             Integer overflow checking on             RuntimeAttributes -> {}                  R0 = A1             R2 = 7.             R1 = 10.             R4 = 20.             I0 = 30             R7 = 0.             Result = R5          1   B0 = R0 <= R1 (tol R2)     2   if[ !B0] goto 6     3   R3 = MainEvaluate[ Hold[InterpolatingFunction[{{0., 10.}}, <>]][ R0]]     4   R5 = R3     5   goto 20     6   B1 = R0 <= R4 (tol R2)     7   if[ !B1] goto 11     8   R5 = Sin[ R0]     9   R6 = R5     10  goto 19     11  R6 = I0     12  B2 = R0 <= R6 (tol R2)     13  if[ !B2] goto 17     14  R6 = Cos[ R0]     15  R8 = R6     16  goto 18     17  R8 = R7     18  R6 = R8     19  R5 = R6     20  Return     "      So how can I solve this problem? Thanks.