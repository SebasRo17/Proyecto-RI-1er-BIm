In unit tested code I often have multiple checks on the arguments on any method before the actual "work" of the method is begun:               public void DoSomething(string test)     {        if (string.IsNullEmptyOrWhiteSpace(test))        {            throw new ArgumentException("Test must not be empty", "test");        }     }      In my corresponding test for this method I'll do the following:               [Test]     [ExpectedException(typeof(ArgumentException),         Message = "Parameter name: test",         MatchType = MatchType.Contains)]     public void TestNullInput()     {         var classToTest = new ClassToTest();         classToTest.DoSomething(null);     }      I'm thinking that this is quite a bad way to go about doing the test, however, as it relies on a specific named parameter (which does not necessarily hold true after any refactoring), as well as the format of the message of an ArgumentException. Another option might be to create a custom exception for this, some form of "TestWasNullOrEmptyException", but this also seems fairly awkward, as there will be many many different exceptions throughout the solution, each used to indicate only the absence/invalidity of a parameter. I am wondering if anyone else has dealt with this issue, and whether I'm simply going about my input validation tests the wrong way of it there's a more elegant solution. EDIT: This is C# code, and I'm using NUnit/Rhino Mocks.