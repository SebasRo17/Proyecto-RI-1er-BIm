I have an interpolated function that looks like this: $\hskip1.2in$![enter image description here](http://i.stack.imgur.com/iRxEx.png) and, based on extreme and critical points, I want to use a polynomial to approximate the function. The points in question are:               pts = {{-0.405234, 1.67277}, {-0.163136, -0.261272}, {0.0847028, -0.183542},         {0.483178, -0.408663}, {0.590177, 1.67277}};      $\hskip1.2in$![enter image description here](http://i.stack.imgur.com/wB56T.png) I know I could use `Fit` to get a polynomial with the desired order, but not every polynomial is acceptable. In order to preserve the qualitative nature of the curve, the polynomial must be _at least_ of order $n=4$, and a requirement is that the polynomial respects the _minima_ of the original curve. Based on that, I did the following: Let $P_4(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + a_4 x^4$. Then I constructed the function (sorry for the lousy programming)               p4[ls_] := Function[x, Module[{a, c4},        a = Flatten@({a0, a1, a2, a3} /.        Solve[Flatten@{(a0 + a1 #1 + a2 #1^2 + a3 #1^3 + a4 #1^4 - #2 == 0) & @@@ #,          (a1 + 2 a2 #1 + 3 a3 #1^2 + 4 a4 #1^3 == 0) & @@@ #} &@ls[[{2, 4}]],          {a0, a1, a2, a3}]);       c4 = a4 /.        (FindMinimum[         Abs[a[[1]] + a[[2]] #1 + a[[3]] #1^2 + a[[4]] #1^3 + a4 #1^4 - #2] & @@ ls[[1]] +         Abs[a[[1]] + a[[2]] #1 + a[[3]] #1^2 + a[[4]] #1^3 + a4 #1^4 - #2] & @@ ls[[3]] +         Abs[a[[1]] + a[[2]] #1 + a[[3]] #1^2 + a[[4]] #1^3 + a4 #1^4 - #2] & @@ ls[[5]],         {a4, 0}])[[2]];       (a[[1]] + a[[2]] x + a[[3]] x^2 + a[[4]] x^3 + a4 x^4) /. {a4 -> c4}       ]];      This function basically finds the coefficients $a_0, ...,a_3$ of the polynomial by imposing it to pass trough the two minima and ensuring that they are indeed minimia (fortunately I didn't had to impose $a_4 > 0$), and determines $a_4$ as the constant that minimizes the function $$|P_4(x_1) - y_1| + |P_4(x_3) - y_3| + |P_4(x_5) - y_5|$$ The result is good but not that good: $\hskip1.2in$![enter image description here](http://i.stack.imgur.com/wwLy7.png) So, I try with $P_6(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + a_4 x^4 + a_5 x^5 + a_6 x^6$ (againg, sorry for the ugly programing):               p6[ls_] := Function[x, Module[{a, c6},        a = Flatten@({a0, a1, a2, a3, a4, a5} /.       Solve[Flatten@{(a0 + a1 #1 + a2 #1^2 + a3 #1^3 + a4 #1^4          + a5 #1^5 + a6 #1^6 - #2 == 0) & @@@ #,         (a1 + 2 a2 #1 + 3 a3 #1^2 + 4 a4 #1^3 + 5 a5 #1^4 + 6 a6 #1^5 == 0) & @@@ #}         &@ ls[[2 ;; 4]], {a0, a1, a2, a3, a4, a5}]);       c6 = a6 /. (Quiet@FindMinimum[          Abs[a[[1]] + a[[2]] #1 + a[[3]] #1^2 + a[[4]] #1^3 + a[[5]] #1^4 +           a[[6]] #1^5 + a6 #1^6 - #2] & @@ls[[1]] +           Abs[a[[1]] + a[[2]] #1 + a[[3]] #1^2 + a[[4]] #1^3 + a[[5]] #1^4 +           a[[6]] #1^5 + a6 #1^6 - #2] & @@ls[[3]] +           Abs[a[[1]] + a[[2]] #1 + a[[3]] #1^2 + a[[4]] #1^3 + a[[5]] #1^4 +           a[[6]] #1^5 + a6 #1^6 - #2] & @@ls[[5]], {a6, 0}])[[2]];       (a[[1]] + a[[2]] x + a[[3]] x^2 + a[[4]] x^3 + a[[5]] x^4 + a[[6]] x^5 + a6 x^6) /.          {a6 -> c6}     ]];      Again I force the minima, but I add a third condition on the coeficients, that there must be a minima in $x_3$. This works like a charm for `pts`: $\hskip1.2in$![enter image description here](http://i.stack.imgur.com/wWvNW.png) I should be very happy but, if I change the definition for `pts`               pts = {{-0.419826, 1.67277}, {-0.292539, -0.296446}, {0.00452181, -0.162576},        {0.6037, -0.534627}, {0.735329, 1.67277}}      I end up with $\hskip1.2in$![enter image description here](http://i.stack.imgur.com/vuHRr.png) which is terrible (qualitatively speaking that is)! **The solution** is (kinda?) obvious, I need to impose the constraint $$2 a_2 + 6 a_3 x + 12 a_4 x^2 + 20 a_5 x^3 + 30 a_6 x^4 \le 0 \quad x \in (x_2 + \delta_1,x_4 - \delta_2) \tag{C}$$ (where $\delta_{1,2}$ can be fixed to ensure smoothness) but I have been unable to work with the interval. I've tried defining a function by pieces and apply it to $a_6$ in the constraint section of `FindRoot`, use `HeavisidePi`, etc, without success so, **my quiestion is: how to include the constraint (C) in`FindRoot`?** For reference, here is a (coarse) table to generate the original interpolated function for the first and second case:               case1 = {{-0.405234, 1.67277}, {-0.305234, 0.264728}, {-0.205234, -0.2388},        {-0.105234, -0.242507}, {-0.00523355, -0.197663}, {0.0947664, -0.183713},        {0.194766,-0.203222}, {0.294766, -0.252936}, {0.394766, -0.334333},        {0.494766, -0.404536}};          case2 = {{-0.419826, 1.67277}, {-0.319826, -0.275709}, {-0.219826, -0.248922},        {-0.119826, -0.185553}, {-0.0198259, -0.163342}, {0.0801741, -0.169325},        {0.180174, -0.197047}, {0.280174, -0.244685}, {0.380174, -0.313329},        {0.480174, -0.41021}, {0.580174, -0.524263}, {0.680174, -0.190625}};      Thanks for the attention.