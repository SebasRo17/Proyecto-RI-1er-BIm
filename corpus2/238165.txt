This is about the third time I've had to write software to control a cellular modem. For those unfamiliar with the process, you have a sequence of steps you have to take. Each step takes a certain amount of time, and there's a few responses you should receive in that amount of time. There are also some responses you can receive at any time, regardless of the step you are on. Based on the response you have to go to another stage in the process. If it times out, you have to go to a different stage. In some cases, steps are attempted multiple times before going to another stage. These have to be non-blocking functions, which I can run as a task on a single threaded machine. So the main program would be calling this `modemTask()` a few hundred times a second, it checks whether it needs to do something, then performs a function if needed, and exits. In the past I've written this as a simple `switch` based state machine, with enumerated stages, somewhat like the following:               switch(stage){        case Power:           powerOn();                 // Turn the modem on           nextstage = ResetCmd;      // Go perform a reset           attemptsLeft = 5;          // Send the reset command up to five times           break;        case ResetCmd;           modem.write("ATZ\n");      // ATZ - reset           attemptsLeft--;            // Use one of our attempts           nextstage = ResetReply;    // Next wait for a response (should be OK)           timeout = millis() + 5000; // Wait for up to 5 seconds each attempt           break;        case ResetReply;           if(receivedResponse() == OK)     // Success           {              nextStage = NetworkAttachCmd; // Attach to the cellular network           } elseif(receivedResponse() == ERROR || timeout < millis())           {        // If we get an error or timeout, reattempt if we can, power on if we can't              if(attemptsLeft > 0)              {                 nextStage = ResetCmd;              } else {                 nextStage = Power;              }           }            break;        case NetworkAttachCmd:        ...     }     stage = nextstage;               // Assign stage indirectly for debug purposes - nice to know where we came from at this point      It's difficult to keep track of the whole flow of the system, inserting an additional step requires changes to the steps before and after, and it just seems like there should be an easier way. The largest one I've had to design had fewer than 60 stages, so it's not unmanageable, but I can't help but think that there's a better strategy or pattern for this type of work. While I use a few `#define` for most timeouts and attempts, it would be a bit nicer if this weren't embedded in the state machine. Perhaps a structure of some sort could be made to hold each state, but since the responses vary it seems just as complicated. Most steps will have a simple "OK" but some contain status and data that have to be acted on, where the stage will change based on the exact response.