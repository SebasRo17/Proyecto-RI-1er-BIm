Consider the following toy problem:               Q = 10^9;     A = Table[RandomInteger[10], {Q}];     Developer`PackedArrayQ@A     B = Map[N[Sin[#]] &, A]; // AbsoluteTiming     Developer`PackedArrayQ@B     MemoryInUse[]     MaxMemoryUsed[]          True     {105.901936, Null}     True     16022521160     24022519456      But using ParallelMap even with custom memberQ gives the following:               Q = 10^9;     A = Table[RandomInteger[10], {Q}];     Developer`PackedArrayQ@A     withModifiedMemberQ[expr_] :=        Module[{doneQ, unmatchable},         Internal`InheritedBlock[{MemberQ}, Unprotect[MemberQ];         (*Can uncomment this if we want to print out the MemberQ calls:mq:         MemberQ[args___]/;(Print@HoldForm[mq];True):=mq;*)         MemberQ[list_, patt_Symbol, args___] /; ! TrueQ[doneQ] :=           Block[{doneQ = True},            MemberQ[Unevaluated[              list] /. _List?Developer`PackedArrayQ -> {unmatchable},             Unevaluated[patt], args]];         Protect[MemberQ];         expr]];     SetAttributes[withModifiedMemberQ, HoldAllComplete];     B = withModifiedMemberQ@         ParallelMap[N[Sin[#]] &, A]; // AbsoluteTiming     Developer`PackedArrayQ@B     MemoryInUse[]     MaxMemoryUsed[]          True     {533.782398, Null}     True     24027869336     48030873944      We see: 5x drop in performance, 2x increase in max memory usage. Why is it happening? How can it be avoided, while keeping the computation parallelized? Edit: the code of the real life example can be found here. Same problems observed.