Lets focus on a domain object that is related to **more** other (different!) entities. Sometimes we need one relation and sometimes the other. Let's be agile and say: we don't know in a front how many other relations there will be. In other words: we have object **A** that is related one-to-one to **B** and one-to-many to **C** and again one-to-one to **D** and so on. Now, when developing the presentation tier, it often needs a lot of data to display; like table of **A** with **B** , or on other place one **A** with many **C** and so on. How we gonna model these relationships? Here is an example: `Competition`. Sometimes it comes and needs to be used with e.g. `Venue`. Sometimes with e.g. `List<Event>`. Since you care about performances, let's also say that the related objects (`Venue` and list of `Event`s) come from the single input/repository method/finder method/one SQL join (however you call it) - and that they can be _injected_ into `Competition` using some mapping tool. This way we express the actual relationship between the entities. Question: should we keep both relations/references in the `Competition` class and ignore the other when one is used, or we should make many separate classes - one for each relation? (It doesn't matter if it is 1-1 relation or 1-many, the question is the same.) In other words, should we have: **[A]** Everything in the single class. Getter methods do represents relationships. It's on us to fill the object if relation is needed.               class Competition {         ... competition data...              private Venue venue;         public Venue getVenue() {             return venue;         }              private List<Event> events;         public List<Event> getEvents() {             return events;         }     }      But then, when your application method return a `Competition` you don't know what relations are populated and you have to figure that out by looking the application methods code or by method name (e.g. `findCompetitionWithEvents...()`). **[B]** For each relationship we have a type or interface. One way to do so, without interfaces for the simplicity of this example, is:               class CompetitionVenue extends Competition {         private Venue venue;         public Venue getVenue() {             return venue;         }     }      and               class CompetitionEvents extends Competition {         private List<Event> events;         public List<Event> getEvents() {             return events;         }     }      Now the type speaks by itself what relationship is returned and therefore application method that returns it guarantees that relation exists. But then each relationship would have its own class or interface; EDIT: **[C]** Each relationship is represented using a generic class like `Tuple<Competition, List<Event>>` and `Competition` does not have the getter for list of events?