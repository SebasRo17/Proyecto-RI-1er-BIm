Scenario:   * One data input feed (call this `Source`)   * Multiple objects (call these `Layer1`) **read** this `Source`, and analyze the feed. This analysis is stateful.   * `Layer1` objects have configuration parameters. For example, `new FooLayer1(10, 20)` will do different analysis than `new FooLayer1(20, 20)` will do different analysis than `new FooLayer1(20, 30)`     * The `Layer1` analysis is done asynchronously.   * Still other objects (call these `Layer2`) **readonly** the output of the `Layer1` objects and process those results. This analysis is also stateful.   * Guice object creation hierarchy   * Needed `Layer1` objects are accessed often enough that it doesn't matter if they are created lazily, as long as they remain in memory after they're created the first time.   * The needs of `Layer2` objects are hardcoded; no good way to know in advance which `Layer1` objects will be needed. I want to be able to reuse the work of the `Layer1` objects. For example, lets say I have:   * `AlphaLayer2` object that reads the output of `FooLayer1` and `BarLayer1`   * `BetaLayer2` reads the output of `BarLayer1` and `BazLayer1`   * `QuuxLayer1` is implemented, but I don't want my server to compute the value of `QuuxLayer1` unless there is a `Layer2` object that needs it. Currently, I have a factory that all `Layer2` objects have access to, that only creates the appropriate `Layer1` object as needed, and stores all created `Layer1` objects in a Map. But, since `Layer1` objects also have configuration parameters, I need to make sure that I'm storing the `Layer1` objects in a good data structure. But the `Layer1` functionality needs to be flexible, and I figure as I create more kinds of `Layer1` objects, this kind of a `Map` could get really complicated. I am asking this question because, while it's fine now, as the complexity grows, maintaining the data structure in this way seems to become really difficult. Trying to do some sort of nested `Map` data structure should get me `O(1)` access times on finding these `Layer1` objects, but will make the caching super complicated. Alternatively, I could keep them in a much flatter structure, and iterate over the list of all the `Layer1` objects and see if they have the right parameters. If none found, create the new one. As long as `Layer2` objects keep the reference, this should only happen once. Yet another option would be to create a `Map<Class, Set<Layer1>>` so that it only needs to iterate through the created `Layer1` objects of the correct class. Has anyone seen this kind of scenario before? Which of the options I've mentioned is preferred? Or, is there something I haven't mentioned yet? Also, is there any way to use Guice to create `Layer1` objects in a way where I can get reuse them (which I need to do, because they're stateful)