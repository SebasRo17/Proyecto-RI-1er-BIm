I have an $w\times h$ array with non-negative integers. I wish to partition the set of coordinates $(c,r)$ with $1\leq c \leq w$ and $1\leq r \leq h$, in subsets, so that each subset corresponds to a cluster of the same value in the array. Two coordinates are neighbouring if they either are on top of another, or one is down-left of the other. This corresponds to finding clusters in a parallelogram. belisarius was nice to provide a picture: ![enter image description here](http://i.stack.imgur.com/kJEhK.png) I have some code to find one connected cluster in an array (I call it gt):               FloodFillExtractTile[gt_, {sr_, sc_}] :=       Module[{r, c, toExplore, visited = {}},       toExplore = {{sr, sc}};       While[Length@toExplore > 0,        (* Pop *)        {r, c} = Last@toExplore;        toExplore = Most[toExplore];        AppendTo[visited, {r, c}];        (* Down-left *)             If[c > 1 && r < h &&           gt[[r + 1, c - 1]] == gt[[r, c]] && !            MemberQ[visited, {r + 1, c - 1}],         AppendTo[toExplore, {r + 1, c - 1}];         ];        (* Down-right *)             If[ r < h &&           gt[[r + 1, c]] == gt[[r, c]] && ! MemberQ[visited, {r + 1, c}],         AppendTo[toExplore, {r + 1, c}];         ];        (* Up-right *)             If[r > 1 && c < w &&           gt[[r - 1, c + 1]] == gt[[r, c]] && !            MemberQ[visited, {r - 1, c + 1}],         AppendTo[toExplore, {r - 1, c + 1}];         ];        (* Up-left *)             If[ r > 1 &&           gt[[r - 1, c]] == gt[[r, c]] && ! MemberQ[visited, {r - 1, c}],         AppendTo[toExplore, {r - 1, c}];         ];        ];       Return@visited;     ];      Then `FloodFillExtractTile[gtp, {1, 1}]` gives the component connected to the upper left hand corner. However, this method feels ugly, and extending it to all components feels even uglier. I was looking at `Gather`, but the problem is that it wants _all_ points in a cluster to be _equal_ , see for example Gather dependency on list order? Edit: So this is the type of arrays I am looking at. The 6, the 3's, the 2's and the 0's are in one component respectively, but there are two components with 1's. Being neighbours means being adjacent down-left, down-right, up-left and up-right. Now, the rows is stored just like regular rows in a rectangular matrix, so that is why this translates to a bit strange criteria for being neighbours. ![GT-pattern](http://i.stack.imgur.com/LrdCQ.png) This is the best code I have so far, first extract points with the same value, then do connected-component analysis on those parts.               GetGTTiles[gtp_] :=        Module[{testSame, testEdge, h, w, pts, sameClusters, getEdges,          tiles},        {h, w} = Dimensions[gtp];        pts = Join @@ Table[{r, c}, {r, h}, {c, w}];        testSame[{r1_, c1_}, {r2_, c2_}] := (gtp[[r1, c1]] ==            gtp[[r2, c2]]);        testEdge[{r1_, c1_}, {r2_,            c2_}] := (gtp[[r1, c1]] ==             gtp[[r2, c2]]) &&          ((c1 == c2 &&               Abs[r1 - r2] <= 1) || (c1 == c2 - 1 &&               r1 == r2 + 1) || (c1 == c2 + 1 && r1 == r2 - 1));        sameClusters = Gather[pts, testSame];        getEdges[clust_] :=          Join @@ Outer[If[testEdge[#1, #2], #1 -> #2, Sequence @@ {}] &,            clust, clust, 1];        tiles =          Join @@ (ConnectedComponents[Graph@getEdges[#]] & /@ sameClusters);        Return@tiles;        ];      This is the output I expect for the example given (5 clusters found):               {{{1, 1}}, {{1, 2}, {2, 1}},      {{1, 3}, {2, 3}, {3, 2}, {4, 1}, {3, 1}, {2, 2}},      {{1, 4}},      {{2, 4}, {3, 4}, {4, 4}, {5, 4}, {5, 3}, {4,3}},      {{3, 3}, {4, 2}, {5, 2}, {5, 1}}}      EDIT: So this is the final code, based on belisarius solution:               GTTiles[gtp_List] := Module[{fromEuclidean, toEuclidean,         getOneTile, elements, elmPos, pts, tile, tiles},             (* This is used to changefrom different coordinate systems. *)             fromEuclidean[{r_, c_}] := {r, (c - r)/2 + 1};        toEuclidean[{r_, c_}] := {r, 2 c + r - 2};             getOneTile[pts_List, maxDist_?NumericQ] := Module[{f},          f = Nearest[pts];          FixedPoint[           Union@Flatten[f[#, {Infinity, maxDist}] & /@ #, 1] &, {First@             pts}]];             elements = Union @@ gtp;        elmPos = (toEuclidean /@ Position[gtp, #]) & /@ elements;        (* This is really strange code. *)        tiles = Flatten[Flatten[             Reap[NestWhile[Complement[#,                  Sow@getOneTile[#, N@Sqrt@2]] &, #, # != {} &]][[2]],              1] & /@ elmPos, 1];        tiles = Map[fromEuclidean, tiles, {2}];        Return@tiles;        ];