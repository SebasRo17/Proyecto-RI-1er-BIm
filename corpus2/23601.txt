Laplace's Equation is an equation on a scalar in which, given the value of the scalar on the boundaries (the boundary conditions), one can determine the value of the scalar at any point in the region within the boundaries. Initially, I considered using `NDSolve`, but I realized that I did not know how to specify the boundary conditions properly. In the example below, my boundary is a square with value 0 along the top, left and right boundary and 1 along the bottom boundary. Alternatively, the solutions to the equation can be approximated via the Method of Relaxation. In the method, the region is divided into a grid, with the grid squares along the boundary being assigned (fixed) boundary conditions, and the value for the grid squares within the boundary being iteratively calculated by assigning the average values (in the previous time- step) of four grid squares adjacent to it. My current code is as follows               localmeaner =        Mean@{#1[[#2 - 1, #3]], #1[[#2 + 1, #3]], #1[[#2, #3 - 1]], #1[[#2, #3 + 1]]} &;          relaxer = ({#[[1]]}~Join~          Table[           {#[[j, 1]]}~Join~            Table[localmeaner[#, j, i], {i, 2, Dimensions[#][[2]] - 1} ]~            Join~{#[[j, Dimensions[#][[2]]]]}, {j, 2,             Dimensions[#][[1]] - 1}]~Join~{#[[Dimensions[#][[1]]]]}) &;          matrixold = Append[ConstantArray[0, {41, 40}], ConstantArray[1, 40]]; (*test matrix fixing the boundary conditions as 0 on the top, left and right boundaries and 1 on the bottom boundary*)          tempmatrix = Nest[relaxer, matrixold, 300]; (*matrix after 300 relaxations*)      `localmeaner` is a function that takes the average of the four grid squares adjacent to a square. `relaxer` is a function that preserves the boundary values but otherwise applies `localmeaner` onto each of the grid cells to produce their new values based on the average of the four grid cells adjacent to it. > Is there a quicker way to find a numerical solution to the Laplace's > Equation given specific boundary conditions? As a point of interest, one can plot the solution as `ArrayPlot[tempmatrix*1., ColorFunction -> "Rainbow"]`, resulting in the following image, which helps one to visualize the results. ![enter image description here](http://i.stack.imgur.com/uji7W.png) NB: I'm planning to extend this solution to approximations that can work in polar coordinates, Cartesian coordinates in three dimensions and spherical coordinates, so I'm hoping that the answers could be equally general.