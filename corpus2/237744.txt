I'm working on some inherited code in C++ and am trying to use 2 classes with templates as I need 2-types of each class to operate on floating point or integer data (double v uint64_t to be exact). In the two classes that I'm trying to "templatize"(?), one inherits from the other. Data definitions needed for both are defined in the 'more base' class, some with the parameterized typename 'T', and some with resolved types (e.g. 'int') in the 'protected:' section. The corresponding implementation (.cc) file for the more base class compiles 'ok', but the implementation file for the derived class (which is also 'templated') isn't seeing the the class data from the 1st template. I thinking that the derived class file wants to see a resolved version of the more base class's template definition, but am not sure. Example: more base class template file (.h) has:               template < typename T > class FieldMeter : public Meter {     ...     protected:         int numfields_;         F *fields_;         F total_, used_, lastused_;     ...     };      'less base' class (.h) file:               template <typename T> class FieldMeterGraph : public FieldMeter <T> {         ...     }      Problem comes in less-base class .cc file when accessing 'numfields_' or 'fields_':               fieldmetergraph.cc:51:24: error: ‘numfields_’ was not declared in this scope       if (!heightfield_  && numfields_>0 && graphNumCols_ >0)      When both were simple classes, I didn't get the above, so it's a case where data being declared in the more base, 'templatized' class isn't accessible in the implementation of a derived template. My terminology may be a bit off -- but it seems like this should be doable -- with "end classes" like "`cpumeter`" that would pass a solid data type (`uint64_t`) to the toplevel `FieldMeterGraph` template. I'm tempted to resort to storing the type at compile time, and doing the resolution manually, at run-time like I would in 'C', but as I understand it, this should be resolvable by the compiler (g++ using C++11), at compile time. I do have Stroustrup's 4th tomb as reference, but it seems his examples are tending toward being a bit too generic for me to correctly derive a resolvable, concrete example that g++ likes (though g++'s error messages do seem to be extraordinarily more helpful and precise compared to what I normally get in perl..).... If someone knows how to more quickly resolve my conundrum, than my randomly trying various things that don't work, it would be appreciated! ;-) Thanks!