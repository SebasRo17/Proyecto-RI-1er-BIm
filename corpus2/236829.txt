In my problem I had lots of objects with slightly different behaviour, but identical attributes and methodes with identical interfaces. The objects variants were quite big in number, and I didn't want to create a class for each of them, with lots of repeting code. I circumvented creating a lot of derived classed by the following construct (pseudocode for abbrevation)               #aTP = all the parameters     def _function_version_1(aTP):         ...          ...          def _function_version_BIG(aTP):         ...          class BaseClass(object):         _typesOfImplementation = {'ONE' : _function_version_1,                                    ...                                   'BIG' : _function_version_BIG,                                  }              def __init__(self, type, ...)             ...             if type not in _typesOfImplementation:                 raise Exception('Unknown type')             # respective function for this object             self.function = lambda aTP:BaseClass._typesOfImplementation[type](self, aTP)      Is this still an implementation of the strategy pattern, although I didn't use classes for the respective function version (which would have been an awful bunch of classes again)?