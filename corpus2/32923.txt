Imagine two lists of two-dimensional coordinates:               listA = RandomReal[{0,100},{202,2}];     listB = RandomReal[{0,100},{97,2}];      I'm attempting to quickly generate a new series of lists, `outputListA` and `outputListB` consisting of the indices for the set of points in `listA` and `listB`, respectively, that are within some Euclidean distance $D$ of a point in a list for which they are not a member (i.e. points in `listA` that are at most a distance `distCut` from at least one point in `listB` and vice versa). This isn't the right way to do things (it takes $\approx 88$ milliseconds for sizes of `listA` and `listB` shown), but it hopefully illustrates what I'm trying to do:               listA = RandomReal[{0, 100}, {202, 2}];     listB = RandomReal[{0, 100}, {97, 2}];          outputList = {};     distCut = 1;          For[x = 1, x <= Length[listA], x++,      For[y = 1, y <= Length[listB], y++,        If[EuclideanDistance[listA[[x]], listB[[y]]] <= distCut,          outputList = Append[outputList, {x, y}];          ];        ];      ];          outputListA = Intersection[outputList[[All, 1]], outputList[[All, 1]]];     outputListB = Intersection[outputList[[All, 2]], outputList[[All, 2]]];          Length[outputListA]     Length[outputListB]      A smarter way to proceed might be to round values in `listA` and `listB` to a multiple of `distCut`, and then check for values in the rounded lists that are equal. However, I can't think of a good way to do this that avoids unnecessary attrition / misses points. A thought - Can we repeatedly apply `Nearest` for each point $p_i$ in `listA` until we find a point that is more than a distance `distCut` from $p_i$? Is `Nearest` doing anything more sophisticated than sequentially scanning through all of the points in a comparison list and checking Euclidean distances? Update - I've specified now that `outputListA` and `outputListB` should consist of the indices of the points in `listA` and `listB` satisfying the distance cutoff criterion.