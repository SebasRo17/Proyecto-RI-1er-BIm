I'm trying to numerically integrate a function which has a vector-valued slow part and a much faster component which is shared by all the components, i.e. an integral of the form $$ \int_a^b\begin{pmatrix}f(x)\\\ g(x) \\\ h(x)\end{pmatrix}w(x)\,\text dx. $$ Because `NIntegrate` is nicely Listable on its first argument, I can feed it a list-valued argument without a problem. However, it appears to be doing each component as a completely separate integral, which results in a lot of work being re-calculated. For example, the (simplified) example integral               samplePointsList = Reap[         NIntegrate[          {x, x^2, x^3} Cos[10 x + Cos[x]]          , {x, 0, 5}          , EvaluationMonitor :> Sow[x]          ]         ][[2, 1]];      gives the sample point diagram (through `ListPlot[Transpose[{samplePointsList, Range[Length[samplePointsList]]}]]`) ![enter image description here](http://i.stack.imgur.com/FuIiD.png) It is clear that the kernel is doing the initial sampling, and then the further refinements, separately for each component. While the required sample points are not identical, there is a lot of shared work and I feel there is a fair bit of room for optimization there. I am aware that, since the sampling requirements of each component are slightly different, binding them completely will require more evaluations in some components than would be necessary. (For instance, in the example above, the extra detail required by the first component around $2\leq x\leq 3$ would be slowed down slightly if it was required to also calculate the second and third components there, though they do not require it.) However, the components in my case are similar enough that I do not think this would be an issue. Is there a way to force Mathematica into this sort of separation of the integrand and unification of the sampling? If not, is there a way to make it aware of the previously calculated values and sampling points which will speed up the process?