I'm playing around a bit with my own C like DSL grammar and would like some oppinions. I've reserved the use of "(...)" for invocations. eg:               foo(1,2);      My grammar supports "trailing closures" , pretty much like Ruby's blocks that can be passed as the last argument of an invocation. Currently my grammar support trailing closures like this:               foo(1,2)     {        //parameterless closure passed as the last argument to foo     }      or               foo(1,2) [x]     {         //closure with one argument (x) passed as the last argument to foo         print (x);     }      The reason why I use [args] instead of (args) is that (args) is ambigious:               foo(1,2) (x)     {     }      There is no way in this case to tell if foo expects 3 arguments (int,int,closure(x)) or if foo expects 2 arguments and returns a closure with one argument(int,int) -> closure(x) So thats pretty much the reason why I use [] as for now. I could change this to something like:               foo(1,2) : (x)     {     }      or               foo(1,2) (x) ->     {     }      So the actual question is, what do you think looks best? [...] is somewhat wrist unfriendly.               let x = [a,b]      {     }      Ideas?