In order to avoid the overhead associated with the shelve module's `writeback` option I'm interested in putting together a shelf class that only accepts hashable values, with hashability being a proxy for immutability. So I'd like to subclass `shelve.Shelf` and override the `__set__` method. The catch is that `shelve.open` can return one of a number of different classes (e.g., `Dbfilenameshelf`), and I'd like my code to allow `shelve` this flexibility. Ideally a solution would have the following properties:   1. No need to wrap every function that `Shelf` provides, as in: `def keys(self): return self._shelf.keys()`   2. Will not break if Python adds new methods to `Shelf` or new subclasses of `Shelf`   3. Avoiding fragility, by which I mean doing something complicated that could easily trip up someone (conceivably me) who is modifying or using the code months or years down the road. An example in this context would be reassigning `Shelf.__set__`, as in `Shelf.__set__ = my_func`. To me defining a new `__getattr__` as @Winston hesitantly offers seems moderately fragile--I take it that's why he suggests it only with hesitation Less important but still desirable would be:   1. Consistent with object-oriented design principles. It seems to me that the new class here _is a_ shelf, not that it _has a_ shelf. And probably not both (it's not a shelf which contains another shelf)