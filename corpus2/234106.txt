Consider the following situation: One hardware device, two applications (1 C# application, 1 Firmware). The C# application sends frames to the firmware and the firmware executes scripts.   * C# -> transmit frame[x]    * FW -> receive frame[x]    * FW -> execute script relating to frame[x]    * FW -> before finished, a FW event is triggered forcing moving parts to stop (safety precaution). C# requirement after such events are raised:   * Poll FW for status, if status == stopped, send a resume fame.   * Caveat: the C# logic therefore needs to adjust itself to being "restarted". ### So this is the situation I have; but what I'm seeking advice with is how I should design a class which can handle the pausing and restarting of tasks an unlimited number of times. While I can write convoluted methods which are hard to maintain through a chain of logical statements, I'm struggling with finding a design which is reusable and clean. Such scenarios are true for ~50 unique tasks, so finding a solution I can apply everytime would save a lot of headache. Anytime a script is restarted or resumed, a physical user can easily cause a safety trigger stop, therefore a solution needs to be robust. While I'm sure recursion would be a first good step, I'm worried that the stack limits has the potential to introduce errors. ### Clarification: In my bid to simplify things, I seem to have omitted too much. Apologies. **Firmware:** Software running on a physical device which controls the hardware. I have no control over this code-base and it was designed independently while allowing USB communication. **Synchronization:** There is very little or no synchronization between the C# application and the firmware. My C# code will send a frame of bytes which match up to a specification document for the firmware, and if the frame is valid, the firmware will reply saying it received the frame and will begin the work. After that, there is no direct synchronization. A task described by a frame typically has two attributes: the time it takes to execute (need to manually observe) and an end target status (complete with status identifiers). Currently I poll the firmware for the status until the target status is reached or until time-out. **Recursion:** What I meant by that was (`if not complete` -> `callSelfAgain()`) **Pause:** User has done something to the device, wait here until they fix (can happen at ANY time during the time the firmware is running its jobs). **Restart:** The user has amended the state, now start the job from the beginning (or where we left off [task dependent]).