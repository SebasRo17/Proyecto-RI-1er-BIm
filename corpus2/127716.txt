I am having a confusion in this Binary Tree Coding. I know the concept of binary tree and I know how those work and all, but in this source code i am confused with "Find" operation. I cannot understand how it works and all. Please help me, I am so interested in this area.               package binarytree_task4;                 class Node          {              private static class Equivalent {                  public Equivalent() {             }         }                  public Equivalent data;              public Node right;              public Node left;                   public Node(Equivalent data)              {                      this(data, null, null);             }                  public Node(Equivalent data, Node left, Node right)              {                      this.data = data;                 this.left = left;                 this.right = right;             }            }                class binarytree {                   public static void main(String[] args) {              }              private static class Equivalent {                  public Equivalent() {             }         }              private static class present {                  public present() {             }         }         private Node root;          private int size;              public binarytree()          {             size = 0;             root = null;         }                   public void printTree()          {             if(size == 0)                 System.out.println("Empty");             else {                 System.out.println("Tree contents:");                    inorder(root);             }         }                   public void inorder(Node present)         {             if(present != null)              {                 inorder(present.left);                 System.out.println(present.data);                 inorder(present.right);             }         }                public void Insert(Equivalent data)          {             root = Insert(data, root);         }                   private Node Insert(Equivalent data, Node present)          {             if( present == null)              {                 size++;                  present = new Node(data, null, null);              }                  else if(data.compareTo(present.data)<0)             {                 present.left = Insert(data,present.left);                     }                  else if(data.compareTo(present.data)>0)                     {                       present.right = Insert(data, present.right);             }                  return present;         }                          public boolean Find(Equivalent data)          {             return Find(data, root);             }                   private boolean Find(Equivalent data, Node present)          {                  if(present == null )              {                 return false;             }             else if(present.data == data)             {                 return true;                 }             else if(data.compareTo(present.data)<0)               {                 return Find(data, present.left);              }             else              {                 return Find(data, present.right);              }         }                        public boolean Delete(Equivalent key){                  if (Find(key)){                 Delete(key);                 return true;             }             else{                 return false;             }         }              public void delete(Equivalent key)          {              Node present = root;             Node parent = root;                  boolean isLeftChild = true;                       while(present.data.compareTo(key) != 0)                     {                      parent = present;                 if(present.data.compareTo(key) > 0)                       {                     isLeftChild = true;                      present = present.left;                  }                 else                                             {                     isLeftChild = false;                      present = present.right;                  }                 if(present == null)                                 return ;                         }                     if(present.left == null && present.right == null)              {                 if(present == root)                      root = null;                                 else if(isLeftChild)                           parent.left = null;                     else                                                  parent.right = null;             }                  else if(present.right == null)                    if(present == root)                           root = present.left;                  else if(isLeftChild)                      parent.left = present.left;                   else                      parent.right = present.left;                    else if(present.left == null)                     if(present == root)                                   root = present.right;                     else if(isLeftChild)                      parent.left = present.right;                  else                       parent.right = present.right;                     else              {                      Node successor = getSuccessor(present);                       if(present == root)                       root = successor;                 else if(isLeftChild)                          parent.left= successor;                  else                     parent.right = successor;                      successor.left = present.left;               }            }                  private Node getSuccessor(Node delNode)        {             Node successorParent = delNode;               Node successor = delNode;                 Node present = delNode.right;                   while(present != null)              {                            successorParent = successor;                  successor = present;                              present = present.left;                       }             if(successor != delNode.right)              {                       successorParent.left = successor.right;                   successor.right = delNode.right;                      }             return successor;         }               }