When using `Reduce`, I accidentally put a set of variables as the domain. To my surprise, it not only seems that `Reduce` expects this sort of input, but I found the output to be very useful. Let me explain with an example. In a system of equations with multiple variables, I am often interested in the conditions placed on certain variables. Suppose I have `x + y == 1 && x y == 2` and want to know what conditions this places on `x`. Normally, I would do this:               In[1]:= Reduce[x + y == 1 && x y == 2, x]     Out[1]= (y == 1/2 (1 - I Sqrt[7]) || y == 1/2 (1 + I Sqrt[7])) && x == 1 - y      This output is not in the best form for what I want. Namely, `Reduce` has given me specific values for `y` and then expressed `x` and a function of `y`. I would have preferred if this had been the other way around, then I would have exactly what I want after ignoring `y`. (Oddly enough, `Reduce` gives specific values for `x` and expresses `y` as a function of `x` if you ask it to solve for `y`.) Recently, I was working with a system of equation like this and accidentally put the other variables (in this case, just the variable `y`) as the domain.               In[2]:= Reduce[x + y == 1 && x y == 2, x, {y}]     Out[2]= x == 1/2 (1 - I Sqrt[7]) || x == 1/2 (1 + I Sqrt[7])      Fantastic! This is exactly what I was looking for: the constraints placed on `x`. As far as I can tell, this behavior is not described in the documentation for `Reduce`. ## Question: Is this expected behavior from `Reduce`? If so, where is this behavior described?