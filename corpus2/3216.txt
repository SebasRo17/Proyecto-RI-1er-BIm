Following all the great advice on this other question, I'm now fluent with `HoldAllComplete` and `Unevaluated` on the **input** side of quote-type functions. I continued my investigations and produced the following attempt at a generic conversion from expression to captive (or quoted) expression:               ClearAll[captive];     SetAttributes[captive, HoldAllComplete];     captive[expr_ /; AtomQ @ Unevaluated @ expr] := expr     captive[head_[args___]] :=          {captive @ head} ~Join~ (captive /@ (Unevaluated @ {args}))     captive[x___] := Throw[{x}];      This is really great and handles **almost** all my scenarios. To wit, the following abbreviated test set produces the desired results               testSet = {"foo", foo, 12, 0, 3/4, 3.14, 2.72 + 3.14 I,        Infinity, {1, 2, 3}, {1, "a", b}, f, f[b], f[1, "a", b], f[{}],        f[{1, "a", b}], f[a][b], f[a][1, "a", b], f[a][{}],        f[a][{1, "a", b}], Hold[Plus @@ {}], Hold[Plus @@ {1, 2, 3}],        Plus @@ {1, "a", b}, 1 + "a" b, a + b*c};      as we can see in the output of               MapThread[List, {       InputForm /@ testSet,        InputForm /@ captive /@ testSet}] // TraditionalForm      (input on left, output on right) $\left( \begin{array}{cc} \text{foo} & \text{foo} \\ \text{foo} & \text{foo} \\ 12 & 12 \\ 0 & 0 \\ 3/4 & 3/4 \\ 3.14 & 3.14 \\ 2.72 + 3.14*I & 2.72 + 3.14*I \\ \text{Infinity} & \{\text{DirectedInfinity}, 1\} \\ \{1, 2, 3\} & \{\text{List}, 1, 2, 3\} \\ \{1, \text{a}, b\} & \{\text{List}, 1, \text{a}, b\} \\ f & f \\ f[b] & \{f, b\} \\ f[1, \text{a}, b] & \{f, 1, \text{a}, b\} \\ f[\{\}] & \{f, \{\text{List}\}\} \\ f[\{1, \text{a}, b\}] & \{f, \{\text{List}, 1, \text{a}, b\}\} \\ f[a][b] & \{\{f, a\}, b\} \\ f[a][1, \text{a}, b] & \{\{f, a\}, 1, \text{a}, b\} \\ f[a][\{\}] & \{\{f, a\}, \{\text{List}\}\} \\ f[a][\{1, \text{a}, b\}] & \{\{f, a\}, \{\text{List}, 1, \text{a}, b\}\} \\ \text{Hold}[\text{Plus} \text{@@} \{\}] & \{\text{Hold}, \{\text{Apply}, \text{Plus}, \{\text{List}\}\}\} \\ \text{Hold}[\text{Plus} \text{@@} \{1, 2, 3\}] & \{\text{Hold}, \{\text{Apply}, \text{Plus}, \{\text{List}, 1, 2, 3\}\}\} \\ 1 + \text{a} + b & \{\text{Plus}, 1, \text{a}, b\} \\ 1 + \text{a}*b & \{\text{Plus}, 1, \{\text{Times}, \text{a}, b\}\} \\ a + b*c & \{\text{Plus}, a, \{\text{Times}, b, c\}\} \\ \end{array} \right)$ I get into trouble, however, when a **return value** of a captive expression has a value. For instance, something as simple as               x = y     (* Out[10]= y *)     captive[x]     (* Out[11]= y *)      traceView2 reveals that captive inspects the Held input, as required, but that the evaluator apparently snatches it on the way out, and we don't get `x`, the desired result. ![captive fail](http://i.stack.imgur.com/86Ux2.png) In hindsight, I suppose I shouldn't expect more, since the ever-present term- rewriter (evaluator) is just the way MMA is supposed to work. On a guess, I tried               captive[expr_ /; AtomQ @ Unevaluated @ expr] := Unevaluated @ expr      which doesn't seem to make any difference (and, after reading the docs, I'm not surprised, since `Unevaluated` only seems to have an effect when supplied in a function-argument slot (see this other question in progress related to behavior of Unevaluated). I could do               captive[expr_ /; AtomQ @ Unevaluated @ expr] := Hold @ expr      or, better,               captive[expr_ /; AtomQ @ Unevaluated @ expr] := If[ValueQ @ expr, Hold @ expr,expr]      but now my output will always have `Hold` wrapping symbols that have values. I am beginning to suspect **that this may be the best I can do** , and I'm prepared to accept that answer (it means that my other function, which frees the captive, will have to have to release the particular holds inserted by this process (and not the Holds that were in the original source expressions!?! which means I probably have to mark them specially, but that's for another topic!) But before giving up, I thought I'd consult you all, who have already been so generous.