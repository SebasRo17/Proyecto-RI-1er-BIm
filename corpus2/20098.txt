I am trying to update some parts of an specific matrix as rapidly as possible. In what follows, I first set up the basics things that I want to use               Clear["Global`*"]     SeedRandom[1234];     d = 300;     A = RandomReal[20, {d, d}];     n = Dimensions[A][[1]];     i = 1; num = 2;     Id = SparseArray[{{k_, k_} -> 1.}, {n, n}];     LU = LinearSolve[A];     mat = (1./(Norm[A, 2]^2))*ConjugateTranspose[A];     mat // MatrixPlot      wherein `Id`, denotes the Identity matrix, A is a dense input matrix, and then I wish to update the matrix `mat`, (which is an approximate inverse of the matrix `A`), by entering `num=2`, columns of the exact inverse that will be obtained by solving two linear systems (using `LinearSolveFunction`). To this end, I use the following piece of code, in which after obtaining the `num=2` columns of the matrix inverse, they must be replaced as the first and the second columns of the matrix `mat` at the end of each cycle of `While`: (please forgive me, if I write the codes in a very rough way!)               While[i <= num,       {ll = Id[[All, i]];        ith = Chop@LU[ll];        mat[[All, i]] = ith;        i++}       ];     mat // MatrixPlot      Considering the above dense matrix A, it works and can update the columns of the matrix `mat`. My problem is here, if I use a sparse matrix, then for low dimensions it works rapidly, while for higher dimensions it takes too much time to update the columns of the matrix `mat`. I mean, if we use the following matrix               A = SparseArray[{{i_, i_} ->       RandomReal[3], {i_, j_} /; Abs[i - j] == 1 -> RandomReal[2],     {i_, j_} /; Abs[i - j] == 8 -> RandomReal[1]}, {d, d}];      while `d=3000`. I would like to ask you experts about that: how we could accelerate (in terms of computational time) this process for dense and sparse matrices in a simple uniform piece of code? Any tip or help will be cheerfully thanked.