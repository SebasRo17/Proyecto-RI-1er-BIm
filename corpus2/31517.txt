I'm trying to parallelize a function by ParallelTable, and it seems the speedup is not very good. I have 16 parallel kernels on my computer node:               $Version     (*"9.0 for Linux x86 (64-bit) (November 20, 2012)"*)          LaunchKernels[]     (*     {KernelObject[1, "local"], KernelObject[2, "local"], KernelObject[3, "local"],KernelObject[4, "local"], KernelObject[5, "local"], KernelObject[6, "local"], KernelObject[7, "local"], KernelObject[8, "local"], KernelObject[9, "local"], KernelObject[10, "local"], KernelObject[11, "local"], KernelObject[12, "local"], KernelObject[13, "local"], KernelObject[14, "local"], KernelObject[15, "local"], KernelObject[16, "local"]}     *)      And using a documentation example, I get about 16X speedup:               Table[Pause[0.5];f[i],{i,16}]//AbsoluteTiming     (*{8.003956, Null*)          ParallelTable[Pause[0.5];f[i],{i,16}]//AbsoluteTiming     (*{0.508174, Null*)      However, my code only get 2X speedup:               hz = 2*0.375*^-9; c = 2.997924580*^8; ht = hz/(1.01*c)*1.*^15; N0 = 60000; hbar = 1.0545716*^-34; ωx = 2.96265*^1; nx = 5.; Ex = 2.74*^8; Tx = 2 π/ωx; β2 = 226.161; d13 = 8.35066*^-31; Ti = 2.64516;          Ω13[t_, β1_] := Piecewise[{{((Ex*d13)/(hbar*1.*^15))*Cos[(ωx*(t - β1))/(2*nx)]^2* Sin[ωx*(t - β1)], β1 - nx*(Tx/2.) <= t <= β1 + nx*(Tx/2.)}, {0., True}}]          Ω13cf =        Compile[{{t, _Real}, {τ1, _Real}}, Evaluate@Ω13[t, τ1], RuntimeAttributes -> {Listable}];          Table[Ω13cf[t, τ1], Evaluate@{τ1, β2 - 80 Ti, β2 + 10 Ti, 0.05 Ti}, Evaluate@{t, ht, ht*N0, ht}] // Developer`PackedArrayQ // AbsoluteTiming     (*{14.805294, True}*)          Table[Ω13cf[t, τ1], Evaluate@{τ1, β2 - 80 Ti, β2 + 10 Ti, 0.05 Ti}, Evaluate@{t, ht, ht*N0, ht}] // Developer`PackedArrayQ // AbsoluteTiming     (*{14.799250, True}*)          ParallelTable[Ω13cf[t, τ1], Evaluate@{τ1, β2 - 80 Ti, β2 + 10 Ti, 0.05 Ti}, Evaluate@{t, ht, ht*N0, ht}] // Developer`PackedArrayQ // AbsoluteTiming     (*{7.714471, True}*)          ParallelTable[Ω13cf[t, τ1], Evaluate@{τ1, β2 - 80 Ti, β2 + 10 Ti, 0.05 Ti}, Evaluate@{t, ht, ht*N0, ht}] // Developer`PackedArrayQ // AbsoluteTiming     (*{3.088646, True}*)      Questions:   1. Is it possible to get about 16X speedup using ParallelTable, and how?   2. Why the second ParallelTable get a 2X speedup? **Update** Mr. Wizard suggested a very useful discussion on how to efficiently parallelize the problem. As I understand, the basic idea is to use `ParallelMap` instead of `ParallelTable`. So I tried this approach, but it turns out the result is not a PackedArray and `ParallelMap` more than 10X slower than the un-parallelized `Table`:               ls = Tuples[{Range[ht, ht*N0, ht],Range[β2 - 80 Ti, β2 + 10 Ti, 0.05 Ti]}];     Developer`PackedArrayQ[ls]     （*True*）          Map[Ω13cf @@ # &, ls] // Developer`PackedArrayQ // AbsoluteTiming     (*{181.030360,False}*)          ParallelMap[Ω13cf @@ # &, ls] // Developer`PackedArrayQ // AbsoluteTiming     (*no return before I kill it after running for 5 minutes*)