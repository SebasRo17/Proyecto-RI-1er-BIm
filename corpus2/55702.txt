I have a number of ugly ways to implement the following **pattern recognition** task, but I'm looking for something elegant to keep my notebook tidy. I need to define a function of six variables $f(a,b,c;A,B,C)$ which is known to be unchanged under the simultaneous interchange of any two of $a,b,c$ and of the corresponding $A,B,C$: $$\begin{align}&f(a,b,c;A,B,C) = f(a,c,b;A,C,B) = f(b,a,c;B,A,C) \\ =&f(b,c,a;B,C,A) = f(c,a,b;C,A,B) = f(c,b,a;C,B,A)\end{align}$$ **EDIT for clarity: Given one definition, how do I get** **_Mathematica_** **to try all possibilities within the** **_restricted_** **set of permutations shown above for pattern matching? I need to mimic the effect of** `SetAttributes[f,Orderless]`. More concretely, if I define the special case:               f[a_, 0, b_, A_, 0, C_] := (a+b)/(A-C)      a function call `f[x, y, 0, m, n, 0]` should match, and return `(x+y)/(m-n)`. But `f[x, y, 0, m, 0, n]` should _not_ match, and thus return it must be returned unevaluated. **Added question:** Instead of finding a way to get _Mathematica_ to try all the possibilities when pattern matching, would it be easier to write code such that when a representative definition for `f` is made, the kernel automatically adds further definitions of `f` for the remaining permutations of the arguments?