I have created a couple of projects to create a better division of my code: I have a Portable Class Library targeting all frameworks that contains just basic DTOs (auto-generated against a database). These DTOs will contain some basic DataAnnotations for the class representing the table. For example:               [DataContract]     public class OrderDetail     {         [DataMember]         public virtual int Id { get; set; }              [DataMember]         [Required]         [StringLength(32)]         public virtual string OrderCode { get; set; }              [DataMember]         public virtual DateTime OrderDate { get; set; }              [DataMember]         public virtual DateTime? ShippedDate { get; set; }     }      * * * Now, the problem I have is that I want to create a "Business Object" and provide common features such as n-level Undo/Redo, marking child objects for deletion, etc. The ways I could think about doing this is as follows: **Option 1** : Inherit the DTO to add the additional members (build out the object graph). I can use partial classes and interfaces and even some AOP to implement the common features. For example:               // OrderDetail.generated.cs: Auto-Generated/T4     public sealed partial class OrderDetail : DTO.OrderDetail, IUndoRedo     {         // Common Features coded here (i.e. n-level Undo/Redo)     }          // OrderDetail.cs: Custom Code     [DataContract]     public sealed partial class OrderDetail     {         [DataMember]         [Required]         public Address ShippingAddress { get; set; }              [DataMember]         [Required]         [Cardinality(1, Cardinality.Infinity)]         public ICollection<ProductDetail> Products { get; set; }     }      Now, the problem with this is that every single Auto-Generated business object extension of each DTO (`OrderDetail`, `Address`, `ProductDetail`, etc.) needs to have the common business features available (i.e. n-level Undo/Redo), but they can't inherit from some sort of `BusinessBase` class because they inherit from the DTO. **Option 2** : Inherit each business object from a `BusinessBase` abstract class which already has common features built into it. Then, simply wrap the DTO properties and re-expose them?               [DataContract]     public abstract class BusinessBase : IUndoRedo     {         // Common Features coded here (i.e. n-level Undo/Redo)     }          [DataContract]     public sealed class OrderDetail : BusinessBase     {         // Wrapped Properties         private Dto.OrderDetail Dto { get; set; }              [DataMember]         [Required]         [StringLength(32)]         public string OrderCode         {             get { return Dto.OrderCode; }             set { Dto.OrderCode = value; }         }              // etc ...              // Custom properties (Object-Graph)         [DataMember]         [Required]         public Address ShippingAddress { get; set; }     }      The problem with this is all the wrapped up DTOs, and it lacks inheritance, so the "Business" version of OrderDetail isn't a type of DTO OrderDetail, and the wrapped properties can get redundant. I'm really stuck as to what should be done here, is one option better, or maybe some other way of doing this that wasn't accounted for (Option 3, 4, 5, etc.)?