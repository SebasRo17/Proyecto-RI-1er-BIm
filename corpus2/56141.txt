Lets say i have two lists with me as given below:               l1 = {4, 6, 8, 9, 10, 12};          l2 = {2, 3, 4, 5, 6, 7};      Now i have a function S2P(details irrelevant) which takes one argument and spits out a list.               S2P[a_] := DeleteDuplicates[Apply[Times,Partition[Flatten[IntegerPartitions[a, {2}]], 2], {1}]]      Now i want to feed S2P the elements of l2 and find which elements of l2 gives an output that is a subset of l1. For e.g               S2P[5]     (*{4, 6}*)           S2P[7]     (*{6, 10, 12}*)      These are the only two elements of l2 for which the output from S2P is a subset of l1 and im finding them like this:               t1[n_] := Module[{l3, res, len},     l3 = S2P[l2[[n]]];     len = Length[l3];     res = Count[     Flatten[Table[{l3[[i]]} == {l1[[#]]} & /@ Range[Length[l1]], {i,1,len}]],True];     If[res == len, Sow[l2[[n]]]]];          DeleteCases[t1[#] & /@ Range[Length[l2]], Null]     (*{5, 7}*)      Can someone show me how to do this more efficiently for large data. Below i have shown the actual function l1 and l2 where n can go upto 1000.               f4 = #~Extract~SparseArray[Unitize[#2 - 1]]["NonzeroPositions"] & @@      Transpose@Tally@# &; (* to keep only duplicates*)          l1[n_] :=      DeleteCases[f4[Flatten[Table[i*j, {i, 1, n}, {j, 1, n}]]], _?PrimeQ]          l2[n_] :=      DeleteDuplicates[Flatten[Table[i + j, {i, 1, n}, {j, 1, n}]]]