Is there some standardized or widely accepted algorithm for picking up operators in shift/reduce conflicts in LALR parser? The question is naive, my problem is not with implementing my solution, but implementing the solution is already widely used. For shift the operator is the next input token, for reduce, it depends -- I consider all already read symbols (for given production) declared as operators:   * if there is one -- it is the operator   * if there are more than one -- I report grammar error   * if there is none I use the input token as operator So for example:               E ::= E + E     E ::= E * E     E ::= num      in case of               E + E | * num      Considering first production I read `+`, and since it is the only one operator read I pick this one for reduce operator. `*` is the first token in input so it servers as shift operator. But is my algorithm correct (i.e. the same as normally used for LALR parsers)? I am especially worried for the point when I have more than 1 operator in the read tokens. * * * ## Update What I **NOT** am asking here I don't ask how to resolve shift/reduce conflict once you have the operators. I don't ask how to set the precedence for operators. What I **am** asking here I ask how to extract operators from the "stream" of tokens. Let's say user set some precedence rules for `+`, `-` and `*`. The stack is: `-` `E` `+` `E` and input is `E`. Or the stack is `E` and input is `*`. What is the operator for reduce in first case? And in the second? Why? _The stack is really entire right hand side of production._