I've done a program in order to calculate the time required to evacuate a room. The program takes in arguments the number of people (N), the dimensions of the room (L,l), and the location of the exit door. People are represented by 1, and free places by 0. At each step, people can move of one square. There is a counter which counts the number of steps. However, sometimes I get a number of steps which is less than the number of people. And normally, maximum one person can go out by step. Where is the mistake ? Thank you.               def evacuation(N,L,l,iporte,jporte):      a=np.zeros((L,l),dtype=int)           Z=np.sum(a)                           for h in range(N):         ir=rd.randint(0,L)         jr=rd.randint(0,l)         while (a[ir,jr]==1):             ir=rd.randint(0,L)             jr=rd.randint(0,l)         a[ir,jr]=1     A=0     for i in range(L):         for j in range(l):             if a[i,j]==1:                 A=A+1     count=0     run=True     while run:                     #print (a)                     count=count+1                     a[iporte,jporte]=0                     for i in range(L):                         for j in range(l):                             if a[i,j]==1:                                 d=np.ones(4)*10000                                 if i >=0 and i +1 <= L and j >=0 and j+1 <= l:                                                              if i >0 and a[i-1,j]==0:                                         d[0]=np.sqrt((i-1-iporte)**2+(j-jporte )**2)                                     if i <L-1 and a[i+1,j]==0:                                         d [1]= np.sqrt((i+1-iporte )**2+(j-jporte )**2)                                     if j >0 and a[i,j-1]==0:                                         d [2]= np.sqrt((i-iporte)**2+(j-1-jporte)**2)                                     if j <l-1 and a[i,j+1]==0:                                         d [3]= np.sqrt((i-iporte )**2+(j+1-jporte)**2)                                 dmin=min(d)                                 kmin=[]                                 for k in range(4):                                     if d[k]==dmin:                                         kmin.append(k)                                 if len(kmin)==2:                                     b=rd.randint(0,2)                                     if b==0:                                         kmin=kmin[0]                                     if b==1:                                         kmin=kmin[1]                                 else:                                     kmin=kmin[0]                                 if kmin==0 and i>0 and a[i-1,j]!=2:                                     a[i-1,j]=3                                     a[i,j]=0                                 if kmin==1 and i<L-1 and a[i+1,j]!=2:                                     a[i+1,j]=3                                     a[i,j]=0                                 if kmin==2 and j>0 and a[i,j-1]!=2:                                     a[i,j-1]=3                                     a[i,j]=0                                 if kmin==3 and j<l-1 and a[i,j+1]!=2:                                     a[i,j+1]=3                                     a[i,j]=0                             if a[i,j]==2:                                 a[i,j]=2                             if a[i,j]==0:                                 a[i,j]=0                     for i in range(L):                         for j in range(l):                             if a[i,j]==3:                                 a[i,j]=1                     m=0                     for i in range(L):                         for j in range(l):                             m=m+a[i,j]                     if m==Z:                         run=False     return count