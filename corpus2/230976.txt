I have implemented a LL1 parser in a non recursive approach with a explicit stack. The following algorithm is from the Dragon Book:               set zp to point to the first symbol of w;     set X to the top stack symbol;     while ( X != $ ) { /* stack is not empty */         if ( X is a )             pop the stack and advance zp;         else if ( X is a terminal )            error();         else if ( M[X, a] is an error entry )            error();         else if ( M[X,a] = X -+ Y1Y2 Yk ) {            output the production X -+ YlY2 - . Yk;            pop the stack;            push Yk, Yk-1,. . . , Yl onto the stack, with Yl on top;              set X to the top stack symbol;     }      The book says: > The parser is controlled by a program that considers X, the symbol on top of > the stack, and a, the current input symbol. If X is a nonterminal, the > parser chooses an X-production by consulting entry M[X, a] of the parsing > table IM. **(Additional code could be executed here, for example, code to > construct a node in a parse tree.)** Otherwise, it checks for a match > between the terminal X and current input symbol a. However i need more info on how to construct the expression tree nodes under this approach. I have a node hierarchy of UnaryOperator, BinaryOperator, etc but dont know where to instanciate it. Yet i havent found any simple example of this (with for example the arithmetic language).