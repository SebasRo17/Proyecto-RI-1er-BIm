I've seen several recommend use of IoC containers in code. The motivation is simple. Take the following dependency injected code:               class UnitUnderTest     {         std::auto_ptr<Dependency> d_;     public:         UnitUnderTest(             std::auto_ptr<Dependency> d = std::auto_ptr<Dependency>(new ConcreteDependency)         ) : d_(d)         {         }     };               TEST(UnitUnderTest, Example)     {         std::auto_ptr<Dependency> dep(new MockDependency);         UnitUnderTest uut(dep);         //Test here     }      Into:               class UnitUnderTest     {         std::auto_ptr<Dependency> d_;     public:         UnitUnderTest()         {             d_.reset(static_cast<Dependency *>(IocContainer::Get("Dependency")));         }     };               TEST(UnitUnderTest, Example)     {         UnitUnderTest uut;         //Test here     }          //Config for IOC container normally     <Dependency>ConcreteDependency</Dependency>          //Config for IOC container for testing     <Dependency>MockDependency</Dependency>      (The above is hypothetical C++ example of course) While I agree that this simplifies the interface of the class by removing the dependency constructor parameter, I think the cure is worse than the disease for a couple of reasons. First, and this is a big one for me, this makes your program dependent on an external configuration file. If you need single binary deployment, you simply cannot use these kinds of containers. The second issue is that the API is now weakly and worse, _stringly_ typed. The evidence (in this hypothetical example) is the string argument to the IoC container, and the cast on the result. So.. are there other benefits of using these kinds of containers or do I just disagree with those recommending the containers?