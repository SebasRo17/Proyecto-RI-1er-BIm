I have been greatly influenced by Joshua Bloch's Effective Java book (2nd edition), probably more so than with any programming book I've read. In particular, his Builder Pattern (item 2) has had the greatest effect. Despite Bloch's builder getting me much farther in the couple of months than in my past ten years of programming, I am still finding myself hitting the same wall: Extending classes with self-returning method-chains is at best discouraging, and at worst a nightmare--especially when generics come into play, and _especially_ with **_self-referential generics_** (such as `Comparable<T extends Comparable<T>>`). There are two primary needs that I have, only the second of which I'd like to focus on in this question:   1. The first problem is "how to share self-returning method chains, without having to re-implement them in every...single...class?" For those who may be curious, I've addressed this part at the bottom of this answer-post, but it's not what I want to focus on here.   2. The second problem, which I am asking for comment on, is "how can I implement a builder in classes that are themselves intended to be extended by many other classes?" Extending a class with a builder is naturally more difficult than extending one without. Extending a class that has a builder _that also implements`Needable`, and therefore has significant generics associated to it_, is unwieldy. So that is my question: How can I improve upon (what I call) the Bloch Builder, so I can feel free to attach a builder to _any_ class--even when that class is meant to be a "base class" that may be extended and sub-extended many times over-- _without discouraging my future-self, or users of my library_ , because of the extra baggage the builder (and its potential generics) impose on them? * * * _**Addendum_**   My question focuses on part 2 above, but I wanted to elaborate a bit on problem one, including how I've dealt with it: The first problem is "how to share self-returning method chains, without having to re-implement them in every...single...class?" This is not to prevent _extending classes_ from having to re-implement these chains, which, of course, they must--rather, how to prevent _non-sub-classes_ , that want to take advantage of these method chains, from having to re-implement every self- returning function in order for _their_ users to be able to take advantage of them? For this I've come up with a needer-needable design that I'll print the interface skeletons for here, and leave it at that for now. It has worked well for me (this design was years in the making...the hardest part was avoiding circular dependencies):               public interface Chainable  {           Chainable chainID(boolean b_setStatic, Object o_id);           Object getChainID();           Object getStaticChainID();       }     public interface Needable<O,R extends Needer> extends Chainable  {         boolean isAvailableToNeeder();         Needable<O,R> startConfigReturnNeedable(R n_eeder);         R getActiveNeeder();         boolean isNeededUsable();         R endCfg();     }     public interface Needer  {         void startConfig(Class<?> cls_needed);         boolean isConfigActive();         Class getNeededType();         void neeadableSetsNeeded(Object o_fullyConfigured);     }