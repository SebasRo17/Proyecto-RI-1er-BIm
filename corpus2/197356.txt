In the Go Language Tutorial, they explain how interfaces work: > Go does not have classes. However, you can define methods on struct types. > The _method receiver_ appears in its own argument list between the func > keyword and the method name.               type Vertex struct {         X, Y float64     }          func (v *Vertex) Abs() float64 {         return math.Sqrt(v.X*v.X + v.Y*v.Y)     }      > An interface type is defined by a set of methods. A value of interface type > can hold any value that implements those methods. This is the only way to create an interface in Go. Google further explains that: > A type implements an interface by implementing the methods. There is no > explicit declaration of intent [i.e. `interface` declarations]. > > Implicit interfaces decouple implementation packages from the packages that > define the interfaces: neither depends on the other. > > It also encourages the definition of precise interfaces, because you don't > have to find every implementation and tag it with the new interface name. This all sounds suspiciously like Extension Methods in C#, except that methods in Go are ruthlessly polymorphic; they will operate on _any type_ that implements them. Google claims that this encourages rapid development, but why? Do you give up something by moving away from explicit interfaces in C#? Could Extension Methods in C# allow one to derive some of the benefits that Go interfaces have in C#?