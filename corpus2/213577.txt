In the debate of Rich vs. Anemic domain models, the internet is full of philosophical advice but short on authoritative examples. The objective of this question is to find definitive guidelines and concrete examples of proper Domain-Driven Design models. (Ideally in C#.) For a real-world example, this implementation of DDD seems to be wrong: The WorkItem domain models below are nothing but property bags, used by Entity Framework for a code-first database. Per Fowler, it is anemic. The WorkItemService layer is apparently a common misperception of Domain Services; it contains all of the behavior / business logic for the WorkItem. Per Yemelyanov and others, it is procedural. (pg. 6) So if the below is wrong, how can I make it right?   The behavior, i.e. _AddStatusUpdate_ or _Checkout_ , should belong in the WorkItem class correct?   What dependencies should the WorkItem model have? ![enter image description here](http://i.stack.imgur.com/QKWNn.png)               public class WorkItemService : IWorkItemService {         private IUnitOfWorkFactory _unitOfWorkFactory;              //using Unity for dependency injection         public WorkItemService(IUnitOfWorkFactory unitOfWorkFactory) {             _unitOfWorkFactory = unitOfWorkFactory;         }              public void AddStatusUpdate(int workItemId, int statusId) {                  using (var unitOfWork = _unitOfWorkFactory.GetUnitOfWork<IWorkItemUnitOfWork>()) {                 var workItemRepo = unitOfWork.WorkItemRepository;                 var workItemStatusRepo = unitOfWork.WorkItemStatusRepository;                      var workItem = workItemRepo.Read(wi => wi.Id == workItemId).FirstOrDefault();                 if (workItem == null)                     throw new ArgumentException(string.Format(@"The provided WorkItem Id '{0}' is not recognized", workItemId), "workItemId");                      var status = workItemStatusRepo.Read(s => s.Id == statusId).FirstOrDefault();                 if (status == null)                     throw new ArgumentException(string.Format(@"The provided Status Id '{0}' is not recognized", statusId), "statusId");                      workItem.StatusHistory.Add(status);                      workItemRepo.Update(workItem);                 unitOfWork.Save();             }         }     }      (This example was simplified to be more readable. There are other entities, and for instance the AddStatusUpdate has some extra behavior -- IRL it actually takes a status category name, and if that category doesn't exist, the category is created.) ## Update @AlexeyZimarev gave the correct answer, a perfect video on the subject in C# by Jimmy Bogard, but it was apparently moved into a comment below because it didn't give enough information beyond the link. I have a rough draft of my notes summarizing the video in my answer below. Please feel free to comment on the answer with any corrections. The video is an hour long but very worth watching.