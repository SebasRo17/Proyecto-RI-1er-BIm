I have a little example that exhibits a successful pattern match in `ReplaceAll` that `Cases` misses and I wonder if the assembled sages would be so kind as to offer me an explanation? This is chopped from an original Prolog emulator by Renan Cabrera circa 2000.               ClearAll[k,s,l,m,j,f,w,g,a,b]      Consider an unordered sequence of _statements`s`_ stored in a _knowledge base`k`_, each being a _predicate`l`_ about some _terms`m`, `f`, `j`,_ and _`w`_ :               k=s[l[m,f],         l[m,w],         l[j,w],         l[j,m]     ];      We wish to search this knowledge base for any predicates such that `l[m,X_]` and `l[j,X_]`, where `X_` matches the same term in both predicates. Our first cut is something like               k /. s[l[m,X_],l[j,X_]] -> a[X]     (* Out[42]:= s[l[m,f],l[m,w],l[j,w],l[j,m]] *)      but this doesn't work until we make _s_ flat and orderless (associative and commutative):               SetAttributes[s,{Flat,Orderless}]      and now               k /. s[l[m,X_],l[j,X_]] -> a[X]     (* Out[43]:= s[a[w],l[j,m],l[m,f]] *)      This is, of course, just the same as `ReplaceAll[k, s[l[m,X_],l[j,X_]] -> a[X]]`. (notice the canonical reordering in the output), and now I can extract my answer with something like               Cases[k /. s[ l[m, X_], l[j, X_] ]->a[X],a[Y_]->Y]     (* Out[44]:= {w} *)      The surprise and the question is why doesn't this work?               Cases[k, s[ l[m, X_], l[j, X_] ] -> a[X]]     (* Out[45]:= {} *)      or even this               MatchQ[k, s[ l[m, X_], l[j, X_] ]]     (* Out[46]:= False *)      It's as though `ReplaceAll`, `Cases`, and `MatchQ` are using different pattern matchers. Will be grateful for advice, clues, discussion, etc.