I have lists which consists of sublists of equal length. The outer list is regarded as a multiset (that is, permutations of the sublists don't matter, but repetitions do), but the order in the sublists _does_ matter, except that if the _same_ permutation is applied to each of the sublists, it also doesn't matter. Now my problem is that I want to write a function that tests whether two lists are equivalent under those rules. An obvious solution would of course be to generate all "inner" permutations for one set and seek the other one in there (the outer permutations can then, of course, be gotten rid of through sorting), but I feel there should be a simpler (and more efficient) solution. But I don't seem to be able to figure it out. To make some concrete examples, I'd like to get e.g. the following results:               equiv[{{1,1,1,2},{1,1,2,2},{2,2,2,2}},           {{2,1,1,1},{2,1,2,1},{2,2,2,2}}] == True      because you get the second from the first by exchanging the first and the last element in each sublist. On the other hand,               equiv[{{1,1,1,2},{1,1,2,2},{2,2,2,2}},           {{2,1,1,1},{1,1,2,2},{2,2,2,2}}] == False      because there's no _common_ permutation which transforms the first to the second. Of course I also want               equiv[{{1,1,1,2},{1,1,2,2},{2,2,2,2}},           {{1,1,2,2},{2,2,2,2},{1,1,1,2}}] == True      because here only the sublists are permuted in the outer list. And also,               equiv[{{1,1,1,2},{1,1,2,2},{2,2,2,2}},           {{2,1,2,1},{2,1,1,1},{2,2,2,2}}] == True      because this just combines a permutation of the sublists with a _common_ permutation of the elements in each list. So what is the best way to write this `equiv` function above?