I'm working on a socks server application written in C#. But I don't really know how to design this in a nice way. I got this for Socks V4 and V4A: ![enter image description here](http://i.stack.imgur.com/xCHbP.png) _I'm not sure if it clears things up, but I think it easier to explain when you have a look what classes exists._ The _SOCKSServer_ is a wrapper over a _Server_ instance. When a client connects it waits for the SOCKS4 request, here is how that looks:               var remoteEnd = eventArgs.Client.RemoteEndPoint.ToString();     var buffer = new byte[1024];     var task = eventArgs.Client.ReceiveTaskAsync(buffer, 0, buffer.Length);     if (await Task.WhenAny(task, Task.Delay(Timeout)) != task) // Timeout reached     {         Trace.WriteLine(String.Format("[{0}] Timeout expired ({1} ms)", remoteEnd, Timeout));         eventArgs.Client.Disconnect();         return;     }          HandleRequest(eventArgs.Client, buffer);          //....          private void HandleRequest(Client client, byte[] request)     {         var remoteEnd = client.RemoteEndPoint.ToString();         var connectionRequest = ConnectionRequest.CreateInstance(request);         if (connectionRequest == null) //invalid version         {             Trace.WriteLine(String.Format("[{0}] Invalid version ({1})", remoteEnd, request[0]));             return;         }              if (connectionRequest.Version == 0x04) // Could be V4 or V4A         {             HandleRequestV4(client, (ConnectionRequestV4) connectionRequest);             return;         }              //It is V5          }          private void HandleRequestV4(Client client, ConnectionRequestV4 connectionRequest)     {         var remoteEnd = client.RemoteEndPoint.ToString();         Trace.WriteLine(String.Format("[{0}] (Id: {3}) SOCKS4(A) Request to: {1}:{2}", remoteEnd,             connectionRequest.IpAddress, connectionRequest.Port, connectionRequest.Id));         Trace.Write(String.Format("[{0}] (Id: {3}) Trying {1}:{2}.. ", remoteEnd, connectionRequest.IpAddress,             connectionRequest.Port, connectionRequest.Id));              var remoteHost = new Client();         if (remoteHost.ConnectTaskAsync(new IPEndPoint(connectionRequest.IpAddress, connectionRequest.Port)).Result)         {             Trace.WriteLine("Succes :D");                  byte[] response;             if (connectionRequest is ConnectionRequestV4A)             {                 Trace.WriteLine(String.Format("[{0}] (Id: {2}) Request is SOCKS4A to: {1}", remoteEnd,                     ((ConnectionRequestV4A) connectionRequest).Domain, connectionRequest.Id));                      ConnectionRequestV4A.AllowConnection(out response, connectionRequest.IpAddress);             }             else             {                 ConnectionRequestV4.AllowConnection(out response);             }                  client.Send(response, 0, response.Length);                  var tunnel = new TunnelV4(remoteHost, client) {BufferSize = BufferSize};             tunnel.DataReceive += DataReceive;             tunnel.DataSend += DataSend;             tunnel.Open();             Trace.WriteLine(String.Format("[{0}] (Id: {1}) SOCKS4 Tunnel Opened =D", remoteEnd, connectionRequest.Id));         }         else         {             Trace.WriteLine("Failed :(");                  byte[] response;             ConnectionRequestV4.RefuseConnection(out response);             client.Send(response, 0, response.Length);         }     }      The request packet looks like:               /*       *  +-----+-----+------+------+--------+      *  | VER | CMD | Port |  IP  |   ID   |      *  +-----+-----+------+------+--------+      *  |  1  |  1  |  2   |  4   |  *'\0' |      *  +-----+-----+------+------+--------+      */      The numbers are the amount of octet (1 byte = 8 bits). But how can I design SOCKS V5? It is more complex there are 3 authentication methods (No authentication, GSSAPI and Username/Password). When the client connects it sends a greeting message which contains the authentication method (id only) then the server response with what authentication to choose (or 0xFF to say that there wasn't an acceptable method). And then the authentication protocol starts which is different for all methods. And after that the client proxy sends the connection request. The full documentation can be found here: RFC1928 or Wikipedia So how can I design this application to support SOCKSV4, V4A and V5 in an OOP manner? **Edit:** The full source can be found here: Github