Example:               int c = 4;     int p = 5;          if (p & (1 << c))        printf("ok\n");     else        printf("nop\n");      gcc -S:               movl    -4(%rbp), %eax   /* eax holds the variable c  */     movl    -8(%rbp), %edx   /* and edx holds p  */     movl    %eax, %ecx       /* tmp(ecx) = c  */     sarl    %cl, %edx        /* edx(p) >>= c  */     movl    %edx, %eax       /* eax = p shifted right by c */     andl    $1, %eax         /* eax(p shifted right by c) &= 1  */     testl   %eax, %eax       /* test if p is 0  */     ... jumps and such ...      As you can see, GCC for some reason converted my code to:               p >>= c;     p &= 1     if (p != 0)         ...     else         ...      Something fishy is going on here or I am missing something... It kinda made the operation backwards, although I had brackets around the `1 << c` so it should've done it separately then AND it with `p` correct? Can someone explain why did GCC do this? Is it some sort of optimization (I had no optimization enabled when I compiled this, so doubt it) Or is it how it should be done in assembly?