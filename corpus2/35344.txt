Is there a way to **conditionally** take control the flow during a depth-first scan against a **TreeGraph**? I have a tree graph whose nodes are constructed as object, and there's a method `isTrue[para_]` for each node.               isValid[desc] = "Check whether input is valid";     isValid[isTrue, para_] := Module[{result},         result = SyntaxQ[para];         Return[result];     ];          isNumber[desc] = "Check whether input is a number";     isNumber[isTrue, para_] := Module[{result},         result = NumberQ[ToExpression[para]];         Return[result];     ];          isInteger[desc] = "Check whether input is an integer";     isInteger[isTrue, para_] := Module[{result},         result = IntegerQ[ToExpression[para]];         Return[result];     ];          isFraction[desc] = "Check whether input is a fraction";     isFraction[isTrue, para_] := Module[{result},         result = !IntegerQ[ToExpression[para]];         Return[result];     ];           tree =        TreeGraph[{isValid, isNumber, isInteger, isFraction},          {isValid -> isNumber, isNumber -> isInteger, isNumber -> isFraction},         VertexLabels->"Name"];      Here is the tree image of the code, The root is `isValid`. ![The structure of tree](http://i.stack.imgur.com/O208W.png) If my input is "3.5", I expect the depth-scan flow should be `isValid -> isNumber -> isFraction` because the `isInteger` gives `False`. I tried `Abort[]` like (as well as `Return[]`):               DepthFirstScan[tree, isValid,       "DiscoverVertex" -> (If[#[isTrue, "3.5"], Print[#], Abort[]]&)];      But this broke the whole scan flow. What I want is: when the node gives `False`, it and its child-nodes should be skipped, but the scan should continue scanning the remaining nodes.