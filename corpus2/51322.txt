I am looking for all the roots of `HarmonicNumber`, in the domain [-30, 1] and [0, 6000] for the real and imaginary parts, respectively, and where the parameter `n` of `HarmonicNumber` is as high as 200. This problem had been asked before in this question. As I increase the size of the domains where I am looking for roots, the following warnings show up: > FindRoot::jsing: "Encountered a singular Jacobian at the point {x,y} = > {56.9935,171.987}. Try perturbing the initial point(s)." > > FindRoot::lstol: The line search decreased the step size to within tolerance > specified by AccuracyGoal and PrecisionGoal but was unable to find a > sufficient decrease in the merit function. You may need more than > MachinePrecision digits of working precision to meet these tolerances " Could you help me fix this? Or suggest another way to solve this equation. I got the same warnings when I tried to apply another technique as described in this answer Here is the code:               Options[FindRoots2D] = {PlotPoints -> Automatic, MaxRecursion -> Automatic};           FindRoots2D[funcs_, {x_, a_, b_}, {y_, c_, d_}, opts___] := Module[     {fZero, seeds, signs, fy},fy = Compile[{x, y}, Evaluate[funcs[[2]]]];      fZero = Cases[Normal[      ContourPlot[         funcs[[1]] == 0,          {x, a-(b-a)/97, b+(b-a)/103}, {y, c-(d-c)/98, d+(d-c)/102},          Evaluate[FilterRules[{opts}, Options[ContourPlot]]]]],       Line[z_] :> z, Infinity];            seeds = Flatten[(      (signs = Sign[Apply[fy, #1, {1}]];        #1[[1 + Flatten[Position[Rest[signs*RotateRight[signs]], -1]]]]) &      ) /@ fZero, 1];      If[seeds == {}, {},       Select[         Union[({x, y} /.            FindRoot[{funcs[[1]], funcs[[2]]}, {x, #1[[1]]}, {y, #1[[2]]},                Evaluate[FilterRules[{opts}, Options[FindRoot]]]] & ) /@ seeds,             SameTest -> (Norm[#1 - #2] < 10^(-6) & )],          a <= #1[[1]] <= b && c <= #1[[2]] <= d & ]]]     n = 20;     zeros = FindRoots2D[{Re[HarmonicNumber[n, x + I y]], Im[HarmonicNumber[n, x + I y]]}, {x, -30, 1}, {y, 0, 6000}]     mediumSeaGreen = RGBColor[0.235298`, 0.702002`, 0.443098`];     violet = RGBColor[0.559999`, 0.370006`, 0.599994`];     orangeRed = RGBColor[1.`, 0.270608`, 0.`];     ContourPlot[{Re[HarmonicNumber[n, x + I y]] == 0, Im[HarmonicNumber[n, x + I y]] == 0},      {x, -30, 1}, {y, 0, 6000},     MaxRecursion -> 3,ContourStyle -> {Directive[Thick, mediumSeaGreen],     Directive[Thick, violet]},      Epilog -> {PointSize[0.02], orangeRed, Point[zeros]}]      The following was my trial of n=20 and range x={-32,1} and y={0,4000}. n = 20; seeds = findSeeds[myHN[n, x + I y], {x, -32, 1}, {y, 0, 4000}, PlotPoints -> 25, MeshFunctions -> {myHNReImCx[n][#1, #2] &, myHNReImCy[n][#1, #2] &}]; // AbsoluteTiming allfoundzeros = Quiet@myFRC[myHN[n, z], {z, -32, 1 + 4000 I}, seeds.{1, I}]; // AbsoluteTiming uniqueszeros = #[[First@Ordering[Abs@myHN[n, #]]]] & /@ findclusters[allfoundzeros, 10.^-6]; // AbsoluteTiming zeros = Pick[uniqueszeros, With[{zz = Developer`ToPackedArray@N@uniqueszeros}, UnitStep[(#1 - (-32)) (1 - #1) (#2) (4000 - #2)] &[Re[zz], Im[zz], 1]], 1]; // AbsoluteTiming Length[zeros] zeroplot = Graphics[{PointSize[0.0035], Red, Point@Transpose@{Re[zeros], Im[zeros]}}, PlotRange -> {{-32, 1}, {0, 4000}}, AspectRatio -> 1, Frame -> True]