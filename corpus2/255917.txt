Producing predictable output for each possible input is the responsibility of each module. For example (in C#):               class Logger     {         public ITextWriter Writer { get; set; }              private uint counter;              /// <summary>         /// Writes message in special format and returns the number of total messages written         /// </summary>         public uint Debug(string message)         {             if (message == null) throw new ArgumentNullException("message");                  if (Writer == null) throw new InvalidOperationException("Writer not set");                  Writer.Write(string.Format("{0:HHmmss}: [DEBUG] {1}", DateTime.Now, message));                  return ++counter;         }     }      `Logger` module is quite verbose, but it's output - exception, call to a depedency and returned value - is predictable and obvious for each argument and state. But one possible use-case bothers me. What if `Writer` was set to some weird implementation which somehow calls the `Logger.Debug` method on that same object? First possible consequence is stackoverflow due to infinite recursion. Second - unpredictable output and possible bugs. It's obvious that such situation must be controlled somehow. If we want predictable output for our logger, it should control double-entries:                   // ...         private bool enter;              public uint Debug(string message)         {             if (message == null) throw new ArgumentNullException("message");                  if (Writer == null) throw new InvalidOperationException("Writer not set");                  if (enter) throw new InvalidOperationException("Double-entry");                  enter = true;                  Writer.Write(string.Format("{0:HHmmss}: [DEBUG] {1}", DateTime.Now, message));                  enter = false;                  return ++counter;         }         // ...      And it seems that every external call (a call not to it's own components) must be wrapped with such flags. That looks crazy! Is it how good code written? Or is it normal to beleive that your system has no circular calls? Am I missing something important? Please, advise. **UPDATE** It's even worse, guys:                   // ...              private bool enter;              public uint Debug(string message)         {             if (message == null) throw new ArgumentNullException("message");                  if (Writer == null) throw new InvalidOperationException("Writer not set");                  if (enter) throw new InvalidOperationException("Double-entry");                  try             {                 enter = true;                      Writer.Write(string.Format("{0:HHmmss}: [DEBUG] {1}", DateTime.Now, message));             }             finally             {                 enter = false;             }                  return ++counter;         }         // ...      I beleive that catching an exception is on duty of higher-level module (the one which created them all), so exceptions must follow their way. But the state after unsuccessfull call must remain correct. Exception is not the end of the world, and modules possibly can be re-used.