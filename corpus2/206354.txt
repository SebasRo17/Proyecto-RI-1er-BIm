As far as I remember myself programming I was taught not to compare floating point numbers for equality. Now, while reading Programming in Lua about Lua `number` type, I found following: > The number type represents real (double-precision floating-point) numbers. > Lua has no integer type, as it does not need it. There is a widespread > misconception about floating-point arithmetic errors and some people fear > that even a simple increment can go weird with floating-point numbers. The > fact is that, when you use a double to represent an integer, there is no > rounding error at all (unless the number is greater than > 100,000,000,000,000). Specifically, a Lua number can represent any long > integer without rounding problems. Moreover, most modern CPUs do floating- > point arithmetic as fast as (or even faster than) integer arithmetic. Is that true for all languages? Basically if we don't go beyond floating point in doubles, we are safe in integer arithmetic? Or, to be more in line with question title, is there anything special that Lua does with its `number` type so it's working fine as both integer and float-point type?