In order to work with lists effectively using common recursive patterns from functional programming, it's often most convenient to worked with the "linked list" representation, that looks like this:               shortLinked = {a, {b, {c, {d, {}}}}};      At the end of the procedure, you can usually flatten it back out. However, it's possible that you may wish to map a function over it, the exact same way you'd use `Map` on a regular `List`. We would want a function that does the following:               mapLinked[f, shortLinked] === {f[a], {f[b], {f[c], {f[d], {}}}}}      We also want this to work with heads other than `List`, exactly like `Map`, because it's often convenient to use heads other than `List` to make a linked list:               shortLinkedCons = cons[d, cons[c, cons[b, cons[a, cons[]]]]]          mapLinked[f, shortLinkedCons] === cons[f[d], cons[f[c], cons[f[b], cons[f[a], cons[]]]]]      The function should be efficient; it's possible we could be working with lists that have tens of thousands of elements. It's also important that the function works if some of the elements of the list are themselves lists (i.e., have the same head as the linked list cells), so naively `Flatten`ing the list and then reconstituting it using `Fold` is not going to work. That is, the function must satisfy               mapLinked[f, {{6, 7}, {{3, 4, 5}, {{1, 2}, {}}}}] === {f[{6, 7}], {f[{3, 4, 5}], {f[{1, 2}], {}}}}      There are doubtless a lot of ways to solve this problem. What's the fastest? **EDIT** to add: It should also avoid going into an infinite loop if the list isn't terminated properly (with `{}` or some other `h[]` in the last tail position). **EDIT** again: For lists which are very long (tens of thousands of elements), a lot of approaches will bump up against `$RecursionLimit` or cause the kernel to crash due (presumably, to a stack overflow).