Not sure how to go about this method to reduce Cyclomatic Complexity. Sonar reports 13 whereas 10 is expected. I am sure nothing harm in leaving this method as it is, however, just challenging me how to go about obeying Sonar's rule. Any thoughts would be greatly appreciated.                public static long parseTimeValue(String sValue) {              if (sValue == null) {             return 0;         }              try {             long millis;             if (sValue.endsWith("S")) {                 millis = new ExtractSecond(sValue).invoke();             } else if (sValue.endsWith("ms")) {                 millis = new ExtractMillisecond(sValue).invoke();             } else if (sValue.endsWith("s")) {                 millis = new ExtractInSecond(sValue).invoke();             } else if (sValue.endsWith("m")) {                 millis = new ExtractInMinute(sValue).invoke();             } else if (sValue.endsWith("H") || sValue.endsWith("h")) {                 millis = new ExtractHour(sValue).invoke();             } else if (sValue.endsWith("d")) {                 millis = new ExtractDay(sValue).invoke();             } else if (sValue.endsWith("w")) {                 millis = new ExtractWeek(sValue).invoke();             } else {                 millis = Long.parseLong(sValue);             }                  return millis;              } catch (NumberFormatException e) {             LOGGER.warn("Number format exception", e);         }              return 0;     }      All ExtractXXX methods are defined as `static` inner classes. For example, like one below -                   private static class ExtractHour {           private String sValue;                public ExtractHour(String sValue) {              this.sValue = sValue;           }                public long invoke() {              long millis;              millis = (long) (Double.parseDouble(sValue.substring(0, sValue.length() - 1)) * 60 * 60 * 1000);              return millis;          }      }      * * * ## UPDATE 1 I am going to settle down with a mix of suggestions here to satisfy Sonar guy. Definitely room for improvements and simplification. Guava `Function` is just a unwanted ceremony here. Wanted to update the question about current status. Nothing is final here. Pour your thoughts please..               public class DurationParse {          private static final Logger LOGGER = LoggerFactory.getLogger(DurationParse.class);     private static final Map<String, Function<String, Long>> MULTIPLIERS;     private static final Pattern STRING_REGEX = Pattern.compile("^(\\d+)\\s*(\\w+)");          static {              MULTIPLIERS = new HashMap<>(7);              MULTIPLIERS.put("S", new Function<String, Long>() {             @Nullable             @Override             public Long apply(@Nullable String input) {                 return new ExtractSecond(input).invoke();             }         });              MULTIPLIERS.put("s", new Function<String, Long>() {             @Nullable             @Override             public Long apply(@Nullable String input) {                 return new ExtractInSecond(input).invoke();             }         });              MULTIPLIERS.put("ms", new Function<String, Long>() {             @Nullable             @Override             public Long apply(@Nullable String input) {                 return new ExtractMillisecond(input).invoke();             }         });              MULTIPLIERS.put("m", new Function<String, Long>() {             @Nullable             @Override             public Long apply(@Nullable String input) {                 return new ExtractInMinute(input).invoke();             }         });              MULTIPLIERS.put("H", new Function<String, Long>() {             @Nullable             @Override             public Long apply(@Nullable String input) {                 return new ExtractHour(input).invoke();             }         });              MULTIPLIERS.put("d", new Function<String, Long>() {             @Nullable             @Override             public Long apply(@Nullable String input) {                 return new ExtractDay(input).invoke();             }         });              MULTIPLIERS.put("w", new Function<String, Long>() {             @Nullable             @Override             public Long apply(@Nullable String input) {                 return new ExtractWeek(input).invoke();             }         });          }          public static long parseTimeValue(String sValue) {              if (isNullOrEmpty(sValue)) {             return 0;         }              Matcher matcher = STRING_REGEX.matcher(sValue.trim());              if (!matcher.matches()) {             LOGGER.warn(String.format("%s is invalid duration, assuming 0ms", sValue));             return 0;         }              if (MULTIPLIERS.get(matcher.group(2)) == null) {             LOGGER.warn(String.format("%s is invalid configuration, assuming 0ms", sValue));             return 0;         }              return MULTIPLIERS.get(matcher.group(2)).apply(matcher.group(1));     }          private static class ExtractSecond {         private String sValue;              public ExtractSecond(String sValue) {             this.sValue = sValue;         }              public long invoke() {             long millis;             millis = Long.parseLong(sValue);             return millis;         }     }          private static class ExtractMillisecond {         private String sValue;              public ExtractMillisecond(String sValue) {             this.sValue = sValue;         }              public long invoke() {             long millis;             millis = (long) (Double.parseDouble(sValue));             return millis;         }     }          private static class ExtractInSecond {         private String sValue;              public ExtractInSecond(String sValue) {             this.sValue = sValue;         }              public long invoke() {             long millis;             millis = (long) (Double.parseDouble(sValue) * 1000);             return millis;         }     }          private static class ExtractInMinute {         private String sValue;              public ExtractInMinute(String sValue) {             this.sValue = sValue;         }              public long invoke() {             long millis;             millis = (long) (Double.parseDouble(sValue) * 60 * 1000);             return millis;         }     }          private static class ExtractHour {         private String sValue;              public ExtractHour(String sValue) {             this.sValue = sValue;         }              public long invoke() {             long millis;             millis = (long) (Double.parseDouble(sValue) * 60 * 60 * 1000);             return millis;         }     }          private static class ExtractDay {         private String sValue;              public ExtractDay(String sValue) {             this.sValue = sValue;         }              public long invoke() {             long millis;             millis = (long) (Double.parseDouble(sValue) * 24 * 60 * 60 * 1000);             return millis;         }     }          private static class ExtractWeek {         private String sValue;              public ExtractWeek(String sValue) {             this.sValue = sValue;         }              public long invoke() {             long millis;             millis = (long) (Double.parseDouble(sValue) * 7 * 24 * 60 * 60 * 1000);             return millis;         }     }      } * * * ## UPDATE 2 Though I added my update, it is only that much worth the time. I am going to move on since Sonar now does not complains. Don't worry much and I am accepting the mattnz answer as it is the way to go and don't want to set a bad example for those who bumps on to this question. Bottom line -- Don't over engineer for the sake of Sonar (or Half Baked Project Manager) complains about CC. Just do what's worth a penny for the project. Thanks to all.