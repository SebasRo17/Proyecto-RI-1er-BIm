I've recently started with a new firm and I'm trying to understand the mechanics behind something, so I'll anonymize the code and present but a sample:               [Test(Description = "Retreives the New view for XXXX.")]     public void New()     {       "~/XXXX/New".ShouldMapTo<XXXXController>(x => x.New());       "~/XXXX/New".WithMethod(HttpVerbs.Post).ShouldMapTo<XXXXController>(x => x.New(null));     }      and again:               [Test(Description = "Test the model injection into the New view.")]     public void New()     {       var @new = WXYZController.New();       @new.AssertViewRendered();            Assert.IsInstanceOf<WXYZSettingsModel>(@new.ViewData.Model, "Expected the data model to be of type WXYZSettingsModel, but the model was another type.");       var model = @new.ViewData.Model as WXYZSettingsModel;       if (model == null)         Assert.Fail("Failed to cast data model to type WXYZSettingsModel.");              Assert.IsNotNull(model.YYYY, "Expected an instantiated service message, but a null message was returned.");         Assert.AreEqual(model.YYYY.Status, WXYZ.Success, "Expected a success status code, but another code was returned.");         Assert.IsNotNull(model.Categories, "");         Assert.AreEqual(model.ZZZZ.Status, ABCD.Success, "Expected a success status code, but another code was returned.");     }      It seems to me this violates the purpose of unit-testing, as you should never unit-test the framework, but rather, your own code, right? Did someone just get carried away? Or am I missing some fundamental component of this code that is just obvious to someone who is more familiar with unit testing. Note that there are entire files (one of each of the above per controller) that never test a single line of internal code, but are filled with these tests. Even to the point of this is fairly boilerplate now that I've anonymized it. If we were instead testing like this (pseudocode now)               [Test(Description = "thingy tester, duh")]     public void ThingTest(){       var mock = new MyDataMock();       var finalMock = new MyFinalMock();       var controller = new thingController();            var test = controller.Thing(mock);       assert.AreNotEqual(test,mock,"It didn't change it");       assert.AreEqual(test,finalMock,"It worked!");     }      I would expect that to be what the unit tests I should see should look like, no?