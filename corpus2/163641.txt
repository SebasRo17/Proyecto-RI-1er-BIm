My coworker and I have different opinions on the relationship between base classes and interfaces. I'm of the belief that a class should not implement an interface unless that class can be used when an implementation of the interface is required. In other words, I like to see code like this:               interface IFooWorker { void Work(); }          abstract class BaseWorker {         ... base class behaviors ...         public abstract void Work() { }         protected string CleanData(string data) { ... }     }          class DbWorker : BaseWorker, IFooWorker {         public void Work() {             Repository.AddCleanData(base.CleanData(UI.GetDirtyData()));         }     }      The DbWorker is what gets the IFooWorker interface, because it is an instantiatable implementation of the interface. It completely fulfills the contract. My coworker prefers the nearly identical:               interface IFooWorker { void Work(); }          abstract class BaseWorker : IFooWorker {         ... base class behaviors ...         public abstract void Work() { }         protected string CleanData(string data) { ... }     }          class DbWorker : BaseWorker {         public void Work() {             Repository.AddCleanData(base.CleanData(UI.GetDirtyData()));         }     }      Where the base class gets the interface, and by virtue of this all inheritors of the base class are of that interface as well. This bugs me but I can't come up with concrete reasons why, outside of "the base class cannot stand on its own as an implementation of the interface". What are the pros & cons of his method vs. mine, and why should one be used over another?