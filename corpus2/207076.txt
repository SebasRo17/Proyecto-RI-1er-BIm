There are n intervals given by starting (a[1], a[2], ..., a[n]) and ending points (b[1], b[2], ..., b[n]) and m queries of the form: given an integer x find the indices of the intervals which contain x. This can be written as S(x) = {k | 1 <= k <= n and a[k] <= x <= b[k]}. What is the fastest algorithm/data-structure (please, if possible, give references to implementation/documentation) to solve these queries? I'm positive that interval trees should solve the problem, but I'm not really sure on how should I approach the returning of the results. Until now, I could produce the following methods, but all seem quite slow.   * Naive approach: for each query go through all the intervals and see if the point is in the respective interval   * Sort the intervals by their starting point (and then ending point) and binary search for a lower bound on the starting point, then iterate to right checking the condition.