While this gives general pointers, I want inputs on **ground rules** for improved performance of nested/interdependent compiled functions. **sample problem:** `a`, `b`, `c`, and `d` are four supporting compiled functions that interact among themselves and also support the main function `main`, as defined below:               a = Compile[{{p1, _Real}, {p2, _Real}}, Min[p1, p2]];     b = Compile[{{p1, _Real}, {p2, _Real}}, Max[p1, p2]];     c = Compile[{{p1, _Real}, {p2, _Real}}, Min[1, 0.5 + a[p1, p2]/b[p1, p2]],             CompilationOptions -> {"InlineExternalDefinitions" -> True},          RuntimeAttributes -> {Listable},Parallelization -> True];     d = Compile[{{p1, _Real}, {p2, _Real}, {p3, _Real}}, a[Mod[p1, 5] - p2, p3],             CompilationOptions -> {"InlineExternalDefinitions" -> True},          RuntimeAttributes -> {Listable}, Parallelization -> True];          main = Compile[{{aa, _Real, 0}}, Module[{            k1 = RandomReal[10, {10^4, 5}],             k2 = RandomReal[5, {10^4, 5}],             k3 = RandomReal[15, {10^4, 5}]},             aa + b[k1, k2] + c[k2, k3] + d[k1, k2, k3]],             CompilationOptions -> {"InlineExternalDefinitions" -> True}];          Do[main[10],{100}];//AbsoluteTiming      I found that eliminating redundant options for dependent functions can help improve the performance; e.g. Since `a` and `b` are used in `c` and `c` is defined as listable and parallelized, 1) `a` and `b` need not be defined listable and defining them as listable may deteriorate the performance of `c` (using `AbsoluteTiming`) 2) since `a` and `b` are not defined `listable`, they can be inlined in `c` that will further improve performance, compared to using `"InlineExternalDefinitions" -> True` alone. With this understanding I want inputs to help establish ground rules that will enhance the **performance** of main:   1. Which functions need `CompilationOptions -> {"ExpressionOptimization" -> True}, RuntimeOptions -> "Speed"` and why not others?   2. Which functions need `CompilationTarger-> "C"` and why not others?   3. Since `main` calls `b`, `c` and `d` and already has `RuntimeAttributes -> {Listable}, Parallelization -> True`, none of the supporting functions should need to be listable, but it will not work. Why?   4. What else can be done to improve the performance of `main` (I need to use a compiled function in `NMinimizer`) ?