I am looking for an extension of `NDSolve` where integration runs until certain variables are settled at an equilibrium. Now I have a working solution in my sleeves but I would rather not show it yet, as I want answers to be unbiased and original, since I'm not convinced that my solution is optimal at all. Consider the following putative example (note that `EquilibriumNDSolve` is an undefined hypothetical function):               eqns = {        Derivative[1][a][t] == -a[t] - 0.2` a[t]^2 + 2.1` b[t],        Derivative[1][b][t] == a[t] + 0.1` a[t]^2 - 1.1` b[t],        a[0] == 0.5`,        b[0] == 0.5`        };          steps = {};          sol = EquilibriumNDSolve[eqns, {a, b}, {t, 0, 1000}, a + b,         EquilibriumThreshold -> 10^-5,         EquilibriumStepMonitor :> AppendTo[steps, t]        ];      This reads as: "numerically solve _eqns_ for _a_ and _b_ variables while _t_ goes from 0, until ( _a_ + _b_ ) is settled at an equilibrium. If no equilibrium is reached until _t_ = 1000", terminate. The solution should be a set of `{y.i -> InterpolatingFunction[...]}` (just like in case of `NDSolve`), and the result should be something like this:               Plot[Evaluate[{a[t], b[t]} /. sol], {t, 0, Last[steps]},       PlotStyle -> AbsoluteThickness[2], ImageSize -> 400,       GridLines -> {steps, {}}, GridLinesStyle -> {Dashed, GrayLevel[.7]}]      ![Mathematica graphics](http://i.stack.imgur.com/uyAsE.png) Vertical gridlines indicate positions where an equilibrium test was performed. The syntax and usage should vaguely work like this: > `EquilibriumNDSolve[eqns, {y1, y2, ...}, {t, t0, tmax}, z}]` numerically > solves the differential equation system _eqns_ for all variables $y_i$, with > independent variable _t_ running from $t_0$ to a maximum of $t_{max}$. > Iteration stops when variable _z_ settles at an equilibrium or no > equilibrium was found in the given range of _t_. Variable _z_ can be a > single variable, a list of variables, or any sensible combination of them, > e.g. $a+b$. `EquilibriumThreshold` should define a threshold value above which no equilibrium is registered. `EquilibriumStepMonitor` should work like `StepMonitor`: each time an equilibrium-test is performed, the _rhs_ of `EquilibriumStepMonitor :> func` is evaluated as well.