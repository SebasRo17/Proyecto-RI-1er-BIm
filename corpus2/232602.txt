In a moderately old blog post, Conal Elliot makes an interesting (if less than serious) argument that C is a purely functional language, by drawing a parallel between the combination of the C preprocessor and C itself, and that of Haskell's pure expression language and its impure IO action values. It's observed further down that the phase separation between C's components actually makes what `cpp` does quite different from Haskell, though, so `cpp+C` is not monadic after all. In real programming projects, C programmers prefer to minimize their use of `cpp` as far as possible. The macro language may be capable of amazing things, but it's a fairly hostile programming environment. So as far as I can tell this concept is mostly unexplored from a C perspective. However, building on the example of C, we could envisage a language where the primary way of programming is for the developer to write a purely functional program which _builds a fixed sequence_ of action values and strings them together into a finished program. Distinct from Haskell's model in that the functional program only exists at "compile time", with a clear separation between the two stages of evaluation and execution; distinct from C's model (or Lisp's) mainly in the emphasis on the "macro" stage as the _primary_ programming tool (and with a macro stage that isn't.. y'know, horrible - rather, it looks and runs like the full-fledged language), with the end program consisting of a fixed sequence of "action" building-blocks that the developer is discouraged (or even prevented) from authoring directly.   * Does this programming paradigm exist? If so, what is it called and what are existing examples of it? Is there any literature on this topic? ("Metaprogramming" is the obvious answer, but that seems too broad and off- target: `cpp` or C++ templates as they're currently lightly-used also fall under that, while Haskell IO doesn't.)