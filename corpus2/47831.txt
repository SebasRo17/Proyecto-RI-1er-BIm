The third listed syntax version of `LogitModelFit` allows one to specify input in a simple way: Only a design matrix (with a row of values of the explanatory input variables for each of the output values) and a response vector are needed. The following example is straight from the `LogitModelFit` help page:               dm = {{1, 1}, {1, 2}, {1, 3}, {1, 4}};     resp = {0, 1, 0, 1};     model = LogitModelFit[{dm, resp}]      ![Mathematica graphics](http://i.stack.imgur.com/ygo8s.png) As usual in these types of fits, Mathematica returns an object that can be interrogated with various methods. In this case, I just want to have the best fit:               model["BestFit"]      ![Mathematica graphics](http://i.stack.imgur.com/JXCUt.png) I noted something here that I feel is strange. Although this looks like a pure function (which is what I expected, given no formal variable names are specified in this syntax), it really isn't, since the required `&` at the end is missing. Hence, a construction like `model["BestFit"][1,2]` doesn't work. Is this a bug, or is this useful in some way and am I missing something? I note that neither the `"Function"` method of `LogitModelFit` nor something like `model//Normal` yields anything useful. The former generates an error which suggests to me that there is indeed a bug in this syntax variant. The latter returns the same as `"BestFit"`. My workaround for now is to use:               mod = model["BestFit"] // Evaluate // Function;      (`Evaluate` because of the `HoldAll` attribute of function)               mod[1, 2]      > 0.3883882668