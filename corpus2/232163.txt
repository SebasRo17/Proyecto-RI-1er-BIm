The typical programming designing method that I've come to use goes like this:               1. ID the problem and what's required     2. Make your program do something simple     3. Test it     4. Make your program do a little bit more     5. Repeat 2 until all the micro problems are solved by the program as a whole      Basically, incremental design. So, all the pieces can be split apart and each micro problem is solved by a micro problem function; does a great job with cohesion and reduces coupling. Then, sometime in the future, the program comes across a problem that is just like the problem it is built on, but requires a little extra. So, I'd say add the functionality to the program, to make up for it. If, when you're adding that functionality, the already established working logic has to be edited to make the new functionality work, it suddenly seems like you're messing with something you shouldn't. So, is there a designing method where every program developed with it can be added onto without compromising working logic? Example:               word = yes,no,"maybe,so"          oldCSVSplit(word, ",") -> {"yes", "no", "\"maybe", "so\""}     newCSVSplit(word, ",") -> {"yes", "no", "maybe,so"};      The oldCSVSplit function does what it should, split on ",". Then, sometime in the future, commas inside quotes must be ignored to properly get entries. Adding the functionality to ignore single/double quotes would severely alter the logic, with more ifs and checks and even a stack for keeping track of starting quotes. Is such a scenario avoidable? What method can make such additions painless and less compromising to working logic?