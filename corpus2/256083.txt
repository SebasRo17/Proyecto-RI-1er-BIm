I'm using Entity Framework with POCO's and change tracking enabled. I started off using CASCADE DELETE relationships, but in some situations, due to cyclic or multiple-possible-cascade-paths, SQL Server prevented me from adding CASCADE DELETE... so I need to manage those deletions myself. Take for example the following situation:   * A site has many chassis   * A chassis has many cards   * A card has many ports   * A link has two ports (`PortAId` and `PortZId`) (and a port may participate in multiple links). The first 3 relationships have CASCADE DELETE, however the final (`Link`) relationship has "multiple cascade path" on the `Link.PortAId` and `Link.PortZId` attributes. Because of this, I _couldn't_ add the CASCADE DELETE relationship. * * * My **problem** is that when a port gets deleted, a foreign key constraint gets thrown because there are still `Link`'s referencing the deleted port. * * * I tried looking through the `ChangeTracker` on `SaveChanges()` for `Port`s which were deleted, and deleting their respective links; _but_ a port deleted implicitly (through CASCADE DELETE) doesn't show up in the ChangeTracker; so I have to look for cards as well, and chassis, and sites... it becomes untenable. I then tried adding `TRIGGER`s to the database, such as:               CREATE TRIGGER delete_port_links ON Ports FOR DELETE AS        DELETE FROM Links WHERE PortAId IN (SELECT Id FROM deleted) OR PortZId IN (SELECT Id FROM deleted)      ... however `FOR` triggers fire _after_ the foreign key constraint has been checked (and failed). I can't use `INSTEAD OF`, because the table has a foreign key. * * * So I'm really stuck in terms of what direction to go down to solve this. What techniques, patterns or features of EF would allow me to detect when a Port (directly or implicitly) been deleted, such that I can delete the Links as well?