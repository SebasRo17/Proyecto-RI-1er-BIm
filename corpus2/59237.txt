Especially in tree-structured data, keys and values, being two sides of the same coin, frequently interchange roles. The ability to aggregate by value but not by key upsets the balance. How to improve on this workaround query - here defined only in operator form?               keyGroupBy[f_][expr_] :=  expr // AssociationMap[First[#] -> # &] // GroupBy[First /* f] //            Map[Values /* Association]      For example, given:                   data = Range[5] // AssociationMap[foo]          (* <|1 -> foo[1], 2 -> foo[2], 3 -> foo[3], 4 -> foo[4], 5 -> foo[5]|> *)      The desired output is:               data // keyGroupBy[PrimeQ]          (* <|False -> <|1 -> foo[1], 4 -> foo[4]|>,       True -> <|2 -> foo[2], 3 -> foo[3], 5 -> foo[5]|>|> *)       A fundamental constraint is that keys are transparent to functions accessing `Association`. Further, `Association` supports only data with unique keys. For example, `GroupBy` nested in `AssociationMap` will drop all but the last key- value pair with a given key.