I've been switching over to Java from C# after some recommendations from some over at CodeReview. So, when I was looking into LWJGL, one thing I remembered was that every call to `Display` must be executed on the same thread that the `Display.create()` method was invoked on. Remembering this, I whipped up a class that looks a bit like this.               public class LwjglDisplayWindow implements DisplayWindow {         private final static int TargetFramesPerSecond = 60;         private final Scheduler _scheduler;              public LwjglDisplayWindow(Scheduler displayScheduler, DisplayMode displayMode) throws LWJGLException {             _scheduler = displayScheduler;             Display.setDisplayMode(displayMode);             Display.create();         }              public void dispose() {             Display.destroy();         }              @Override         public int getTargetFramesPerSecond() { return TargetFramesPerSecond; }              @Override         public Future<Boolean> isClosed() {             return _scheduler.schedule(() -> Display.isCloseRequested());         }     }      While writing this class you'll notice that I created a method called `isClosed()` that returns a `Future<Boolean>`. This dispatches a function to my `Scheduler` interface (which is nothing more than a wrapper around an `ScheduledExecutorService`. While writing the `schedule` method on the `Scheduler` I noticed that I could either use a `Supplier<T>` argument _or_ a `Callable<T>` argument to represent the function that is passed in. `ScheduledExecutorService` didn't contain an override for `Supplier<T>` but I noticed that the lambda expression `() -> Display.isCloseRequested()` is actually type compatible with both `Callable<bool>` **and** `Supplier<bool>`. My question is, is there a difference between those two, semantically or otherwise - and if so, what is it, so I can adhere to it?