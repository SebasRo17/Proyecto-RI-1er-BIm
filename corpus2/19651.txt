I have a symbolic expression that represents a set of operators. These operators have quite a bit of symmetry to simplify expressions:               A[{1,2},{3,4}]==A[{3,2},{1,4}]==A[{1,4},{3,2}]==A[{3,4},{1,2}]     S[{1},{2}]==S[{2},{1}]      I will use the first term of the series to denote positions.               3->"d"     A[{1,2},{"d",4}]      So for example:               In:     temporary=S[{1}, {2}]*v[{1, 2}, {3, 4}]      + S[{2}, {1}]*v[{3, 2}, {1, 4}]      + S[{2}, {1}]*v[{3, 4}, {1, 2}]          Out:     3*S[{1},{2}]*A[{1, 4}, {3, 2}]      At current I simply have replacement rules that move indices in a logical way for example:               temporary//.{     x_[{x1_, x2_}, {x3_, x4_}] /; (!condition[x1,x3]) :> v[{x3, x2}, {x1, x4}]     }          (*Condition is a statement that checks the order of indices, for example       if x1="b" and x3="a" it would return false and so the expression would be      reordered so that "a" is now in position 1 and "b" in position 3.*)      It seems if there has to be a better way to do this. Bonus: Is there a simple way to find the original of a unique value. Say `Unique[a]=a$532 unUnique[a$543]=a`.