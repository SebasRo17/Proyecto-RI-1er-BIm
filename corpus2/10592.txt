I need to solve a sequence of equations and I want the starting point of each new FindRoot to be the solution of the earlier FindRoot, increased or decreased by a a bit in the following way: Some data               d={..,.,...}      Step1: Solve for counter c =100,                {x100,y100}={x,y}/.FindRoot[{f1(x,y,c,d[[c]])==0,f2(x,y,c,d[[c]])==0},{x,a100},{y,b100}]      Step2: Solve for counter c =99                {x99,y99}={x,y}/.FindRoot[{f1(x,y,c,d[[c]])==0,f2(x,y,c,d[[c]])==0},{x,a99},{y,b99}]      The starting points $(a100,b100)$ and $(a99,b99)$ are something I find by trial and error. Step3: For counter c=98,               a98 = x99 + x99-x100;     b98 = y99 + y99-y100;      I know that my roots are monotonic in $c$, therefore I want my new start point to be the previous solution perturbed by how much more or less the previous solution was relative to the solution before that. Finally when I have all my solutions, I would like to store them as a list so I could do more math with them. I already know how to use Table and feed in the previous solution as the new start point.                d = {0.5, 0.4, 0.5, 0.4, 0.5};     sol = {0.9, 0.4};     Table[sol={x,y}/.FindRoot[{x^2+y^2==a,x-y==d[[a]]},{x,sol[[1]]},{y,sol[[2]]}], {a,1,5}]      But I don't know enough about Mathematica Loop commands to figure out how to use the previous solution + the difference between the previous solution and the one before that, as the start point. Also, I don't know when the counter should stop. I'd like for the counter to stop when the solutions first hit a particular region. For example: Stop when $-4 <x < y < 0.1$ or if counter $c = 0$. So basically, I'd like my loop stopping condition to be some function of the counter and/or all the roots calculated so far. Suppose more complicated stopping conditions are hard to figure out, I'd appreciate it if someone to tell me how run a loop with simple stopping conditions like $x<0.1$ unless ofcourse $c=0$. _**EDIT(New stuff):Below is an implementation of Kguler's solution method_** Ok, following Kgluer's comments, I have tried to mimic what he has suggested and it is sort of working but I am not entirely sure of what's going on and I wanna be absolutely certain that I am error free before I implement it on my actual problem. Ok here goes:               f = Table[{x + y == a*a, x - y == 0}, {a, 1, 5}]          ContourPlot[Evaluate[f], {x, 0, 25}, {y, 0, 25}]      ![enter image description here](http://i.stack.imgur.com/SZhhW.jpg) I want to give my FindRoot a start point of $(0,0)$ and a start distance of $(0.5,0.5)$ to look for the first solution when $a=1$. Then when it computes the solution as $(0.5,0.5)$, I want it to look for the next solution, for $a=2$, near the first solution $(0.5,0.5)$+the difference between the first solution and the previous start point$(0.5,0.5)-(0,0)$. So it should look for solutions near $(1,1)$ when $a=2$ and so on and so forth. The parameter $d$ below is superfluous for this problem but I just threw it in there because in my actual problem, $d$ like data shows up non-trivially.               d = {0, 0, 0, 0, 0};     sol = {0, 0};     add = {0.5, 0.5}     counter = 5;          data = NestWhileList[{#[[1]] + 1,{x, y} = {x, y} /.       FindRoot[{x + y == #[[1]]*#[[1]], x - y == d[[#[[1]]]]}, {x, #[[2]][[1]] + #[[3]]  [[1]]}, {y, \#[[2]][[2]] + #[[3]][[2]]}],     {x - #[[2]][[1]], y - #[[2]][[2]]}} &,{1, sol, add},Not[2 < #[[2]][[2]] < #[[2]][[1]] < 3] &, 2, counter]      This code gives the following output.               {{1, {0, 0}, {0.5, 0.5}}, {2, {0.5, 0.5}, {0.5, 0.5}}, {3, {2., 2.}, {1.5, 1.5}}, {4, {4.5, 4.5}, {2.5, 2.5}}, {5, {8., 8.}, {3.5, 3.5}}, {6, {12.5, 12.5}, {4.5, 4.5}}}      So it looks like it is doing what I want it to do.. but I still don't fully understand many thing. Like what would change if I altered the 4th input of NestWhileList from 2 to 3? Or how NestWhileList test function knows to look at the counter. I am sure there are more things I don't understand so any help with writing good code and explanations will be greatly appreciated. Thanks.