When doing table driven predictive parsing on an LL(1) grammar, (as explained in good detail here for example), how can we augment the algorithm to allow processing of semantic actions while doing the parsing. One technique could possibly use the same stack in the algorithm by defining the production rules with markers for the semantic actions, and pushing these markers on the stack the same way it's done with terminals/non-terminal in the rest of the production rule, and then processing the code designated by the marker when it gets popped out of the stack. So given something like this (from the Dragon book - actions in curly braces):               rest -> + term { print('+') } rest           | - term { print('-') } rest           | Epsilon          term -> 0 { print('0') }           | 1 { print('1') }           ...           | 9 { print('9') }      We can add a marker for each type of action, and push it in on the stack with the rest of the production terms, and then execute the corresponding code when the marker is popped out by the algorithm. Is this how this is done or is there better approaches?