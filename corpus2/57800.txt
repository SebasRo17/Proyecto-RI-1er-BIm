I'm trying to build a Verbose option into some code but I'm having trouble passing to a `Quiet` statement a variable list of which messages I want to suppress. My naÃ¯ve try is code along the lines of               f[x_] := Module[{messageList},       messageList = {Power::infy};       Quiet[1/x, messageList]       ]     f[0]      The idea would then be to build an option `Verbose` which controls whether the assignment `messageList = {Power::infy}` is made, or whether that variable is set to `{}`, which will let the message through. However, even this bare-bones code is not working, and it returns messages of the sort               Quiet::anmlist: Argument 2 of Quiet[1/0,messageList$1303]           should be All, None, a message name, or a list of message names. >>      (though obviously the number after `messageList$` changes every time). * * * ### Edit It seems, from a discussion in the comments, that two things are important (though I don't understand why). First of all, not all error messages are treated equally (as shown e.g. by running `Evaluate[{Power::infy, FindRoot::lstol}]`) so to give a better example, here is one with the error I'm interested in, `FindRoot::lstol`:               g[a_] := Module[{verbose = True, messageList},       If[verbose,        messageList = {},        messageList = {FindRoot::lstol}        ];       Quiet[        FindRoot[x^2 + x + a, {x, 3}]        , messageList]       ]     g[1]      It is also important to me to be able to control, from within the function (and eventually with an `OptionsPattern[]` that contains `Verbose->True` or `False`) whether the message list that gets passed is `{}` or a nontrivial one. I'm not picky about how it gets there (i.e. `messageList = If[verbose, {}, {FindRoot::lstol}];` would serve just fine) but it does need to have at least that level of logic built in. * * * What is the correct way to do this?