I've been trying to think of a way of declaring strongly typed typedefs, to catch a certain class of bugs in the compilation stage. It's often the case that I'll typedef an int into several types of ids, or a vector to position or velocity:               typedef int EntityID;     typedef int ModelID;     typedef Vector3 Position;     typedef Vector3 Velocity;      This can make the intent of code more clear, but after a long night of coding one might make silly mistakes like comparing different kinds of ids, or adding a position to a velocity perhaps.               EntityID eID;     ModelID mID;          if ( eID == mID ) // <- Compiler sees nothing wrong     { /*bug*/ }               Position p;     Velocity v;          Position newP = p + v; // bug, meant p + v*s but compiler sees nothing wrong      Unfortunately, suggestions I've found for strongly typed typedefs include using boost, which at least for me isn't a possibility (I do have c++11 at least). So after a bit of thinking, I came upon this idea, and wanted to run it by someone. First, you declare the base type as a template. The template parameter isn't used for anything in the definition, however:               template < typename T >     class IDType     {         unsigned int m_id;              public:             IDType( unsigned int const& i_id ): m_id {i_id} {};             friend bool operator==<T>( IDType<T> const& i_lhs, IDType<T> const& i_rhs );     };      Friend functions actually need to be forward declared before the class definition, which requires a forward declaration of the template class. We then define all the members for the base type, just remembering that it's a template class. Finally, when we want to use it, we typedef it as:               class EntityT;     typedef IDType<EntityT> EntityID;     class ModelT;     typedef IDType<ModelT> ModelID;      The types are now entirely separate. Functions that take an EntityID will throw a compiler error if you try to feed them a ModelID instead, for example. Aside from having to declare the base types as templates, with the issues that entails, it's also fairly compact. I was hoping anyone had comments or critiques about this idea? One issue that came to mind while writing this, in the case of positions and velocities for example, would be that I can't convert between types as freely as before. Where before multiplying a vector by a scalar would give another vector, so I could do:               typedef float Time;     typedef Vector3 Position;     typedef Vector3 Velocity;          Time t = 1.0f;     Position p = { 0.0f };     Velocity v = { 1.0f, 0.0f, 0.0f };          Position newP = p + v*t;      With my strongly typed typedef I'd have to tell the compiler that multypling a Velocity by a Time results in a Position.               class TimeT;     typedef Float<TimeT> Time;     class PositionT;     typedef Vector3<PositionT> Position;     class VelocityT;     typedef Vector3<VelocityT> Velocity;          Time t = 1.0f;     Position p = { 0.0f };     Velocity v = { 1.0f, 0.0f, 0.0f };          Position newP = p + v*t; // Compiler error      To solve this, I think I'd have to specialize every conversion explicitly, which can be kind of a bother. On the other hand, this limitation can help prevent other kinds of errors (say, multiplying a Velocity by a Distance, perhaps, which wouldn't make sense in this domain). So I'm torn, and wondering if people have any opinions on my original issue, or my approach to solving it.