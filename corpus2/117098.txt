Thinking about Kanban, I realized that the queuing-theory behind the SW- development-methodology obviously also applies to concurrent software. Now I'm looking for whether this kind of thinking is explicitly applied in some area. A simple example: We usually want to limit the number of threads to avoid cache-thrashing (WIP-Limits). In the paper about the disruptor pattern[1], one statement that I found interesting was that producer/consumers are rarely balanced so when using queues, either consumers wait (queues are empty), or producers produce more than is consumed, resulting in either a full capacity-constrained queue or an unconstrained one blowing up and eating away memory. Both, in lean-speak, is waste, and increases lead-time. Does anybody have examples of WIP-Limits, reducing/eliminating queues, pull or single piece flow being applied in programming? http://disruptor.googlecode.com/files/Disruptor-1.0.pdf