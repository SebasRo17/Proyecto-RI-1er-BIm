I have a very simple question about redefining basic built-in functions, such as `Plus`. I'm pretty sure someone must have asked a similar question around here, but I couldn't find one. Consider the following code:               Unprotect[Plus];     x_ + y_ := x y     Protect[Plus];      For symbols this works as expected:               x+y     (* ---> x y *)      For numbers, however, the new definition does not work:               1+2     (* ---> 3 *)      Of course I know that it is stupid to use something like this and that defining functions or using upvalues etc. is the way to go here, but I'm really interested in why this happens. Can the pattern for `Plus` be defined in such a way that it works for numbers as well? Is `Plus[1,2]` evaluated internally _before_ the pattern can be matched?