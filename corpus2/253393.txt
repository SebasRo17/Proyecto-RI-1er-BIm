Im trying to use framebuffer objects to render into textures. In my code below, I have a framebufferobject with 2 textures and one depth buffer attached to it. My aim is to render a colored cube with front and back face culled for two textures. Later I will use these as inputs into fragment shader program named in my code "shaderProgramFinal". However I could not been able to render both back culled and front culled version at the two textures. They either become back culled or front face culled version simultaneously. I want frontTex contain back culled and backTex contain front culled version. Can anyone help me where Im wrong in my code below?               #include <GL/glew.h>     #include <GLFW/glfw3.h>     #include <stdlib.h>     #include <stdio.h>     #include "Shader.hpp"     #include "ShaderProgram.hpp"     #include <math.h>     #include <glm/glm.hpp>     #include <glm/gtc/matrix_transform.hpp>     #include <glm/gtc/type_ptr.hpp>     #include <glm/gtx/euler_angles.hpp>          #define screenSizeX 500     #define screenSizeY 500          GLFWwindow* window;          static void error_callback(int error, const char* description){fputs(description, stderr);}          void glSetup(){     glfwInit();     glfwSetErrorCallback(error_callback);     glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);     glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,4);     glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,0);     glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);     glfwWindowHint(GLFW_RESIZABLE,GL_FALSE);     window = glfwCreateWindow(screenSizeX, screenSizeY, "Graphics World", NULL, NULL);     glfwMakeContextCurrent(window);     glewExperimental = GL_TRUE;     glewInit();     printf ("Renderer: %s\n", glGetString (GL_RENDERER));     printf ("OpenGL version supported %s\n", glGetString (GL_VERSION));     glEnable (GL_DEPTH_TEST);     glDepthFunc (GL_LESS);     }          void shaderSetup(Shader* vertexShader, Shader* fragmentShader, ShaderProgram* shaderProgram){     vertexShader->loadFromFile("myVert.S");     vertexShader->compile();     fragmentShader->loadFromFile("myFrag.S");     fragmentShader->compile();     shaderProgram->attachShader(*vertexShader);     shaderProgram->attachShader(*fragmentShader);     shaderProgram->linkProgram();     shaderProgram->addAttribute("Position");     shaderProgram->addAttribute("ColorC");     shaderProgram->addUniform("rotateMatrixX");     shaderProgram->addUniform("rotateMatrixY");     shaderProgram->addUniform("rotateMatrixZ");     }          void shaderSetupFinal(Shader* vertexShader, Shader* fragmentShader, ShaderProgram* shaderProgram){     vertexShader->loadFromFile("myVertFinal.S");     vertexShader->compile();     fragmentShader->loadFromFile("myFragFinal.S");     fragmentShader->compile();     shaderProgram->attachShader(*vertexShader);     shaderProgram->attachShader(*fragmentShader);     shaderProgram->linkProgram();     shaderProgram->addAttribute("Position");     }          int main(void)     {     glSetup();          Shader vertexShader(GL_VERTEX_SHADER);     Shader fragmentShader(GL_FRAGMENT_SHADER);     ShaderProgram* shaderProgram = new ShaderProgram();     shaderSetup(&vertexShader, &fragmentShader, shaderProgram);          Shader vertexShaderFinal(GL_VERTEX_SHADER);     Shader fragmentShaderFinal(GL_FRAGMENT_SHADER);     ShaderProgram* shaderProgramFinal = new ShaderProgram();     shaderSetupFinal(&vertexShaderFinal, &fragmentShaderFinal, shaderProgramFinal);          float vertices[] = {     -0.5f,  0.5f, -0.5f, 0.0f, 1.0f, 0.0f, //Green0     -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, //Black1      0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, //Red2      0.5f,  0.5f, -0.5f, 1.0f, 1.0f, 0.0f, //Yellow3     -0.5f,  0.5f, 0.5f, 0.0f, 1.0f, 1.0f, //Cyan4     -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, //Blue5      0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 1.0f, //Magenta6      0.5f,  0.5f, 0.5f, 1.0f, 1.0f, 1.0f //White7     };          GLuint elements[] = {     2,0,3,     2,1,0,     6,4,5,     6,7,4,     3,4,7,     3,0,4,     2,6,5,     2,5,1,     2,3,7,     2,7,6,     1,5,4,     1,4,0     };          float verticesFinal[] = {     -1.0f, -1.0f, 0.0f,      1.0f, -1.0f, 0.0f,      1.0f,  1.0f, 0.0f,     -1.0f,  1.0f, 0.0f     };          GLuint elementsFinal[] = {     0,1,3,     1,2,3     };          GLuint VAO, VBO, EBO, backTex, frontTex, frameBuffer, renderBuffer, VAOFinal, VBOFinal, EBOFinal;          glGenVertexArrays(1, &VAO);     glBindVertexArray(VAO);          glGenBuffers(1, &VBO);     glBindBuffer(GL_ARRAY_BUFFER, VBO);     glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);     glEnableVertexAttribArray(shaderProgram->attribute("Position"));     glVertexAttribPointer (shaderProgram->attribute("Position"), 3, GL_FLOAT, GL_FALSE, 6*sizeof(GLfloat), NULL);     glEnableVertexAttribArray(shaderProgram->attribute("ColorC"));     glVertexAttribPointer (shaderProgram->attribute("ColorC"), 3, GL_FLOAT, GL_FALSE, 6*sizeof(GLfloat),  (void*)(3 * sizeof(GLfloat)));          glGenBuffers(1, &EBO);     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);     glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(elements), elements, GL_STATIC_DRAW);          glGenTextures(1, &backTex);     glBindTexture(GL_TEXTURE_2D, backTex);     glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, screenSizeX, screenSizeY, 0, GL_RGBA, GL_FLOAT, NULL);     glBindTexture(GL_TEXTURE_2D, 0);          glGenTextures(1, &frontTex);     glBindTexture(GL_TEXTURE_2D, frontTex);     glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, screenSizeX, screenSizeY, 0, GL_RGBA, GL_FLOAT, NULL);     glBindTexture(GL_TEXTURE_2D, 0);          glGenFramebuffersEXT(1, &frameBuffer);     glGenRenderbuffersEXT(1, &renderBuffer);     glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, frameBuffer);     glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, backTex, 0);     glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, frontTex, 0);          glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, renderBuffer);     glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT, screenSizeX, screenSizeY);     glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, renderBuffer);     GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER_EXT);     if(status != GL_FRAMEBUFFER_COMPLETE) cout << "Frame buffer yokki!\n";     glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);          glGenVertexArrays(1, &VAOFinal);     glBindVertexArray(VAOFinal);          glGenBuffers(1, &VBOFinal);     glBindBuffer(GL_ARRAY_BUFFER, VBOFinal);     glBufferData(GL_ARRAY_BUFFER, sizeof(verticesFinal), verticesFinal, GL_STATIC_DRAW);     glEnableVertexAttribArray(shaderProgramFinal->attribute("Position"));     glVertexAttribPointer(shaderProgramFinal->attribute("Position"), 3, GL_FLOAT, GL_FALSE, 3*sizeof(GLfloat), NULL);          glGenBuffers(1, &EBOFinal);     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBOFinal);     glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(elementsFinal), elementsFinal, GL_STATIC_DRAW);          while (!glfwWindowShouldClose(window))     {         double mouseX, mouseY;         glfwGetCursorPos(window, &mouseX, &mouseY);         mouseX -= screenSizeX/2;         mouseY -= screenSizeY/2;              shaderProgram->use();         glBindVertexArray(VAO);         glUniformMatrix4fv(shaderProgram->uniform("rotateMatrixX"), 1, GL_FALSE,       glm::value_ptr(glm::eulerAngleX((float)(mouseY/25.0))));         glUniformMatrix4fv(shaderProgram->uniform("rotateMatrixY"), 1, GL_FALSE, glm::value_ptr(glm::eulerAngleY((float)(-mouseX/25.0))));         glUniformMatrix4fv(shaderProgram->uniform("rotateMatrixZ"), 1, GL_FALSE, glm::value_ptr(glm::eulerAngleY((float)(0.0/50.0))));              glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, frameBuffer);         glBindTexture(GL_TEXTURE_2D, backTex);         glBindTexture(GL_TEXTURE_2D, frontTex);              glActiveTexture(GL_TEXTURE0);         glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );         glEnable(GL_CULL_FACE);         glCullFace(GL_FRONT);         glDrawElements (GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);         glDisable(GL_CULL_FACE);              glActiveTexture(GL_TEXTURE1);         glDrawBuffer(GL_COLOR_ATTACHMENT1_EXT);         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );         glEnable(GL_CULL_FACE);         glCullFace(GL_BACK);         glDrawElements (GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);         glDisable(GL_CULL_FACE);              glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);              shaderProgram->disable();              shaderProgramFinal->use();         glBindVertexArray(VAOFinal);         glEnable(GL_CULL_FACE);         glCullFace(GL_BACK);         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );         glDrawElements (GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);         glDisable(GL_CULL_FACE);         shaderProgramFinal->disable();              glfwSwapBuffers(window);         glfwPollEvents();     }          glfwDestroyWindow(window);     glfwTerminate();     exit(EXIT_SUCCESS);     }