I have an `AuthenticationManager.authenticate(username,password)` method that gets called in someMethod of a SomeService under test. The AuthenticationManager is injected into SomeService:               @Component     public class SomeService {         @Inject         private AuthenticationManager authenticationManager;              public void someMethod() {             authenticationManager.authenticate(username, password);             // do more stuff that I want to test         }     }      Now for the unit test I need the authenticate method to just pretend it worked correctly, in my case do nothing, so I can test if the method itself does the expected work (Authentication is tested elsewhere according to the unit testing principles, however authenticate needs to be called inside that method) So I am thinking, I need `SomeService` to use a mocked `AuthenticationManager` that will just return and do nothing else when `authenticate()` gets called by `someMethod()`. How do I do that with PowerMock (or EasyMock / Mockito, which are part of PowerMock)? Or is there another way to tell Spring to use some Mock instead of the real deal, when injeeting the `AuthenticationManager` into `SomeService`? Or is my design wrong? Thanks! * * * **Edit - found a solution, would like to hear comments** So I found a nice way to inject a mock without having to use a setter or package level:               @RunWith(PowerMockRunner.class)     public class TestOrderService {              @Mock         private AuthenticationManager authenticationManager;              @InjectMocks          private OrderService orderService = new OrderService();              @Before         public void setup() {             MockitoAnnotations.initMocks(this);             Mockito.doNothing().when(this.authenticationManager).authenticate(null, null);         }              @Test         public void testOrderService() {             orderService.save(null, null, null);         }     }      with OrderService like this:               public void save(String username, Order order) {         authenticationManager.authenticate(username, password);         // do something with the order...     }      Now the save method will call authenticate on the mock and the mock does nothing leaving me free to test the actual work inside my service method (which actually is calling a manager method but that was not the point ;) )