Does this `IConvertible` interface satisfy the Interface Segregation Principle (ie. the "I" in SOLID)? Here is the definition:               public interface IConvertible     {         TypeCode GetTypeCode();          bool ToBoolean(IFormatProvider provider);         byte ToByte(IFormatProvider provider);         char ToChar(IFormatProvider provider);         DateTime ToDateTime(IFormatProvider provider);         decimal ToDecimal(IFormatProvider provider);         short ToInt16(IFormatProvider provider);         int ToInt32(IFormatProvider provider);         long ToInt64(IFormatProvider provider);         sbyte ToSByte(IFormatProvider provider);         float ToSingle(IFormatProvider provider);         string ToString(IFormatProvider provider);         object ToType(Type conversionType, IFormatProvider provider);         ushort ToUInt16(IFormatProvider provider);         uint ToUInt32(IFormatProvider provider);         ulong ToUInt64(IFormatProvider provider);     }      So if I would like to have a class which will implements this `IConvertible` interface the I have to implement all of those methods, right? Or if I don't implement all of them, then I have to at least make an empty method or throw an Exception, right?. In my opinion, the better way is to make more interface with fewer methods, for example:               public interface IConvertibleInt     {             short ToInt16(IFormatProvider provider);             int ToInt32(IFormatProvider provider);             long ToInt64(IFormatProvider provider);     }      Or even:               public interface IConvertibleInt16     {             short ToInt16(IFormatProvider provider);     }          public interface IConvertibleInt32     {                         int ToInt32(IFormatProvider provider);     }          public interface IConvertibleInt64     {             long ToInt64(IFormatProvider provider);     }      Is my reasoning correct?