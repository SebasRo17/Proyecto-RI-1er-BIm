I know of Interfaces, Abstract classes that serve as Base class, I've been reading up on loose coupling, ... But I can't come up with a decent solution when a property of a class changes, and the new type needs to be implemented in other classes using this updated class. **Example** Below is a simplified representation of a real life situation. Invoice contains a Contact object which has an Address property.               Abstract Class Contact{         string Name{get;set;}         string Address{get;set;}     }                    Class Customer:Contact{         string CustomerNumber{get;set;}     }                    Class Invoice{         string DocumentNumber{get;set;}         Customer Customer{get;set;}     }      Next, we decide to upgrade the Contact class to contain multiple Addresses. Of which the Invoice will need one.               Class Address{         string Street{get;set;}     }                    Abstract class Contact{         string Name{get;set;}         List<Address> Addresses{get;set;}     }      Logically, the Invoice class needs to be changed to something like               Class Invoice{         string DocumentNumber{get;set;}         Customer Customer{get;set;}         Address InvoiceAddress{get;set;}     }      **Problem** You immediately see that _everywhere_ I used the **string** property `Address` before, I will now have to change it to an occurence of the type **Address** As stated before, this is just a simplified example. The real life problem would be much, much bigger as contacts will be used throughout the entire software. **Conclusion** I want to develop the software with a principle that will keep my software light for new versions of certain modules. So that if I decide to create a new Contact module, the impact to the other modules is close to non-existing. So, the added functionality can be implemented gradually. I want to know how I can tackle such versioning problems. This project is currently still in the architectural design stage, and I want this sorted out before we continue.