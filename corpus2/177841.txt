I am working on refactoring an old simulation of a Turing machine. The application uses a class that contains the state and the logic of program execution, and several panels to display the tape representation and show the state, messages, and the GUI controls (start, stop, program listing, ...). I would like to refactor it using the MVC architecture that was not used originaly: the Frame is the only way to get access to the different panels and there is also a strong coupling between the "engine" class and the GUI updates in the way of `frame.displayPanel.state.setText("halted");` or `frame.outputPanel.messages.append("some thing");` It looks to me that I should put the state related code into an observable model class and make the different panels observers. My problem is that the java Observable class only provides a global notification to the Observers, while I would prefer not to refresh every Observers everytime, but only when the part that specificaly observe has changed.   * I am thinking of implementing myself several vectors of listeners (for the state / position, for the output messages, ...) but I feel like reinventing the wheel.   * I though also about adding some flags that the observers could check like `isNewMessageAvailable()`, `hasTapeMoved()`, etc but it sounds also approximative design. BTW, is it ok to keep the fetch / execute loop into the model or should I move it in another place? We can think in a theorical ideal way as I am completely revamping this small application.