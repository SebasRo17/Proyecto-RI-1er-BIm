When writing an OpenCL kernel, calls to `get_global_id()` are used to determine the "position" within the problem that a particular instance of the kernel is working on. However, I'm confused about how the dimensionality of a problem is specified or determined to begin with. I can write simple kernels that do the right thing, but I don't know _why_ they're doing the right thing! When moving to more complex kernels to do real work, I'm going to need to understand what's actually happening. Am I right in saying that if a kernel takes $n$ arguments that are qualified as `__global`, then I can call `get_global_id(0)`, â€¦, `get_global_id(` $n-1$ `)`? Am I further correct in saying that each `__global` argument is treated as a one-dimensional array and that Mathematica runs one kernel (i.e., one OpenCL thread) for each element of the longest such array (but that I can specify the number of threads as the last argument to the Mathematica function created by `OpenCLFunctionLoad` if I want to control the dimensionality of the problem)? Assuming this, and $k$ threads, presumably values returned by `get_global_id(0)` will range from 0 to $k-1$; but if so, what values could `get_global_id(1)`, `get_global_id(2)`, etc. take? How can this be specified when running a kernel via the OpenCLLink Mathematica functions? Alternatively, does Mathematica look at the dimensionality of the largest `__global` argument, somehow pass this to the underlying OpenCL, such that `get_global_id(0)` return values that index the first dimension of this argument, `get_global_id(1)` return values that index the second dimension of this same argument, and so on? If this is the case, how do I specify the dimensionality of the problem when running a Mathematica function created by `OpenCLFunctionLoad`? So, in short, how is the dimensionality of a problem specified and what values can be taken by `get_global_id(`$i$`)`? Many thanks in advance.