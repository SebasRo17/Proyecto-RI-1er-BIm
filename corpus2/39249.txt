Consider               Fold[f,z,{a,b,c}]     ==> f[f[f[z,a],b,c]]      I'm looking for a way to write this (in general) using `Map` or `MapThread` (and perhaps `Flatten[#,1]&`, thinking of monadic `bind` a-la Haskell), and not using mutable variables. In other words, the following is too easy:               Module[{result = z},       Map[v \[Function]         result = f[result, v],        {a, b, c}]] // Last      and the following is not even wrong:               MapThread[f, {{z, f[z, a], f[f[z, a], b]}, {a, b, c}}] // Last      and the following is even more not even wrong (invoking Haskell's state monad); although it could be written recursively to be more general, the recursive form would just be a simulacrum of `Fold` with more functional garbage around the binding functions:               return[v_] := s \[Function] {v, s};     bind[m_, fv2m_] := s \[Function]       With[{vs0 = m[s]},         With[{          v0 = vs0[[1]],          s0 = vs0[[2]]},         fv2m[v0][s0]]]          bind[       bind[         bind[          return[z],          v \[Function] return[f[v, a]]],         v \[Function] return[f[v, b]]],        v \[Function] return[f[v, c]]][z] // First      I'm beginning to think that `Fold` is its own critter, kind of a state-monad- in-disguise, inherently recursive, and not representable by `Map` and friends, which are inherently iterative. But I haven't yet been able to prove that it's not possible, even though I haven't found a solution. Anyone happen to know? EDIT: the reason I'm looking for this is so I can build a reactive version around the Observable/Observer pattern, which is formally dual to the Iterable/Iterator pattern, and replaces `Map` with `Subscribe`, sort-of. I do not know a reactive partner to `Fold`, and that's the ultimate objective.