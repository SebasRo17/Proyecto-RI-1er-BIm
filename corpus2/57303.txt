I'm trying to define a function that takes an expression and spits out a pure function involving a replacement rule of that function's variable. An example would be a function `f` such that `f[x^2]` returns `x^2 /. x -> # &` (let's just stick with single-variable function for simplicity's sake). I have written 2 functions, both aim to do just that. Now, their pure function outputs do work when applied to something else (see last input of block code), but they themselves don't display in the form that I'd like:               (* 1 *)         Clear[f1]     f1[expr_] := Module[{var},       var = First@Variables[expr];       expr /. var -> # &]          f1[x^2]     (* x^2 /. var$77097 -> #1 & *)               (* 2 *)     Clear[f2]     f2[expr_] := expr /. First@Variables[expr] -> # &          f2[x^2]     (* x^2 /. First[Variables[x^2]] -> #1 & *)               {f1[x^2][3], f2[x^2][3]}     (* {9, 9} *)      It seems like `Rule` holds the evaluation of the left hand side, which I don't really know why. Adding `Evaluate` to the left hand side did not help. I tried reading the documentation for `Rule` but couldn't find any relevant information on this behavior. One of its attributes is `SequenceHold`. Could that be a contribution? Also, if anyone could help me understand the result I got for each of those modules I'd really appreciate it. I'm very fuzzy on evaluation order inside `Rule` and `Module`. Lastly, how can I build such a function mentioned in the beginning of my question?