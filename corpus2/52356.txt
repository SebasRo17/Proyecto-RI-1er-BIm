Suppose I want to implement a function to solve a very basic Elliptic problem using Finite Element of some degree (It's just an example). Normally the user of my function is only interested to the numerical solution of the Elliptic problem, i.e. the values of the solution on a proper grid. So, the user call something like               u = EllipticDirichlet[..., range, ...];      Sometimes the caller of my function may be interested to some internal detail of the computation, for example the linear system formulation of the problem, i.e. the stiffness matrix K and the load vector F. Ideally my function should return these ancillary data tagged in some way, so the user of my function can get these data simply and in a roubust. I don't want my fuction return everytime the solution and all ancillary data in a list like in the following pseudocode.               {u, K, F} = EllipticDirichlet[..., range, ...];      What are the way to handle this situation? I can think to the following way.   1. Using Options or Arguments to tell to the function what to return. Not clean in my opinion, not because of the options, but because it would be preferable to keep main result distinct from other ancillary intermediate computation data.   2. Returning an "object" with "properties" like `LinearModelFit` for example. Probably the best idea but make the function result more difficult to use and to understand for a casual reader.   3. Using `Sow`. But I'm not sure if this this a use-case for `Sow`? For example it's legal to `Sow` from a function if no one `Reap`? Documentation say nothing about this.  There are other way to accomplish this task? ### Update I'm anything but a _MATLAB_ fan, but what I'm asking it's a very common scenario under _MATLAB_ , and it's very simple to consume and provide functions that returns differently "shaped" answer with different "levels" of details. For example in _MATLAB_ I can call a function with syntax like this               [x, u] = EllipticSolve[...]      if I'm only interested to the x grid used and solution u on grid vertices; or I can call               [x, u, K] = EllipticSolve[...]      if I'm occasionally also interested to the stiffness matrix K of the linear system used to solve the problem; I can also call               [~, ~, K] = EllipticSolve[...]      if I'm interested only to the stiffness matrix K. I think the function EllipticSolve can also do some optimization of the computation recognizing the output requested. Basically I whish to be able to do something like this.