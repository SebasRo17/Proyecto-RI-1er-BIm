I've started working at this company, and the software is managed in a Visual Studio solution that includes hundreds of projects (C++ and C#). After poking around the solution for couple of weeks, I started wondering why there are so many projects. Not only does it slows down VS considerably, but a rebuild can take up to an hour. Since a visual studio project corresponds to a physical deployment unit (be it a .NET dll, a C++ lib or an exe), there are reasons why you'd want code partitioned across projects. Some of those reasons can be found in this article. In my particular case, none of the reasons in that article stood. There are roughly 5 processes running across tiers, maybe a few dynamically loaded assemblies used for a plug-in model, and some infrastructure which is rarely changed. I don't see any need for more than ~50 VS projects for this solution, and I believe that merging them will increase productivity and will allow for a shorter feedback loop. When I tried to suggest this to the software manager, his response was that they are trying to have **as many dlls as possible** so that when they plan to ship a new feature, **QA can test just the behavior of the modified dlls** without having to worry that something else was effected. He said that since a dll was not changed, it will behave the same. For this to work they aim for high granularity of deployment units. Does this make sense to anyone? I don't see the difference in the effect on behavior between editing a single line in a project that has a single huge dll, and editing the same line in a project that includes hundreds of dlls. **EDIT** I'm looking for an answer on using assemblies/project as means for separating logical concerns and its effect on the testing effort. I would even go as far as saying that many assemblies that could give you more testing scenarios because of versioning incompatibilities. So my distilled question is: When will you partition your code across projects/assemblies instead of namespaces in the same assembly, given that there are no runtime constraints, and why? **EDIT 2** I guess I'm looking for something like this article. However, I'm reluctant to post this as an answer and accept before I see if there are different opinions in the community.