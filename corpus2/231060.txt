Delphi RAD libraries implement many thread friendly objects in a way which forces one to declare another object for storing the reference returned by that object's locking method. The object thus essentially encapsulates the prime object which is returned on locking. For example;               List := ThreadList.Unlocklist;     // do something with List     ThreadList.LockList;      Why is this approach taken? Why is inheriting from the prime object, adding the locking object, overriding constructors and destructors, discouraged? For example the following implementation adds a TMREWSync to a list;               IMREWS = interface            ['{5B6DE5FA-847B-42D5-8BF4-9EB20A452C54}']            procedure BeginRead;       function  BeginWrite: Boolean;       procedure EndRead;       procedure EndWrite;          end;          TThreadList = class ( TList, IMREWS )     private            FLock : TMREWSync;          public            constructor Create;       destructor  Destroy; override;            property Lock : TMREWSync read FLock implements IMREWS;          end;          constructor TThreadList.Create;     begin       FLock := TMREWSync.Create;       inherited;     end;          destructor TThreadList.Destroy;     begin       inherited;       FLock.Free;     end;          // Usage:          ThreadList.BeginWrite;     // Do something with ThreadList     ThreadList.EndWrite;