I have a dual-core intel machine. I would like to test how many parallel local kernels should be launch to get the optimized performance. Knowing that the HyperThreading technology of Intel could run 2 "Threads" on 1 core. That means we could run 4 threads on a dual-core CPU. For informations about "Threads vs Cores", look at here.. AMD says "no" to HyperThreading, and after them, cores is much more important. view amd vs intel: " _Based on the results of the Cinebench® and PovRay® benchmark tests, we find that physical cores outperform enhanced threading software in certain applications."_ Function to evaluate:               mlength[z_] :=       Length[FixedPointList[#^2 + z &, z, 20, SameTest -> (Abs[#] > 2 &)]]      **1\. Sequential Evaluation (No parallel)**               CloseKernels[]; Kernels[]     ParallelTable[        mlength[x + I y], {y, -1, 1, 0.005}, {x, -2, 1,          0.005}]; // AbsoluteTiming      > During evaluation of ParallelTable::nopar: No parallel kernels available; > proceeding with sequential evaluation. > > {8.814056, Null} ![enter image description here](http://i.stack.imgur.com/aOIVc.png) Although no parallel kernel is used, we can see that the second core on the right shares about 50% the work with the first core. I think Windows automatically shares the work for multicore. **2\. Using 1 Slave kernel**               CloseKernels[]; LaunchKernels[1]; Kernels[]     ParallelTable[        mlength[x + I y], {y, -1, 1, 0.005}, {x, -2, 1,          0.005}]; // AbsoluteTiming      > {9.110458, Null} ![enter image description here](http://i.stack.imgur.com/zb4xB.png) By asking Mathematica add one slave kernel, this slave kernel runs on the first core mainly (on the left) and we can see that the work is mainly done in the first core. There are still some works on the second core. **3\. Using 2 slaves kernel**               CloseKernels[]; LaunchKernels[2]; Kernels[]     ParallelTable[        mlength[x + I y], {y, -1, 1, 0.005}, {x, -2, 1,          0.005}]; // AbsoluteTiming      > {4.820431, Null} ![enter image description here](http://i.stack.imgur.com/D6Ffm.png) Now, with 2 slaves kernels, the work is evenly distributed on 2 cores. That's the reason why, we get the results done in half of the time. We can see that Mathematica parallelizes better than Windows. **4.Using 4 slaves kernel**               CloseKernels[]; LaunchKernels[4]; Kernels[]     ParallelTable[        mlength[x + I y], {y, -1, 1, 0.005}, {x, -2, 1,          0.005}]; // AbsoluteTiming      > {5.023232, Null} ![enter image description here](http://i.stack.imgur.com/pAeic.png) ![enter image description here](http://i.stack.imgur.com/Tm0qP.png) I'm trying to add more kernels by supposing that, one core could maintain 2 "threads". But the results is slower. I think Multithreading does not help in Mathematica. So the rule of thumb is: the number of parallel local kernels = number of cores (not threads). Increasing number of kernel just increases the overhead of data transfer between kernels. Any suggestions? ================================================================= **Udate to another computer Intel i7, 4 CORES, 8 THREADS (TRUE HT).**               maxKernel = 8;     data = Table[       CloseKernels[];         LaunchKernels[n];         ParallelTable[          mlength[x + I y], {y, -2, 1, 0.002}, {x, -2, 1, 0.002}]; //          AbsoluteTiming // First, {n, 0, maxKernel}]      > {40.332307, 44.634553, 22.154267, 17.925025, 14.795846, 13.280760, \ > 12.369708, 13.218756, 12.701726} ![enter image description here](http://i.stack.imgur.com/fYOo7.png) We can see that, the time decreases up to 4 Cores, and then, up to 6 threads, time optimized only 1-2 second.