I have some expressions `f,g,h` that are elements of a symmetric tensor algebra. The expressions are generated by a basis `{e1,e2,e3,...en}` and so takes the form of a polynomial of the basis elements with coefficients that are linear polynomials made from `{c1,c2,c3,...cm}` and parameter `k`. I know that there is a unique assignment of the `c`'s such that `f=g=h=0`. I initially used `SolveAlways` and gave the basis as the second argument. However `SolveAlways` became very slow for larger `f,g,h` as it continued attempt to solve for `k` even though it was not possible to determine a specific value. I varied the attempt by using `Solve[!Eliminate[!{f==0,g==0,h==0},basis],constantslist]` which did speed up the process significantly likely because mathematica correctly identifies k as a parameter. Now however as the size of the basis I'm dealing with grows it seems `Eliminate` is slowing down the process. For a an example to for a basis of dimension 25 and `f= (c1-1)e1+c2 e2...+c25 e25` it takes 10 seconds and nearly 1.3 GBs of memory to to tell me that all but one coefficient must be 0. I do have a way around this when I know that `f` only has linear terms of the basis. This involves a brute force method of solving the zeroes of the coefficients one by one then replacing the rules back into f. This comes out as                Module[{tempvalue = e1-c1 e1+c2 e2...+ c25 e25,temprules = {},tempcoef},     For[i = 1, i <= GeneratorSize, i++,       tempvalue = tempvalue /. temprules;      tempcoef = Coefficient[tempvalue, GeneratorBasis[[i]]];     temprules = Join[temprules, Solve[tempcoef == 0][[1]]]];     temprules]      However, I would believe that this method would be impracticable when f has non-linear terms of the basis. As asking for e1's coefficient in `c1 e1 e2 +c2 e1` would lead to `c1 e2 +c2` and unless I again use `SovleAlways` I won't find a solution which keeps the `Eliminate` problem. To fix this I would need to generate a list that goes from the highest order terms to the lowest. This may be possible but I am unsure how to go about it. As an example of what would be needed to solve the problem. Suppose `f=(c1-c2+1)e1 e2 + (c1-1/3)e1^2 + c3 e1`, what is needed is to some how extract the 3 equations that are needed to solve for `{c1,c2,c3}` here they are:                c1-c2+1=0      c1-1/2=0      c3=0      A method that could be possible would be to generate a list of terms generated by the basis elements `{e1,e2}` ordered from most highest order product to least. Here that list would be `{e1 e2, e1^2,e1}` which would then be used with `Coefficient` to extract the equations above. The reason the set must be ordered in this way is that after the equation is extracted its solution is put back into `f` and so would eliminate that term being picked up by lower ordered terms. This means that when `Coefficient[f/.rules,e1]` is called one would get `c3` rather then `c3+(c1-c2+1)e2`. This leads to the question at hand. Either, is there a way to generate a list of the terms of a polynomial made from the basis ordered so that the high order products are first, or is there a better way to approach the problem as a whole?