The purpose of the algorithm is to create `n` routes on a geographical map, where `n` is being given, whereas all routes take no longer than `t` time units by foot and end where they start, while trying to have as little overlap as possible, meaning the user walking the routes walks on as few streets twice or more often as possible. The software is to calculate closed routes (starting point = ending point) while the length of the routes should equal the time `t`. Another restriction is that each street should be walked along as few times as possible to always explore new areas while walking for the same time period. Example: You are in New York City (google maps for an example map)   * You want to walk for 40 minutes.   * You want to be on new roads or paths as often as possible. Picture having a thread. The thread has a length of `velocity_walking * t` in a smaller scale. Now you glue the end and start to a starting point on your map, `lat` and `lon`. Then you move the thread so it is only on streets/walking paths, without being on the same street twice. Now you take another thread and glue the end and start to a starting point on your map, `lat` and `lon`. Now you do the same thing as above, trying to not put it over the other thread. You repeat this `n` times, all in all, so given the first two threads, you repeat it `n-2` times. So the steps are   1. Enter `n`   2. Enter `t`   3. Enter the starting point in `lat` and `lon`   4. Create `n` routes that take `t` time units to walk by foot, start and end in `lat`,`lon` and if possible don't contain the same streets or parts of streets twice. My idea: Having a circle of radius equaling `walking_velocity * t / 2`. Plan routes from start to point on circle to start. Disadvantages:   * Same streets to the circle's circumference and back.    * Many streets are omitted. What is the better algorithm to do this? Language does not matter, algorithm matters.