I am trying to set up Brillouin zone and representing the lines that are formed by the intersection of two planes is part of my step. I have tried the sample sections from the graphics guide book, but I got some wrong output. Here is the code that I copied from the guidebook:               (* to save memory *) $HistoryLength = 0;      The function `latticePointListSC` generates all lattice points that we want to take into account. It returns all lattice points inside a sphere of radius d around the origin.               latticePointListSC[d_] :=       With[{n = Ceiling[d]},          Select[           DeleteCases[             Flatten[Table[{i, j, k}, {i, -n, n}, {j, -n, n}, {k, -n, n}], 2],             (* without origin *){0, 0, 0}],           #. # <= d^2&]]          maxDist = 4;Length[latticePoints = latticePointListSC[maxDist]]          Show[Graphics3D[Cuboid[# + 0.1 {1, 1, 1},# - 0.1 {1, 1, 1}]& /@ latticePoints],       Axes -> True];      Next, we construct the perpendicular planes in the middle of the lines origin–latticePoint. We denote a plane in the form `Plane[onePointOfThePlane, listOfTwoOrthogonalDirections]`. The function `toPlane` generates a plane (head Plane) of the bisector plane formed by the point latticePoint.               toPlane[p:latticePoint_] :=       Plane[latticePoint/2,         Which[(* lattice point is on a coordinate axis *)           p[1] == 0 && p[2] == 0, {{1, 0, 0}, {0, 1, 0}},           p[1] == 0 && p[3] == 0, {{1, 0, 0}, {0, 0, 1}},           p[2] == 0 && p[3] == 0, {{0, 1, 0}, {0, 0, 1}},           (* lattice point is on a coordinate plane *)           p[1] != 0 && p[2] != 0, {#, Cross[#, p]}&[{p[2], -p[1], 0}],           p[1] != 0 && p[3] != 0, {#, Cross[#, p]}&[{p[3], 0, -p[1]}],            p[2] != 0 && [P3] != 0, {#, Cross[#, p]}&[{0, p[3], -p[2]}],           (* lattice point is in generic position *)           True, {#, Cross[#, p]}&[{p[2], -p[1], 0}]]]      We are now adding some planes that guarantee that polygons are divided along the symmetry planes. A “symmetry unit” (for brevity, just called unit in the following) is given by the following domain x>=0, y>= 0, z>= 0, z >= x, x >=y. This is 1/48 of the whole space. The list symmetrySlicingPlanes contains the planes that bound the unit.               symmetrySlicingPlanes =       Plane[{0, 0, 0}, #]& /@         {{{1, 0, 0}, {0, 1, 0}}, {{1, 0, 0}, {0, 0, 1}},{{0, 1, 0}, {0, 0, 1}},          {{0, 0, 1}, {-1, 1, 0}}, {{0, 0, 1}, {1, 1, 0}}, {{1, 0, 0}, {0, -1, 1}},           {{1, 0, 0}, {0, 1, 1}}, {{0, 1, 0}, {-1, 0, 1}},{{0, 1, 0}, {1, 0, 1}}};      Here are the symmetrySlicingPlanes. The red, slightly sticking out polygons mark one symmetry unit. We will in the following concentrate on this unit and only later in the visualization part generate all other 47 units by reflection and rotation.               With[{ε = 0.05},       Show[         Graphics3D[{           (* make polygons *)           Polygon[{#[1] - #[2, 1] - #[2, 2],                     #[1] + #[2, 1] - #[2, 2],                    #[1] + #[2, 1] + #[2, 2],                     #[1] - #[2, 1] + #[2, 2]}]& /@ symmetrySlicingPlanes,           {SurfaceColor[Hue[0]],             (* lift a bit up *)            Map[# + {ε, ε, 2ε}&,               (* boundary of the unit cone *)              {Polygon[{{0, 0, 0}, {0, 0, 1}, {1, 0, 1}}],               Polygon[{{0, 0, 0}, {0, 0, 1}, {1, 1, 1}}],               Polygon[{{0, 0, 0}, {1, 0, 1}, {1, 1, 1}}]},              {-2}]}}],          Boxed->False]]          planes =        Join[toPlane /@ latticePoints, symmetrySlicingPlanes];     Take[planes, 4]      Next, we construct representations of the lines that are formed by the intersection of two planes. The presentation of the lines will be in the form Line[onePointOfTheLine, lineDirection]. We use here a two-argument version of Line, in distinction to the built-in Line, which takes one argument. The function lineOnPlane[plane1, plane2] calculates the intersection line which is located on plane1 , induced by its intersection with the plane plane2 .               (* three equations cannot be solved for four variables *)     Off[Solve::"svars"];     lineOnPlane[Plane[p_, {dir1_, dir2_}], Plane[q_, {d1_, d2_}]] :=        Module[{eqs, sol, line, var, aux, P1, P2},         If[           (* are the planes parallel? *)           Length[DeleteCases[RowReduce[{dir1, dir2, d1, d2}], {0, 0, 0}, {1}]] == 2,            {},           (* calculate direction of the intersecting line *)           eqs = Thread[p + s dir1 + t dir2 == q + u d1 + v d2];         sol = Solve[eqs, {s, t, u, v}];         aux = p + s dir1 + t dir2 /. sol[[1]];         (* two points on the line *)         {P1, P2} = {aux /. {u -> 0, v -> 0}, aux /. {u -> 1, v -> 1}};Line[P1, P2 - P1]]]          lineOnPlane[planes[[1]], planes[[5]]]      I should have gotten > >     Line[{-2, 1, -1}, {0, -20, 10}] >   but i got > >     Line[{-2, s, -(1/2) - s/2}, {0, 0, 0}] >   instead The lines after this all got messed up beacuse of the wrong out[16] Could anyone please help? Is there a better way I could do compute the lines that are formed by the intersection of two planes?