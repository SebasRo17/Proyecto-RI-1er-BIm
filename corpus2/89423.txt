## Background I do game development as a hobby, and am looking for a better way to design them. Currently, I am using a standard OOP approach (I have been doing enterprise development for 8 years so it comes nartually). Take for example a "baddie"               public class Baddie:AnimatedSprite //(or StaticSprite if needed, which inherit Sprite)     {         //sprite base will have things like what texture to use,          //what the current position is, the base Update/Draw/GetInput methods, etc..         //an AnimatedSprite contains helpers to animated the player while          //a StaticSprite is just one that will draw whatever texture is there     }      ## The problem Lets say I am making a 2d platformer, and need the baddie to be able to Jump. Usually what I do is add the appropriate code in the Update/GetInput methods. Then if I need to make the player crawl, duck, climb, etc... the code will go there. If I'm not careful, those methods get cluttered, so I end up creating methods pairs like this `CheckForJumpAction(Input input)` and `DoJump()` `CheckforDuckAction(Input input)` and `DoDuck()` so GetInput looks like               public void DoInput(Input input)     {         CheckForJumpAction(input);         CheckForDuckAction(input);     }      and Update looks like               public void Update()     {         DoJump();         DoDuck();     }      If I go and create _another_ game where the player needs to jump and duck, I usually go into a game that has the functionality and copy it over. Messy, I know. Thats I why I'm looking for something better. ## Solution? I really like how Blend has behaviors I can attach to an element. I have been thinking about using the same concept in my games. So lets look at the same examples. I would create a base Behavior object               public class Behavior     {         public void Update()         Public void GetInput()     }      And I can create behaviors using that. `JumpBehavior:Behavior` and `DuckBehavior:Behavior` I can then add a collection of behaviors to the Sprite base and add what I need to each entity.               public class Baddie:AnimatedSprite     {         public Baddie()         {             this.behaviors = new Behavior[2];             this.behaviors[0] = new JumpBehavior();             //etc...         }              public void Update()         {             //behaviors.update         }              public GetInput()         {             //behaviors.getinput         }     }      So now If I wanted to use Jump and Duck in many games, I can just bring the behaviors over. I could even make a library for the common ones. ## Does it work? What I can't figure out is how to share state between them. Looking at Jump and Duck, both affect not only the current portion of the texture being drawn, but also the state of the player. (Jump is going to apply a decrementing amount of upward force over time, while duck is just going to stop movement, change the texture and the collision size of the baddie. How can I tie this together so it works? Should I create dependency properties between the behaviors? Should I have each behavior _know_ about the parent and directly modify it? One thing I thought was being able to pass a delegate into each behavior to get executed when it is triggered. I'm sure there are more issues I am looking over, but the entire purpose is for me to be able to easily reuse these behaviors between games, and entities in the same game. So I turn it over to you. Care to explain how/if this can be done? Do you have a better idea? I'm all ears.