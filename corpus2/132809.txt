I'm playing around a bit with image processing and decided to read up on how color quantization worked and after a bit of reading I found the Modified Median Cut Quantization algorithm. I've been reading the code of the C implementation in Leptonica library and came across something I thought was a bit odd. Now I want to stress that I am far from an expert in this area, not am I a math-head, so I am predicting that this all comes down to me not understanding all of it and not that the implementation of the algorithm is wrong at all. The algorithm states that the _vbox_ should be split along the lagest axis and that it should be split using the following logic > The largest axis is divided by locating the bin with the median pixel (by > population), selecting the longer side, and dividing in the center of that > side. We could have simply put the bin with the median pixel in the shorter > side, but in the early stages of subdivision, this tends to put low density > clusters (that are not considered in the subdivision) in the same vbox as > part of a high density cluster that will outvote it in median vbox color, > even with future median-based subdivisions. The algorithm used here is > particularly important in early subdivisions, and 3is useful for giving > visible but low population color clusters their own vbox. This has little > effect on the subdivision of high density clusters, which ultimately will > have roughly equal population in their vboxes. For the sake of the argument, let's assume that we have a vbox that we are in the process of splitting and that the red axis is the largest. In the Leptonica algorithm, on line 01297, the code appears to do the following   * Iterate over all the possible green and blue variations of the red color   * For each iteration it adds to the _total_ number of pixels (population) it's found along the red axis   * For each red color it sum up the population of the current red and the previous ones, thus storing an accumulated value, for each red  _note: when I say 'red' I mean each point along the axis that is covered by the iteration, the actual color may not be red but contains a certain amount of red_ So for the sake of illustration, assume we have 9 "bins" along the red axis and that they have the following populations > 4 8 20 16 1 9 12 8 8 After the iteration of all red bins, the _partialsum_ array will contain the following count for the bins mentioned above > 4 12 32 48 49 58 70 78 86 And _total_ would have a value of 86 Once that's done it's time to perform the actual _median cut_ and for the red axis this is performed on line 01346 It iterates over bins and check they accumulated sum. And here's the part that throws me of from the description of the algorithm. It looks for the first bin that has a value that is _greater_ than _total/2_ Wouldn't _total/2_ mean that it is looking for a bin that has a value that is greater than the _average_ value and not the _median_ ? The median for the above bins would be _49_ The use of _43_ or _49_ could potentially have a huge impact on how the boxes are split, even though the algorithm then proceeds by moving to the center of the larger side of where the matched value was.. Another thing that puzzles me a bit is that the paper specified that the bin with the median value should be located, but does not mention how to proceed if there are an even number of bins.. the median would be the result of _(a+b)/2_ and it's not guaranteed that any of the bins contains that population count. So this is what makes me thing that there are some approximations going on that are negligible because of how the split actually takes part at the center of the larger side of the selected bin. Sorry if it got a bit long winded, but I wanted to be as thoroughas I could because it's been driving me nuts for a couple of days now ;)