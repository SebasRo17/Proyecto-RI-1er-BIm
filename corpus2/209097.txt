I need an algorithm for picking a user. Users are identified by letter {A, B, C, ...} and are ranked by number {1, 2, 3, ...}. Rank is the degree of likelihood to be picked, so a rank 2 user is twice as likely to be picked over a rank 1 user, and rank 4 is four times as likely, etc. So let's say four users are {A, B, C, D}, with rank {1, 1, 5, 2} respectively. A user table might store rank:                  USER   RANK           A   1           B   1           C   5           D   2      How do I pick a user based on rank? My first idea for an algorithm is to add up all the ranks 1 + 1 + 5 + 2 to obtain a sum of 9. Then assign subranges from 1 to 9 to each user, where subrange size is user rank. So A has range [1, 1], B has range [2, 2], C has range [3, 7] (5 possibilities due to rank being 5), and D has range [8, 9]. The table becomes this:                  USER   RANK  RANGE           A   1     [1, 1]           B   1     [2, 2]           C   5     [3, 7]           D   2     [8, 9]      Then calculate a random value from 1 to 9, and find the user whose range contains that value. So if the random value is 4, user C is picked because 4 falls within range [3, 7]. This achieves fairness based on rank. If you repeat picking randomly this way, on the average, users will be chosen fairly, and no user will be starved. However, it feels sloppy, because to add or remove users, I have to recalculate all the ranges. Here is removing user C (recalculate range of user D):                  USER   RANK  RANGE           A   1     [1, 1]           B   1     [2, 2]           D   2     [3, 4]      And here is changing user A to have rank 2 (recalculate range of B and D):                  USER   RANK  RANGE           A   2     [1, 2]           B   1     [3, 3]           D   2     [4, 5]      What is the best algorithm to pick a user? Surely recalculating ranges for every user add, delete, or update is suboptimal. Is there a well-known function or algorithm that can help? * * * UPDATE: @rwong got me thinking about grouping people by rank, then picking rank instead of picking user. With **one** person in each rank, you turn the random-shaped ranges into a very linearly-growing ranges (one dot is one chance to be picked):               Rank 1:  *     Rank 2:  * *     Rank 3:  * * *     Rank 4:  * * * *     Rank 5:  * * * * *      Works great for exactly one person per rank, but it falls apart when you have lots of people at rank 1, where their chances should increase by the number of people within that rank, possibly overtaking the chances of higher ranks. Now we're back to an irregular shape, and must pick from it. A friend pointed me to Rejection sampling. This seems to be a great solution where you pick a random x and y coordinate, see if it falls within the shape, and if so, we now picked rank. Then pick a random person within that rank. To show this solution, here is the shape with multiple people inside each rank. For rank 2, there are 5 people, so that's 2 x 5 = 10 chances:               User count   Rank   Chances(graph)       Chances(number)     5            1      * * * * *            5     5            2      * * * * * * * * * *  10     1            3      * * *                3     0            4                           0     1            5      * * * * *            5      The algorithm is to pick a random row (like picking an x coordinate), and pick a random value from 1 to max(chances) (like picking a y coordinate). See if that is less than or equal to the number of chances at that rank. If not repeat until you have a valid rank and chance. This takes care of distribution probability. Now that you have chosen a valid rank, at that point you simply pick a random person within that rank. Done! The beauty is, to add or remove someone, you increment or decrement the user count column, and assign a new Changes(number). Two small very simple updates. The memory complexity and time complexity of add/remove/update user and also complexity to pick a user is nothing, like O(1). We grouped user by rank, and captured user count in each rank, then calculate chances for that rank, and used a simple looping algorithm to pick random rows and chance values until we get a hit, and finally pick a random person at that rank.