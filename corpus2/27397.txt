This is a toy example of the question I have but I think it illustrates the point. I have a function `y[x]` which is an interpolating function. Let's define it through:               y=y1 /. NDSolve[{y1''[x]+y1'[x]+y1[x]==0,y1[0]==1,y1'[0]==0},y1, {x, 0, 5}][[1, 1]]      I need to pass this function into another differential equation as the initial condition for the new system (it's time dependent). However, the new differential equation has to be in polar coordinates so I need the above function converted into polar coordinates. Of course I could do this simply by writing:               Interpolation[{Sqrt[y[#]^2 + #^2], ArcTan[y[#]/#]} & /@ Range[0.001, 5, 0.1]]      Which will give me an interpolating function in the right coordinate system. However, with the above, I have had to chose the `x` values that I pass in by hand (ie. `Range[0.001,10,0.1]`). I would like to take as much data from the original `InterpolatingFunction` `y[x]` as I can. The grid within the interpolating function won't be even and there is, as far as I know, gradient data within the function as well. I would like to be able to translate the original `y[x]` `InterpolatingFunction` into a `θ[r]` `InterpolatingFunction` with as much fidelity as I can. I have seen that within `Head[y[x]][[4]]` there is data of the form `{Developer`PackedArrayForm,List_,List_}` but it's not clear what the syntax is. If anybody knows how to pass my `y[x]` into a `θ[r]` as accurately as possible, I would be very grateful. **Edit** Thanks to mmal's comment I see a way forward. In the first link there is an answer to a similar question. If we load:               Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"]      Then we can define the following function:               Clear[reconstructInterpolatingFunction];     reconstructInterpolatingFunction[intf_InterpolatingFunction] :=      With[{data = intf[[4, 3]],      step = Subtract @@ Reverse[Take[intf[[4, 2]], 2]],      order = Developer`FromPackedArray@InterpolatingFunctionInterpolationOrder[intf],      grid = InterpolatingFunctionGrid[intf]},      Interpolation[MapThread[Prepend, {Partition[data, step], grid}],      InterpolationOrder -> order]];      Inspecting the term `MapThread[Prepend, {Partition[data, step], grid}]` for the `InterpolatingFunction` from `NDSolve` I find that the output is of the form:               {...,{{x},y[x],y'[x],y''[x]},...etc.}      Thus, this is what is needed to be transformed into polar coordinates and turned back into an `InterpolatingFunction`. This is a much simpler task than I originally had so many thanks to mmal. I shan't be able to finish answering this question tonight so if anyone fancies playing with the derivative terms, please do so.