I am using NDSolve on a vector function $\mathbf y'(x)=f[\mathbf y(x)]$ with initial condition $\mathbf y_0$, where the dimension of the vector should be user-defined.               Clear[y, y0]     y0 = {1, 2}     sol = NDSolve[{y'[x] + y[x] == 0, y[0] == y0}, {y}, {x, 0, 10}]      I'm attempting to use the resulting InterpolatingFunction as an input into a matrix ODE, $\mathbf z'(x) = g[\mathbf z(x)]$, with initial condition $\mathbf z_0$.               Clear[z,z0]     z0 = {{1., 2.},{3.,4.}}     failing = NDSolve[{z'[x] + foo[y[x] /. sol, {1, 1}] z[x] == 0, z[0] == z0}, {z}, {x, 0, 10}]      Where               foo[vectx_?(VectorQ[#] &), vecty_?(VectorQ[#] &)] := vectx.vecty      The function `foo[x,y]` is failing to compute the dot product correctly because the dimensions don't match up (`Length[y[x] /. sol,]` is `1`), although `VectorQ[y[x] /. sol]` yields `True`. Naively, I expected that the result of `NDSolve` would be something like $\mathbf y(x) = (\text{InterpolatingFunction}[y_1(x)], \text{InterpolatingFunction}[y_2(x)],...)$ So that the dot product $\mathbf y \cdot (a,b,...)=a \, \text{InterpolatingFunction}[y_1(x)] + b \, \text{InterpolatingFunction}[y_2(x)]+...$ Rather, it's something more like `{InterpolatingFunction[{{0.,10.}},<>][t]}`, which is trivially a vector since it's enclosed by `{...}`. How do I express my "dot product" logic above in Mathematica-ese? Or is there a more elegant way to get the code flow that I want?