I have an app where I need to synchronize some entities (simply download latest versions of entities from server to client). Entity has bunch of text properties and bunch of resource links (referenced by ids, URLs, whatever). For example let `Entity` has three properties:               id: integer,     name: string,     photos: array of photo ids      For now `Entity` is represented by two classes: one for persistent store (I'm using CoreData storage in iOS, you may consider it as ORM if you aren't familiar with iOS SDK) and one for JSON parsing and serialization called `Entity` and `JSONEntity` respectively. `Entity`               id: integer,     name: string,     photos: array of paths for files at local file system     pendingDownloads: object to track pending file downloads for `Entity`      `JSONEntity`               id: integer,     name: string,     photos: array of photo ids      I'm going to use the following algorithm:   1. call server API and obtain array of instances of `JSONEntity`   2. for each retrieved `JSONEntity`     1. find or create corresponding instance of `Entity` that should be updated     2. immediately update `name` property of `Entity` instance     3. associate `pendingDownloads` instance with current `Entity` instance `Entity` instance that have associated `pendingDownloads` object is considered as downloading and can't be used. When application starts:   1. find `Entity` instances that have non-null `pendingDownloads`   2. for each `id` in `pendingDownloads`     1. download photo     2. add local file reference to photo into `photos`     3. remove current item from `pendingDownloads`   3. null-out `pendingDownloads` property   4. notify model that `Entity` finished syncronization As for me the biggest flaw of current approach is that I have to keep two parallel hierarchies of classes - one for persistent store and one for JSON parsing/serialization. I tried to use inheritance: I declared newtork-level (like photo ids) properties in superclass and local-level (like file references) in subclass. But I don't like this approach either - object become overloaded with responsibilities - it have to track both network-level and local-level information. Are there any patterns or approaches to handle this kind of situations? Would be grateful for any thoughts. Thanks.