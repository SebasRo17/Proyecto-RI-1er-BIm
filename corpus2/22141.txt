My first question here as I only got into _Mathematica_ programming recently. Basically I have a large symbolic algebraic expression where I know certain variables with head pε appear with degree 2 in each term. So the terms look like this:               (...) pε[i, j] pε[k, l] + (...) pε[m ,n] pε[p, q] + ...      I want to pick out which of these appear in my expression, and I figured out this would do the trick               (Reap[expr /. patt : (x_pe y_pe | _pe _pe) :> Sow[patt] ;][[2,1]]) // DeleteDuplicates      which gives: > {pe[4, 6]^2, pe[3, 6]^2, pe[2, 6]^2, pe[5, 6]^2, pe[3, 6] pe[4, 6], pe[3, 6] > pe[5, 6], pe[4, 6] pe[5, 6]} This however is missing terms because, when I ran two sets of pattern matches without `|`, I get more terms               (Reap[expr /. patt : x_pe y_pe :> Sow[patt] ;      expr /. patt : _pe _pe :> Sow[patt] ;][[2,1]]) // DeleteDuplicates      > {pe[3, 6] pe[4, 6], pe[2, 6] pe[4, 6], pe[2, 6] pe[3, 6], pe[3, 6] pe[5, 6], > pe[4, 6] pe[5, 6], pe[2, 6] pe[5, 6], pe[4, 6]^2, pe[3, 6]^2, pe[2, 6]^2, > pe[5, 6]^2} So I would like to know what's going on. In particular I imagine the first would be a lot more efficient if it worked properly. Also feel free to give alternative ways of doing this. My choice of using `Reap, Sow` was one of efficiency but my of knowledge of the language is still small. ### Edit Based on the example given by @Federico I have constructed a small analogue where the difficulties are manifest, I use `Cases` because it's conceptually clearer               sum = Sum[pe[i, j] l[i, j] pe[j, k], {i, 3}, {j, 3}, {k, 3}]      whose output is: > l[1, 1] pe[1, 1]^2 + l[1, 1] pe[1, 1] pe[1, 2] + l[1, 1] pe[1, 1] pe[1, 3] + > l[2, 1] pe[1, 1] pe[2, 1] + l[1, 2] pe[1, 2] pe[2, 1] + l[2, 1] pe[1, 2] > pe[2, 1] + l[2, 1] pe[1, 3] pe[2, 1] + l[1, 2] pe[1, 2] pe[2, 2] + l[2, 2] > pe[2, 1] pe[2, 2] + l[2, 2] pe[2, 2]^2 + l[1, 2] pe[1, 2] pe[2, 3] + l[2, 2] > pe[2, 2] pe[2, 3] + l[3, 1] pe[1, 1] pe[3, 1] + l[3, 1] pe[1, 2] pe[3, 1] + > l[1, 3] pe[1, 3] pe[3, 1] + l[3, 1] pe[1, 3] pe[3, 1] + l[2, 3] pe[2, 3] > pe[3, 1] + l[1, 3] pe[1, 3] pe[3, 2] + l[3, 2] pe[2, 1] pe[3, 2] + l[3, 2] > pe[2, 2] pe[3, 2] + l[2, 3] pe[2, 3] pe[3, 2] + l[3, 2] pe[2, 3] pe[3, 2] + > l[1, 3] pe[1, 3] pe[3, 3] + l[2, 3] pe[2, 3] pe[3, 3] + l[3, 3] pe[3, 1] > pe[3, 3] + l[3, 3] pe[3, 2] pe[3, 3] + l[3, 3] pe[3, 3]^2 So there are two types of terms those that contain `pe` squared and those that don't. Those that do are captured by               Cases[sum, _pe^2, Infinity]      those that don't require               Cases[sum, _ x_pe y_pe -> x y, Infinity]      So the question now is why does the following also work for the case with no `pe` squared?               (Reap[sum /. patt : (x_pe y_pe) :> Sow[patt]; ][[2,1]])      And a followup question, how would one capture the squared terms if _Mathematica_ didn't collect them in a square? For example, if I had `pe[1, 1]l[1, 1] pe[1, 1]` can I construct a pattern to capture this? Or will it never happen due to `Times` having the `Orderless` attribute? I am thinking of a situation where `l[1,1]` is very large and _Mathematica_ doeesn't order it. Another question is can I combine both pattern matching cases in one with the use of `|`, and, if so, would that be more efficient?