My goal is given an integer number to deduce if its digits increase (or remain the same) from left to right or not. Example: $1236, 123336$ are both considered numbers with increasing digits, but $1203$ is not. This is the code that I came up with during my first attempt:               incQ[n_] :=          And @@ (#[[1]] - #[[2]] <= 0 &) /@ Partition[IntegerDigits@n, 2, 1];      I'd like to know:   1. Whether an experienced user could, by looking at this construct, detect the bottleneck.   2. Whether it can be rewritten to speed things up, without completely altering its logic though.   3. If there's a way, besides Workbench, to measure how much time the parts of a compound expression consume (e.g., is the partitioning, the difference'ing or the AND'ing the offender here ?) **EDIT 1** : By slow, I mean that it takes ~2.6secs to check the first $10^5$ integers in Mac OSX 10.9.1, Mathematica 9.0.1, i5 @ 1.7 GHz. **EDIT 2** : As expected, I got lots of great answers (basically for Q2). Before accepting one, what would be the moral of this story? Perhaps, that built-in functions are more likely to be faster than their custom-made equivalent versions?