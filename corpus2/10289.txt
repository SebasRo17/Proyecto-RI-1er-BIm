I have a problem that can be reduced to this one: Suppose I have an unbalanced (almost random) tree. The leaves of the tree have one property already set, and all vertex (including the leaves) have another property that I have to update upon visiting. To update that property, I need to cast a function `f[father_Vertex,{son_Vertex..}]` in an ordered way, as shown below: Example               (*build some tree*)     s = KaryTree[23, 3, DirectedEdges -> True];     leaves = Flatten@Position[VertexDegree[s], 1];     (*Draw it*)     HighlightGraph[#, leaves, VertexLabels -> "Name", ImagePadding -> 20] &@s     (*Assign a property to the leaves*)     leaves = Flatten@Position[VertexDegree[s], 1]     s1 = Fold[SetProperty[{#1, #2}, "leavesProp" -> RandomInteger[{1, 5}]] &, s, leaves];     (*Assign another property to all Vertex*)     s2 = Fold[SetProperty[{#1, #2}, "toUpdateProp" -> ""] &, s1, VertexList[s1]];      ![Mathematica graphics](http://i.stack.imgur.com/66wRC.png) Now, to cast my function, I need to visit node sets updating the properties in a hierarchical order: ![Mathematica graphics](http://i.stack.imgur.com/d0iRt.png) Which is the easiest way to accomplish this navigation scheme? **Edit** The visiting order at each tree level is interchangeable {s1, s2, s3, s4} and {s5, s6, s7} **Edit2** Trying to be more clear. This is the desired order of invocation. All calls to `f` within the same round could be done in any order. The red one could be done in the first or second round. ![Mathematica graphics](http://i.stack.imgur.com/cvwpm.png)