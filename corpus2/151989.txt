Sometimes I find myself writing comments on class methods like this:               class A : public Base     {     public:         /**           * Sets variable;           * should be called before ImplementsInterfaceMtehod(),           * else has no effect.           */       void SetSomeVariable( var_type value );            virtual void ImplementsInterfaceMethod();     }      The callers of `Base::ImplementsInterfaceMethod` obviously do not know about the variable, and should not. But the users of `A` should set the variable if they want it to take effect. It is not required to set the variable (else it could be a parameter for the constructor), so I cannot throw exceptions in `ImplementsInterfaceMethod` if it is not set. Is this a sign of some typical bad practice? Is there a better way than writing a comment as shown to deal with this? **edit** here's a more concrete example resembling part of some realtime 3D image processing code; because of the realtime part and the fact images can get huge, everything has to be preallocated.               class DataProcessor     {     public:         /**           * Sets dimensions of the data for the next call to Process().           * Can be used by implementations to setup internals, eg preallocate.           * Upon returning out contains the dimensions that will be returned           * by the Process call, given dims as input dimensions.           * (A)           */       virtual bool SetInputDimensions( const Dimensions& dims, Dimensions& out ) = 0;            virtual bool Process( const Data& in, Data& out ) = 0;     };          class ImageStitcher : public DataProcessor     {         /**           * Set size of the output image returned by Process() as a factor,           * eg when size == 2, image will be twice as big.           * (B)           */        void SetOutputSize( const double size );              /**           * Set the position at which the next Data object passed to Process()           * will be stitched.           * (C)           */        void SetStitchPosition( double x, double y, double alpha );     }      So here (A) must be called at least once before Process() is called. Which I enforce by returning an error in Process() if that was not the case. Most of the time the dimensions are not known when constructing the object though so a constructor parameter is not an option. Two main components use the DataProcessor interface: all processors are in a network of processors, and that network is unaware of the type of processor, it just takes care of transferring data between them by calling Process() multiple time. Another component takes care of setting up the network by calling SetInputDimensions(), again unaware of what type the processor is. (B) should be called before SetInputDimensions() gets called, as it defines the size of the resulting image. (C) should be called before each call to process else the stitcher doesn't know where to put the image Now this whole processing network is actually used in commercial applications and works extremely well since I made sure everything is called nicely in order. Yet each time I write 'must/should be called before' bells start ringing all over the place..