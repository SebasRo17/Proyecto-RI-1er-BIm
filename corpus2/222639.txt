So imagine the following the happens (and that we're all using SourceTree):   1. We're all working off origin/develop.    2. I go on holiday for a week.   3. My coworker has been working locally for the past several days without merging origin/develop back in to his local develop branch.   4. He tries to do a push, gets told he has to merge first, and then does a pull.   5. He gets a conflict, stopping the automatic commit-after-a-merge from proceeding.   6. Assuming that Git is like SVN, my coworker discards the "new" files in his working copy and then commits the merge - wiping those "new" files from the head of origin/develop.   7. A weeks worth of dev work goes on on top of that revision.   8. I come back from holidays and find out that several days of my work is missing. We're all very new to Git (this is our first project using it), but what I did to fix it was:   1. Rename "develop" to "develop_old".   2. Merge develop_old into a new branch "develop_new".   3. Reset the develop_new branch to the last commit before the bad merge.   4. Cherry pick each commit since then, one by one, resolving conflicts by hand.   5. Push develop_old and develop_new up to the origin. At this point, develop_new is, I'm hoping, a "good" copy of all of our changes with the subsequent weeks worth of work reapplied. I'm also assuming that "reverse commit" will do odd things on a merge, especially since the next few weeks worth of work is based on it - and since that merge contains a lot of things we _do_ want along with stuff we don't. I'm hoping that this never happens again, but if it does happen again, I'd like to know of an easier / better way of fixing things. Is there a better way of undoing a "bad" merge, when a lot of work has gone on in the repo based on that merge?