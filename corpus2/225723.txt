I'm programming a graph object which can be in either a mutable or immutable state. In both states, it has a `get` method, but only in the mutable state is the `set` method allowed. The transition occurs when one invokes a method `compress` which optimizes the storage of the graph. **How do I deal with the fact that some methods are legal in some states but not others?** I can think of two approaches. The blunt way is to use the state pattern. If you invoke `set` when the graph is mutable, it executes as normally; but, if you invoke `set` when the graph is immutable, an error is thrown. This looks ugly to me because an immutable object still has a `set` method. Alternatively, I can make a `graph` type with a `mutable_graph` sub-type; only the second one has a `set` method. The state change is effected by changing the type of the graph. However, this also looks ugly to me; for every implementation of `graph` (of which there are several), I now have to make two types instead of just one. EDIT: I'm using the state pattern and throwing an exception; if neither solution is especially preferable, this one involves writing the least code. Thanks for the advice!