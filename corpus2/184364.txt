If I want to create an infinite list of integers in Java like so:               ArrayList<Integer> list = new ArrayList<Integer>();     for(int i = 0;;i++){         list.add(i);     }      I run out of memory. My understanding is that we allocate some memory for _i_ , _list_ , and every time we add _i_ to the list, we allocate more memory for it. But, by using a thunk, I can create an infinite list which will not eat all of my memory:               infList(final int start){         return new InfiniteList (          start,          return new InfiniteList.LazyTail(){eval(){return infList(start+1);}}         );     }      (I adapted source from here). How does this work? I know I am delaying the evaluation of the expressions : start+1, start+1, start+1 ... but do I end up with a list of something like this: [start, eval(){start+1}, eval(){start+1}, eval(){start+1} ... ] Are the 'eval(){...}' object references? Do they take up space in memory? Will I eventually run out of memory with this implementation (I tried, but memory allocation was not budging)? Do I only start using memory, say, if I wanted to system.out.print integers, then they would have to be evaluated, and some memory allocated?