The old _Mathematica_ package `Graphics`Shapes`` featured the function `PerforatePolygons[]`, which drilled a hole in any `Polygon[]` primitive present in a `Graphics3D[]` object. One would usually use it on the output of `ParametricPlot3D[]` or `Polyhedron[]` from the `Graphics`Polyhedra`` package, like so: ![objects with holes](http://i.stack.imgur.com/q1qP0.png) Here is a slightly simplified implementation of `PerforatePolygons[]` which I used in generating the pictures above:               perforateaux[points_, ratio_] := Block[{test = TrueQ[First[points] == Last[points]],       center, q},         center = Mean[If[test, Most, Identity][points]]; q = 1 - 2 Boole[test];         MapThread[Polygon[Join[#1, Reverse[#2]]] &,           Partition[#, 2, 1, {1, q}] & /@ {points, (center + ratio (# - center)) & /@ points}]]          PerforatePolygons[shape_, ratio_: 0.5] :=       shape /. Polygon[p_] :> perforateaux[p, ratio]      (I elected to remove the additional `EdgeForm[]` directive in the original implementation so that the images clearly show what is going on with each polygon. A proper implementation would have it, of course.) Nowadays, both `PolyhedronData[]` and `ParametricPlot3D[]` return `GraphicsComplex[]` objects within `Graphics3D[]`. The big benefit of this new representation, among other things, is that it minimizes redundant storage; instead of having a point being stored on three or four `Polygon[]` primitives, all the points in the object are stored in the first component of `GraphicsComplex[]`, and the `Polygon[]` objects only need to store the index corresponding to the point they need. For instance, compare the output of `PolyhedronData["Tetrahedron", "Faces"]` and `Normal[PolyhedronData["Tetrahedron", "Faces"]]`. The problem with this efficient representation is that it no longer works nicely with polygon replacement rules like the one used by `PerforatePolygons[]`. Of course, there is the obvious solution of applying `Normal[]` to any `GraphicsComplex[]` object generated before applying `PerforatePolygons[]`, but you lose out on the storage efficiency afforded by `GraphicsComplex[]`. Here now is my question: > Is it possible to improve `PerforatePolygons[]` so that it works > on`GraphicsComplex[]` objects, with the output still retaining the > `GraphicsComplex[]` characteristic of storage with minimum redundancy? * * * If the question above is not sufficiently challenging for you, consider the following wrinkle. `Polygon[]` objects in _Mathematica_ are currently able to take a `VertexColors` option that sets how the things are colored, with proper color interpolation within the polygon. > Is it possible to implement a version of `PerforatePolygons[]` that does its > best to have the new polygons inherit the coloring used by the old polygons? As an example of what is expected: ![colored polygon, with and without hole](http://i.stack.imgur.com/3P5zD.png) The improved `PerforatePolygons[]` should be able to produce an image like the one on the right from the one on the left. For triangular polygons, simple bilinear interpolation works nicely, but how about more complicated polygon objects? Again, it is important that a `GraphicsComplex[]` object still be one after the perforation.