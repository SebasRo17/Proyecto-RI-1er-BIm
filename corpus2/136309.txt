Modular programming and reusable software routines have been around since the early 1960's, if not earlier. **They exist in every programming language.** Conceptually, a software library is a list of programs, each with its own interface (entry points, exit points, function signatures) and state (if applicable). Libraries can be high quality because modules are focused on solving narrow problems, have well-defined interfaces, and the cost can be amortized across all future software programs that will ever use them. Libraries are purely additive: adding new modules does not introduce bugs or limitations in existing modules. So why don't software libraries solve all our problems? Why can't we write software as merely a composition of high-quality software modules? Can we fix these problems with software libraries and unleash the full potential of this incredibly powerful mechanism for writing high-quality programs faster? Or are these problems intrinsic to libraries and can never be solved? _Note: Several comments said that I have too many questions. Please treat the above questions as the real questions and everything that follows as points for discussion._ It is true that software libraries are widely used. Some programming languages such as C, Java and Python have enormous software libraries. But there are numerous problems.   1. Some well-known languages have less than ideal library support (e.g. C++, Lisp). To some extent this is mitigated by piggybacking on a virtual machine platform (e.g. JVM, CLR). A corollary question, should all future software be written for a virtual machine platform to increase library support? This is problematic for scripts that don't want to incur the cost of launching a virtual machine every time.   2. There is a lot of "reinventing the wheel". Have you ever written a linked-list module in C? Yes, of course you have. I don't enjoy writing linked lists in C, but what is the alternative?   3. Can a given library (e.g. libfoo-0.1.2) be trusted as as a basis to write your important software? Is the library tested, documented, and does it implement the features you need? How can you tell?   4. Learning a library's API can be as time consuming as learning a whole new programming language.   5. If a bug is discovered in a library, what is the proper procedure for fixing the bug in your software? How should the bugfix be distributed to all library users?   6. How should libraries be built and distributed? (For example, autotools obviously got it wrong.) Semantic Versioning is good, but how can this be verified and enforced?   7. How should library dependencies be handled? Can we download and install automatically? Will the versions and licenses be compatible?   8. Is the license for a given library compatible with your software? How can you tell?   9. What should you do if the library is abandoned before starting your software? What about after starting your software?