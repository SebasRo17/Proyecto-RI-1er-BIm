I'm currently trying to consistently define rules for extending D[] to four- derivatives. As 'backend' I'm using the package TRACER (http://library.wolfram.com/infocenter/MathSource/2987/), which can perform contractions with metric tensors, Dirac algebra, etc. Derivatives, however, are not implemented in this package. The rules here are independent of TRACER, but I adapted it's syntax, so   * `S[k, {σ}]` is the four-vector $k_\sigma$   * `S[{μ}, {ν}]` is the metric tensor $g_{\mu\nu}$ The basic assumption is that $\frac{\partial}{\partial k^\sigma}k^\rho=g^{\sigma\rho}$. So far, I have               D[S[notk_Symbol, idx_List], S[k_Symbol, derividx_List]] :=          0 /; FreeQ[notk, k];     D[S[k_Symbol, index_List], S[k_Symbol, derividx_List]] :=         S[index, derividx];     D[S[param1__]^n_Integer, S[deriv_, derividx_]] :=         n S[param1]^(n - 1) D[S[param1], S[deriv, derividx]]      For multiplication and addition, I have               D[S[param1__] + S[param2__], S[deriv_, derividx_]] :=          D[S[param1], S[deriv, derividx]] + D[S[param2], S[deriv, derividx]];     D[S[param1__] * S[param2__], S[deriv_, derividx_]] :=          D[S[param1],            S[deriv, derividx]]*S[param2] + S[param1] * D[S[param2],           S[deriv, derividx]]];      And for scalar products:               D[S[k1_Symbol, k2_Symbol], S[k_, derividx_List]] :=          D[S[k1, {dummy}],           S[k, derividx]] S[k2, {dummy}] + S[k1, {dummy}] D[S[k2, {dummy}],           S[k, derividx]];      These, however, do not deliver the correct results (the result is in fact 0) when trying to derive a product or sum with more than two terms. `//Trace` confirms that Mathematica does not know what to do. Does anyone have a pointer?