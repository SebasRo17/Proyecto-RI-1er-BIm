I am looking for a fast and robust way to calculate the Hamming distance of integers. The Hamming distance of two integers is the number of matching bits in their binary representations. I expect that clever methods can easily outpace `HammingDistance` as it works on vectors instead of integers and on any vector not just binary. My naive bitwise method is faster than `HammingDistance` but I'm pretty sure that it can be further optimized. While compilation would help, it won't work on big integers ($\ge 10^{19}$). Nevertheless, I am interested in compiled solutions!               max = 10^10;     n = Length@IntegerDigits[max, 2];     data = RandomInteger[{0, max}, {100000, 2}];     m1 = Map[HammingDistance[IntegerDigits[First@#, 2, n],            IntegerDigits[Last@#, 2, n]] &, data]; // AbsoluteTiming     m2 = Map[Total@IntegerDigits[BitXor @@ #, 2] &, data]; // AbsoluteTiming     m1 === m2      > >     {0.967202, Null}   >     {0.624001, Null} >     True >   It would be nice to work entirely on the binary representations, and I thought that using `DigitCount` on `BitXor` would help, but it gave a cruel 3x slowdown compared to the `HammingDistance` version. **Edit** As an answer to Kirma's comment: I have to calculate the pairwise distance matrix for a set of integers (highly related is Szabolcs's post: Fastest way to calculate matrix of pairwise distances), in the (simplest and most didactive) form:               Outer[hamming[#1, #2], Range[2^20], Range[2^20]]      Now in this case my main problem is of course memory not speed, but it would be nice to see solutions that scale well with this problem. I understand that it is another question, but I want to encourage everyone to post their solutions even if they require vectors or matrices of integers as input.