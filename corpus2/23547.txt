I'm building a square matrix, with 1s on the diagonal and elements in U the inverse of elements in L, which are random integers drawn from the sequence 1, ..., 9. Given the nature of the problem I need to solve, conceptually this does the trick perfectly.               size = 5; (*size of matrix*)     range = {1, 9}; (*the range of integers, min to max*)     init = RandomInteger[range, size]; (*builds the initial vector*)     matrix = Transpose[Table[init/init[[i]], {i, size}]];       (*constructs the matrix from the initial vector the way the problem requires*)      `matrix` is an "ideal" matrix, because in a second step a hypothetical user should be able to perturb it by modifying the elements in L, with elements in U changing accordingly; i.e., becoming the inverse `matrix[[1,2]] = 1/matrix[[2,1]]`, and so on. This is the best I have done so far to implement the dynamic behavior I want.               onscreen = SparseArray[{       {i_, i_} -> 1,         (*1s on the diagonal*)       {i_, j_} /; i - j >= 1 :> InputField[Dynamic[matrix[[i, j]]]],         (*InputFields to edit L part of matrix*)       {i_, j_} /; i - j <= 1 :> Dynamic[1/matrix[[j, i]]]         (*the U part of matrix - comment below*)       }, {size, size}]      I use `onscreen` as the means for the user to enter the desired values. Now he/she can edit the L part of `matrix`, and the U part of `onscreen` should reflect what is expected in `matrix`. However values in U of `matrix` don't change. How can I make it happen? I should remark that `matrix` will be needed for further calculations, so I can't populate it with `Dynamic`.