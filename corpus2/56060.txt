I noticed a surprising problem when using evaluate to plot multicurve, "evaluate" function actually consider global variable first, not the local! I can illustrate the problem using the following simple example, say I want to plot multicurve Z=1*x^2, 3*x^2, 5*x^2, 7*x^2 using a two-variate function Z[x_,y_]:=y*x^2, the following will work:               Z[x_, y_] := y*x^2;     Needs["PlotLegends`"];     Plot[Evaluate[Table[Z[x, y], {y, 1, 7, 2}]], {x, 1, 5}, PlotRange -> All,      PlotStyle-> {Purple, Red, Green, Blue},      PlotLegend -> Table[Style[SequenceForm["y=", y], Bold, 16], {y, 1, 7, 2}],      AxesLabel -> {"x", "Z"}]      But inserting a global variable (say x=1) before the plot command will over ride the local variable used for the plot range ({x,1,5} in the example). So Instead of plotting Z=1*x^2, 3*x^2, 5*x^2, 7*x^2, it will plot Z=1*1^2, 3*1^2, 5*1^2, 7*1^2. Isn't this counter-intuitive? I think the ListPlot is more intuitive in terms of variable scope. Because the following implementation using ListPlot is not interfered by global variable x.               ListPlot[Table[Table[{x, Z[x, y]}, {x, 1, 5, 0.1}], {y, 1, 7, 2}],      PlotRange -> All, PlotStyle -> {Purple, Red, Green, Blue}, Joined -> True,     PlotLegend -> Table[Style[SequenceForm["y=", y], Bold, 16], {y, 1, 7, 2}],     AxesLabel -> {"x", "Z"}]