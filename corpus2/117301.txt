In a lot of cases I might have an existing class with some behavior:               class Lion     {         public void Eat(Herbivore herbivore) { ... }     }      ...and I have a unit test...               [TestMethod]     public void Lion_can_eat_herbivore()     {         var herbivore = buildHerbivoreForEating();         var test = BuildLionForTest();         test.Eat(herbivore);         Assert.IsEaten(herbivore);     }      Now, what happens is I need to create a Tiger class with idential behavior to that of the Lion:               class Tiger     {         public void Eat(Herbivore herbivore) { ... }     }      ...and since I want the same behavior, I need to run the same test, I do something like this:               interface IHerbivoreEater     {         void Eat(Herbivore herbivore);     }      ...and I refactor my test:               [TestMethod]     public void Lion_can_eat_herbivore()     {         IHerbivoreEater_can_eat_herbivore(BuildLionForTest);     }               public void IHerbivoreEater_can_eat_herbivore(Func<IHerbivoreEater> builder)     {         var herbivore = buildHerbivoreForEating();         var test = builder();         test.Eat(herbivore);         Assert.IsEaten(herbivore);     }      ...and then I add another test for my new `Tiger` class:               [TestMethod]     public void Tiger_can_eat_herbivore()     {         IHerbivoreEater_can_eat_herbivore(BuildTigerForTest);     }      ...and then I refactor my `Lion` and `Tiger` classes (usually by inheritance, but sometimes by composition):               class Lion : HerbivoreEater { }     class Tiger : HerbivoreEater { }          abstract class HerbivoreEater : IHerbivoreEater     {         public void Eat(Herbivore herbivore) { ... }     }      ...and all is well. However, since the functionality is now in the `HerbivoreEater` class, it now feels like there's something wrong with having tests for each of these behaviors on each subclass. Yet it's the subclasses that are actually being consumed, and it's only an implementation detail that they happen to share overlapping behaviors (`Lions` and `Tigers` may have totally different end-uses, for instance). It seems redundant to test the same code multiple times, but there are cases where the subclass can and does override the functionality of the base class (yes, it might violate the LSP, but lets face it, `IHerbivoreEater` is just a convenient testing interface - it may not matter to the end-user). So these tests do have some value, I think. What do other people do in this situation? Do you just move your test to the base class, or do you test all subclasses for the expected behavior? **EDIT** : Based on the answer from @pdr I think we should consider this: the `IHerbivoreEater` is just a method signature contract; it does not specify behavior. For instance:               [TestMethod]     public void Tiger_eats_herbivore_haunches_first()     {         IHerbivoreEater_eats_herbivore_haunches_first(BuildTigerForTest);     }          [TestMethod]     public void Cheetah_eats_herbivore_haunches_first()     {         IHerbivoreEater_eats_herbivore_haunches_first(BuildCheetahForTest);     }          [TestMethod]     public void Lion_eats_herbivore_head_first()     {         IHerbivoreEater_eats_herbivore_head_first(BuildLionForTest);     }