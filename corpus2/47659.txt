As a programmer with a history with procedural languages, the Observer design pattern inmediately springs to my mind when attacking certain class of problems, mostly **UI/notifications** related. A two-pronged question:   * Is the **Observer** pattern well suited to _Mathematica_ style(s)? Or, more generally, can event-driven programming, being mostly about state and asynchronous notifications, be implemented efficiently/elegantly in _Mathematica_? `Dynamic` seems promising, but is a **FE** solution.   * In any case --for educational purposes, maybe,-- how would you implement a bare-bones **Observer** mechanism? I know that taming all `*Values` and assignments is hard or directly impossible without hooks. Let's settle with somewhat useful, instead of perfect: only `OwnValues`, simple `Protect[]`, very simple notification callbacks. Something along the lines of:               ClearAll[a];     a[b_] := b;     a = 2;     Observe[a, observer1 = Print["1.- ", ToString[Unevaluated[#1]], ": ", #2] &];     a = 3      > 1.- a: 3   >  3               Observe[a, Print["2.- ", ToString[Unevaluated[#1]], ": ", #2] &];     a = 4      > 1.- a: 4   >  2.- a: 4   >  4               DownValues[a] = DownValues[a]~Join~{HoldPattern[a[c_]] :> c};     a /: b[Unevaluated[a]] := b;          Set::write: "Tag a in DownValues[a] is Protected."     TagSetDelayed::write: "Tag a in b[a] is Protected."          RemoveObservations[a,observer1];     RemoveObservations[a];     a = 5      > 5 Related:   * Detecting changes of variables' values   * Is it possible to create an event handler for changes in values of variables? and possible starting points:   * Triggering actions when a variable is set   * ValueFunction