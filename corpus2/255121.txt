We're building an application which uses complex data with rich relationships. In order to allow us to make the most of this data and easily extend the model, we have decided to use a graph database (Neo4j with Cypher). I'm exploring the use of a CQRS-based application architecture (without event sourcing) to allow us to fully utilize the flexibility of the graph via varied commands and a flexible, almost ad-hoc read side. What I am currently wrestling with is how to structure the persistence part of the command side in such a way that we retain the flexibility of the graph but don't lose too much structure in the application (e.g. via repetition in Cypher queries or large, overly verbose interfaces). I've considered a few options:   1. Use repositories and aggregates, persisted either via reflection or accessors. The benefit here is that the interfaces are simple, the downside is that the repository itself could become complex for aggregates including many relationships (there are no well-maintained .NET ORMs for Neo4j). Another downside to this is the potential to load lots of unnecessary "aggregate fluff" into the domain for simple commands that don't necessarily need it (this problem applies even if I eventually steer away from CQRS).   2. Specialist repositories that expose more constrained commands (e.g. `AddThingToOtherThing`) that are invoked from command handlers. The benefit here is that there's no unnecessary querying. The downside is potentially large, clumsy repository interfaces (maybe there's a nicer way to break this up?)   3. Use _events_ (not event sourcing) and use event handlers to explicitly execute graph DB commands. The good thing here is I only ever execute the DB commands that I need to but my DAL becomes dispersed and more coupled to the application - thus, potentially harder to maintain. Is there a middle ground/alternative pattern (or even simplification) that I haven't considered?