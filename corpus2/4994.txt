I want a linear interpolation from the following example list:               list={{0.0005023, 22.24}, {0.01457, 21.47}, {0.04922, 19.79},            {0.07484, 18.7}, {0.104, 17.55}, {0.1331, 16.52}, {0.1632, 15.49},           {0.1888, 14.52}, {0.2215, 13.31}, {0.2506, 12.16}, {0.3024, 10.01},            {0.3435, 8.304}, {0.3943, 6.036}, {0.4098, 5.329}, {0.4726, 2.384}};      The easiest way is to use:               Interpolation[list, InterpolationOrder -> 1]      but my `list` will be changing a lot, and the `InterpolatingFunction` takes a lot of time to build:               Timing[        Table[Interpolation[list, InterpolationOrder -> 1][q], {q,           0.0006, 0.4, 0.00001}];]      is 10x slower than:               test=Interpolation[list, InterpolationOrder -> 1];     Timing[Table[test[q], {q,0.0006, 0.4, 0.00001}];]      How can I remove the overhead? **EDIT** (following JxB comment) This compiled version is 5 times faster than the original version, but I don't think Partition is compiling (it appears between all the `List`s when I use `FullForm`); and there's also a `CopyTensor` that _doesn't look good_ :               Compile[{{list, _Real, 2}, {value, _Real, 0}},      Module[{temp},       temp = Select[          Partition[list, 2, 1], #[[1, 1]] <= value && #[[2, 1]] > value &][[1]        ];       temp[[1, 2]] +        (value - temp[[1, 1]])/(temp[[2, 1]] - temp[[1, 1]])*(temp[[2, 2]] - temp[[1, 2]])       ]      ]      Any suggestions? (I don't want to compile to C)