I'm experimenting with different algorithms that approximate pi via iteration and comparing the result to pi. I want to both visualise and perhaps know the function (if any) that describes the increasing trend in accuracy as the number of iterations rises. For example, 1 iteration might give me 3.0, 10 iterations might give me 3.12, 50 iterations might give me 3.1409 etc. The more iterations, the better. Sometimes it might be a case of diminishing returns, running 1000 iterations to get an additional decimal point of correctness - is it worth it? Knowing the sweet spot at which to quit would be nice to know, for each pi approximation algorithm type. I'm a mature programmer who is rekindling an interest in math, and this project idea interests me. Trouble is, I don't know what the correct math and statistical terminology is to describe what I want to do. Could someone please locate my problem within the history of math and possibly illustrate with mathematica? **UPDATE** : To be more specific. My pi generation algorithm produces the following pairs of numbers, where the first number is the number of iterations it looped and the second number is the abs(result - pi) i.e. how much the result differs from pi. The more iterations, the smaller the second number.               data = {{10, 0.19809}, {50, 0.039984}, {100, 0.019998}, {500,      0.00399998}, {1000, 0.002}, {20000, 0.0001}, {100000,      0.00002}, {500000, 4.*10^-6}}      I want to visualize what is going on with the data and find a function that describes what is going on. I'd like to also know what is possible in this area with this sort of data. What I've tried:               ListPlot[data, Joined -> True]      gives me an an almost unreadable graph due to the small numbers involved.               GeneralizedLinearModelFit[data,{x},{x}]      gives me FittedModel[0.0405405 -<<22>> x] which when plotted Show[ListPlot[data,PlotStyle->Red],Plot[%36[x],{x,10,500000}]] gives me a straight line. Not helpful as it doesn't seem to tell me anything about the trend re gradually converging on pi. I think there would be a curve of some sort that would better fit the data, but functions like FindFit seem to require you supply an expression e.g. Log and various parameters a, b etc - but how do I know what expression and what parameters to supply? Should I be looking at Interpolation instead? **UPDATE 2** : Thanks for the answers so far. What's holding me back from accepting an answer is the fact that I'm expecting a curved graph - not a straight line. Because the whole point of more and more iterations is that it gets closer to pi and so the answer must be a curve. And that curve must have a formulae, which it would be nice to have defined. So I did some experimenting in mathematica and came up with a curve after all. Here's how I did it. My data came from a crude Wells / Gregory / Leibniz algorithm (see Gregory Series) where I get pi by alternately adding and subtracting 1/n where n is 3, 5, 7... for example               N[(1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + 1/13 - 1/15 + 1/17) * 4]      which gives me 3.25237 - not bad for 8 numbers in the series, or 8 iterations if its a program that's generating the result. So I went on to define a Mathematica function that takes the number of iterations you want and generates pi. The following function also happens to subtract from real pi and return the discrepancy difference. The higher the iterations _it__ passed to this function, the smaller the difference from pi and the smaller the result coming out of this function:               f[it_]:=Abs[N[Sum[(-1)^(n-1)/(2n-1),{n,it}]]*4-\[Pi]]      So my original data points were for 10, 50, 100, 1000, 20000 and 100000 iterations. I thought those would be representative. Thus I can now generate my original data in Mathematica with               data = {{10,f[10]},{50,f[50]},{100,f[100]},{500,f[500]},{1000,f[1000]},{20000,f[20000]},{100000,f[100000]}}     output: {{10,0.099753},{50,0.019998},{100,0.00999975},{500,0.002},{1000,0.001},{20000,0.00005},{100000,0.00001}}      then plot it using the recommended techniques offered as comments and answers on this page               ListLogLogPlot[data,Joined->True,GridLines->Automatic,PlotStyle->Thick]      and I of course get a straight line like everybody else. Hmmm - remember I am after a curve. My instinct tells me it should be a curve. So then I discover that if I generate a more gradual list of points like this:               data = Table[f[x],{x,20}]     ListPlot[data]      then I finally get my curve. ![curved graph](http://i.imgur.com/XkKxiHF.png) Yey! It looks exactly like I imagined it would - curving gradually towards perfection. And if I change the iterations from 20 to 1000 or any higher number, I get the same curve, only smoother. So this is the function I want a precise definition of. Interestingly, if I use the ListLogLogPlot everybody is recommending on my more gradually spaced data               ListLogLogPlot[data, Joined -> True, GridLines -> Automatic, PlotStyle -> Thick]      I get a straight line again! Grrr. ![straight line again](http://i.imgur.com/5tPbiig.png) What I suspect is going on here is that there _was_ probably a curve in the normal ListPlot of my original data but we couldn't see it due to the scaling, which is why we went for the ListLogLogPlot. But that probably turns curves into straight lines (hence the log in the name?) - which disappointed me because I was expecting a visual curve. And I don't think my original choice of x values (representing the number of iterations being fed into my pi calculation function) and how those x values are spaced makes a difference. My x values of 10, 50, 100, 1000, 20000 and 100000 certainly made it hard to see the curve in the graph, but the curve was still probably there. My second, gentler set of x data points (from the same pi generation function) of 1..20 makes the curve ridiculously easy to see. So what counts as an answer to this question?   * An exact definition of the curve being seen here.    * And perhaps some commentary on what functions describing curves typically arise when attempting to visualise pi using iterative techniques. I hope I haven't changed the goal posts in this question. I think I have always asked for an exact definition of the curve in my data plus some commentary of what might be typical / best practice in this sort of visualisation/graphing territory, where there is a known value we are iterating towards.