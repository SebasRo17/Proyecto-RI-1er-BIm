I am trying to define a "postfix map" operator (denoted `$OP$` for now) that behaves thus:               {1, 2, 3} $OP$ # + 1 & == {2, 3, 4}      and               {1, 2, 3} // RotateLeft $OP$ # + 1 & == {3, 4, 2}      and               {1, 2, 3} // RotateLeft $OP$ # + 1 & // Total == 9      I hope not to need parentheses when I pipe results forward using a combination of // and my custom `$OP$`. Is this possible? My guess is that it is not because there is no operator with the same precedence as `//`. I understand that I will need to use either an unassigned operator (e.g., CirclePlus) or another symbol as an infix operator; that I cannot modify precedence; and that the ability to define custom syntax is limited (e.g., `@//` can't be defined). Looking at "Operator Input Forms", it seems the closest I can get to `//` with regard to precedence is either Colon or VerticalSeparator, as               Precedence /@ {Colon, Postfix, VerticalSeparator} == {80., 70., 60.}      **Does this mean that there is simply no way to define the operator I seek in a way that will never require parentheses when it is chained with`//`?** For example, given               SetAttributes[VerticalSeparator, HoldAll];     VerticalSeparator[l_, f_] := f /@ l;      this does not work               {1, 2, 3} \[VerticalSeparator] # + 1 & // Total == {(1 + #1)[1], (1 + #1)[2], (1 + #1)[3]}      Similarly, with               SetAttributes[Colon, HoldAll];     Colon[l_, f_] := f /@ l;      this does not work               {1, 2, 3} // RotateLeft \[Colon] # + 1 & == {2, 3, 1}      I have read, for example, Prefix operator with low precedence , http://stackoverflow.com/questions/5304858/custom-postfix-notation-apply- function .