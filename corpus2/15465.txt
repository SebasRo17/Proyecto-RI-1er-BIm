Say I have a list of values `v = {v1, v2, v3, ... }`. I need to partition these values to perform operations with a sliding window (think `MovingAverage`). I define my window as `{r1, r2}` where `r1` indicates the number of objects to capture to the left and `r2` is the number to the right of each of the `vi`. Thus, my window width is `r1 + r2 + 1`. I have written a function which does this partitioning.               f[list_, {r1_, r2_}] := With[{r = r1 + r2 + 1, n = Length[list]},        Partition[PadRight[PadLeft[list, n + r1], n + r1 + r2], r, 1]       ]      For example.               f[Array[v, 6], {1, 3}]          (*{{0, v[1], v[2], v[3], v[4]}, {v[1], v[2], v[3], v[4], v[5]}, {v[2],        v[3], v[4], v[5], v[6]}, {v[3], v[4], v[5], v[6], 0}, {v[4], v[5],        v[6], 0, 0}, {v[5], v[6], 0, 0, 0}}*)      Is there a way to use the overhang argument to `Partition` so that I can avoid `PadLeft` and `PadRight`? The reason I don't just use this solution is because ultimately I don't want the zeros, I will be working with a ragged array. If I can get the overhang argument right I can just use `{}` for padding saving me from post processing the zeros.