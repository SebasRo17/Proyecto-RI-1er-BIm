First off, I'll admit that I'm a newbie to DDD and need to read the "blue book". I'm building a system that has an AggregateRoot of type "Match". Each Match can have a collection of "Votes" and also has a readonly "VoteCount" property which gets incremented when a user up-votes or down-votes a Match. Since many users could be voting on a Match at the same time, Votes have to be added/removed from the Match and the VoteCount has to be incremented/decremented as one atomic operation involving write locks (with locks handled by the DB). (I need VoteCount as a static value in the database to be queried on efficiently by other processes/components.) It seems to me that if I were adhering to strict DDD, I would be coding this operation as such:   1. An application service would receive a vote request object   2. The service would then retrieve the Match object from a Match Repository   3. The service would then call some sort of method on the Match object to add the Vote to the collection and update VoteCount.   4. The Repository would then persist that Match instance back to the DB However, this approach is not feasible for my application for 2 main reasons, as I see:   1. I'm using MongoDB on the backend and cannot wrap this read-write operation into a transaction to prevent dirty reads of the Match data and its associated Votes and VoteCount.   2. It's highly inefficient. I'm pulling back the entire object graph just to add a Vote and increment VoteCount. Although this is more efficient in a document db than in a relational one, I'm still doing an unnecessary read operation.  Issues 1 & 2 are not a problem when sending a single Vote object to the repository and performing one atomic update statement against Mongo. Could Vote, in this case be considered an "aggregate" and be deserving of its own repository and aggregate status?