I was just wondering why does Java compiler decide whether you can call a method based on the "reference" type and not on actual "object" type? To explain I would like to quote an example:               class A {         void methA() {             System.out.println("Method of Class A.");         }      }          class B extends A {         void methB() {             System.out.println("Method of Class B.");         }         public static void main(String arg[]) {             A ob = new B();             ob.methB();       // Compile Time Error         }     }      This will produce a Compile Time Error that method methB() not found in class A, although Object Reference "ob" contains an object of class B which consists of method methB(). Reason for this is that Java Compiler checks for the method in Class A (the reference type) not in Class B (the actual object type). So, I want to know whats the reason behind this. Why does Java Compiler looks for the method in Class A why not in Class B(the actual object type)?