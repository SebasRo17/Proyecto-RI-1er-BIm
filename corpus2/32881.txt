Imagine I'm running a loop that's manipulating and changing elements in an array. Is it possible for me to create a `ListPlot` output in my notebook that updates on command? I'm imagining taking something like this:               testArray = Array[{0, 0} &, 10^3];     For[i = 1, i <= 10^3, i++,            testArray[[i]] = {i, i};            If[Mod[i, 10] == 0,        Print[ListPlot[testArray, PlotRange -> All]];       ];          ];      And transforming it into something like this (with the imaginary command `fTriggerUpdateForPreviouslyExistingListPlot`):               testArray = Array[{0, 0} &, 10^3];     For[i = 1, i <= 10^3, i++,            testArray[[i]] = {i, i};            If[Mod[i, 10] == 0,        fTriggerUpdateForPreviouslyExistingListPlot[{testArray}];       ];          ];      Here, `fTriggerUpdateForPreviouslyExistingListPlot` is some kind of switch that takes a listplot, say, in another notebook (within the context of the same kernel) or the current one, and plots the new data. Is this possible? * * * The function `Monitor` comes close to what I'm looking for:               testArray = Array[{0, 0} &, 10^3];          Monitor[        For[i = 1, i <= 10^3, i++,          Pause[0.1];          testArray[[i]] = {i, i};        ];     ,     ListPlot[testArray, PlotRange -> All]];          ListPlot[testArray, PlotRange -> All]      However, this updates whenever `testArray` changes, and not on a trigger. I could create a separate `testArrayForMonitor` and move data from `testArray` to `testArrayForMonitor` to trigger an update, but this seems a bit of an odd thing to do, and incurs a significant overhead.