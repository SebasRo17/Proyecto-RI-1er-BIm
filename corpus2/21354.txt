Consider the following modified fibonacci function:               tempHist = $History     $History = 0     ClearAll[fibon]     Options[fibon] = {k -> 1}     fibon[0] = 0;     fibon[1] = 1;     fibon[n_, OptionsPattern[]]:= fibon[n-1] + OptionValue[k] * fibon[n-2]          fibon[30] // Timing           (* {4.111894, 832040} *)     fibon[30, k -> 2] // Timing   (* {4.161676, 1149851} *)      The modification involves a coefficent that multiplies the second term of the recursive definition. Can the idiom `f[x_]:=f[x]= ...` be used to implement memoization in this case? I tried with no luck the following naive approaches for `c`-aching `fibon`               ClearAll[cfibon]     Options[cfibon] = {k -> 1}     cfibon[0] = 0;     cfibon[1] = 1;     cfibon[n_, OptionsPattern[]]:= cfibon[n, OptionsPattern[]] = cfibon[n-1] + OptionValue[k] * cfibon[n-2]          cfibon[30] // Timing          (* {2.1999999997746045*^-5, 832040} *)     cfibon[30, k -> 2] // Timing  (* {2.899999999961267*^-5, 832040} *)      _Something_ is being memoized, but this is not the wanted behavior (note that the two calls return the same value `832040`, the second call is meant return `1149851`). Here is another try:               ClearAll[cfibon]     Options[cfibon] = {k -> 1}     cfibon[0] = 0;     cfibon[1] = 1;     cfibon[n_, OptionsPattern[]]:= cfibon[n, k -> OptionValue[k]] = cfibon[n-1] + OptionValue[k] * cfibon[n-2]          cfibon[30] // Timing     (* {10.664260999999998, 832040} *)          cfibon[30, k -> 2] // Timing     (* {10.677505, 1149851} *)      Now, the results are as expected, by the computation is slower than the non- cached version! So... How to memoize a function with `Options`?