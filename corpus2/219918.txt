I've done this piece of code for creating bernulli samples, but I think that it is a so heavy algorithm because every time I call this recursive function I create a new vector that is passed to it. Is there a way for making this algorithm faster? Here is the algorithm and the description: As already said, this function creates bernulli samples recursively. If `n`, that is the number of elements that should be found, is equals 0 I print the sample. Else to the sample that is passed I add every element of the population (I have to create a vector for everyone of this new samples), and I call the function with this new sample and n(the number of element to be found) decremented.               private static void distribuzioneBernoulli(int n, Vector<Float> population, Vector<Float> sample){         // exit condition, when n equals 0 the fuction doesn't self-calls         if(n==0){             JOptionPane.ShowMessageDialog(null, campione);         }              // Every element of the population is added to the sample,         // and is recalled the function         for(int x = 0; x < population.size(); x++){             Vector<Float> aggiunta = new Vector<Float>(sample);             aggiunta.add(population.elementAt(x));             distribuzioneBernoulli(n-1, population, aggiunta);         }     }