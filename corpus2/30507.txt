My problem starts from attempts at depicting overlapping lines of different thickness, i.e.               ClearAll[line1, line2, overlapping1, overlapping2, ov1Flat, ov2Flat]     line1 = Graphics[{Thickness[0.003], Blue, Line[{{0, 0}, {4, 1}}]}];     line2 = Graphics[{Thickness[0.03], Red, Line[{{0, 0}, {4, 1}}]}];     overlapping1 = Show[{line2, line1}];      ![overlapping lines 2d](http://i.stack.imgur.com/UaB8q.png) I am often annotating parts of a plot with lines of varying thickness and my preferred method of projecting 2D plots onto 3D is by, well, projecting:               ov1Flat = Show[{ContourPlot[Sin[y x], {x, -4, 4}, {y, -4, 4}], overlapping1}];     Graphics3D@(N@First@ov1Flat /. {x_?AtomQ, y_?AtomQ} -> {x, y, 2.})      ![enter image description here](http://i.stack.imgur.com/nDJt5.png) This works really well for projecting `Graphics` objects comprised of polygons onto a plane but I am not happy with the behaviour of `Line` as a 3D object: lines of various thicknesses get turned into ugly cylinders and their overlap doesn't show too well. I know I can use `Texture` to do the same thing but I would like to avoid it. I'd need to adjust the position of a rasterized image which I'd need to rasterize to an acceptable quality etc - in short, I find it dirtier. So I am looking for a failsafe rule that maps lines onto polygons that I can apply to a `Graphics` object before projecting it and turning it into a truly flat `Graphics3D` object. In trying making a rule for lines consisting of two points, I got the following:               overlapping2 =        overlapping1 /. {pre1___, Thickness[a_], mid___, Line[c_],           post___} :> {pre1, mid,           Polygon[           Transpose@(Transpose@c +                4 a (RotationMatrix[π/2].Normalize[                   Flatten@Differences@c]))~Join~            Transpose@(Transpose@Reverse@c -                4 a (RotationMatrix[π/2].Normalize[                   Flatten@Differences@c]))]          , post};     Show[overlapping2]      which probably has a million ways to break, is inefficient etc, but at least works for the toy example of a line consisting of a start and end point. ![overlap2](http://i.stack.imgur.com/CINfw.png) This replicates the line quite well and once projected is still "flat" with the overlaps showing much better:               Show[Graphics3D@(N@          First@Graphics@overlapping2 /. {x_?AtomQ, y_?AtomQ} -> {x, y,            2.}), Lighting -> "Neutral"]      ![line3D](http://i.stack.imgur.com/oORnI.png) but it doesn't like getting combined with other objects:               ov2Flat=Show[{ContourPlot[Sin[y x], {x, -4, 4}, {y, -4, 4}], overlapping2}];     Graphics3D@(N@First@ov2Flat /. {x_?AtomQ, y_?AtomQ} -> {x, y, 2.})      ![projected line](http://i.stack.imgur.com/Eoz36.png). So my question in its most general form would be: **Is there a transformation rule that one can apply to a`Graphics` object so that the said object can be projected to a truly flat `Graphics3D` object (and look good)?** I know that for `Text` this would probably be impossible so something that has the right behaviour for `Line` and `Point` primitives would be great. And a "no" answer that would mean I have to use `Texture` is also OK but as I said, I want this to be a last resort. **\----EDIT----** The reason I want to do the projection is so that I combine two and three dimensional plots. I am stuck with the toy example I made up (which isn't very well suited for this) but it should give an idea:               Show[{Plot3D[8 + Sin[y x], {x, -4, 4}, {y, -4, 4},         MeshFunctions -> {(0.25 #1 - #2) &}, Mesh -> {{0}},         MeshStyle -> {Blue, Thick}, PlotPoints -> 80],       Graphics3D@(N@           First@ov2Flat /. {x_?AtomQ, y_?AtomQ} -> {x, y, 2.})},       PlotRange -> All, BoxRatios -> {Automatic, Automatic, 6}]      ![projection3](http://i.stack.imgur.com/IzJ7r.png) **\----EDIT 2----** Ok, so the only way out seems to be offsetting each polygonised `Line` a little with respect to the overlapping line and all these lines with respect to the projected plane. I think @belisarius's rule based on the line colour is the simplest one to do that (especially if there's a lot of lines to go through) so I'm going with that.