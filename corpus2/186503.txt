In C# it is legal to write               Animal[] a = new Giraffe[4]; //with obvious relationships      Because arrays are covariant. However, this is a breaking relationship. It's a runtime exception to then apply a different type of Animal to this array because the backing store is a `Giraffe`.               a[0] = new Cat(); //KABOOM      Why doesn't the language create a covariant backing store? This doesn't appear to be a limitation of the language because I can create this type of data structure myself:               class Program     {         static void Main(string[] args)         {             A[] a = new B[2];             a[0] = new B();             a[1] = new C();//runtime exception                  var containerLegal = new Container<B, A>();             containerLegal.Add(new B());             containerLegal.Add(new C());//works fine         }     }          class A { }          class B : A { }          class C : A { }          class Container<T,S> where T: class, S     {         S[] s = new S[4];         int currentIndex = 0;              public void Add(S t)         {             s[currentIndex] = t;             currentIndex++;         }     }      I'm cheating a little bit cause I'm not using `T` in `Container<>`...but I think its a fair relationship anyhow.