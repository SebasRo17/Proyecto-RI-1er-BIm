I am writing a php script that carries out a task. One input is a list of options that I need to test for interoperability. If the options are `A B C` then I need to test every combination, but I only keep the options that are compatible ("left to right") and throw away the ones that are not to get a final Result (R).   * A is compatible with B? -> Result   * R with C? -> R rather than:   * A is compatible with B?    * A with B?    * A with C?  The options might be provided in any order but I don't want to bother with the cost of sorting them first. My "left to right" rules imply that the first valid option found dictates compatibility going forward. So `A B C` could mean a different R than `B A C`. Also The options might be interspersed with invalid options. For example `A 0 C` The way I am solving this right now is as follows:   * I stored a predefined list `l` of possible option names with details about the option. Each option has the following static details:      * information about which options it is compatible with ** (starring this as we'll come back to it)     * details about how to implement it     * an index number, `i` ( by definition of it's storage) `l` might look like this (written as JSON for readability here):               { A : { "description"    : "some text to help out",             "index"          : 0,             "conflict"       : (1 << 1 | 1 << 3),             "implementation" : doA()           },       B : { "description"    : "some text to help out",             "index"          : 1,             "conflict"       : (1 << 0 ),             "implementation" : doA()           },     ...     }      When I'm given a list of options the algorithm is this:   * while options      * if option `o` is in the list `l`       * then keep it and find it's index `i` and compatibility "mask" `l[i][m]`       * update the aggregate compatibility "score" `m`       * update the aggregate conflict "score" `c`     * else throw it away for an given `l[i]` it's `m` (`l[i][m]`) is always an integer that represents an item's known compatibility with other items. It is not an array, but rather `m = 1 << i(X) | 1 << i(Y) | 1 << i(Z)` where it is compatible with `X` via it's index, meaning "index of X". So we can rewrite the algorithm more specifically as (still pseudo-code):               for options as o         _m = 1 << l[o][i]         _c = l[o][c]         if( !( _m & c )  && !( m & _c ) )             m |= _m             c |= _c      I'm pretty happy with it right now but since I'm new to using binary operations in a practical way I'm **uncertain as to it's re-use, especially maintenance with a large number of options**. Right now the biggest challenge is that when a new option is added I have to go through all the options to determine if its compatible and update the conflict values. If I get more than a couple of dozen options I may have to use option groups where anything in group must be fully compatible with that group but other groups might be compatible with this group and not share the same compatibility with other groups. I'm also concerned with **readability** for whomever comes after me. Implemented differently, the conflict values might just be a list of items `[A, C, ...]`. But that seems like extra overhead to me and even though conflict values are integers, the raw form of the conflict values directly lists those index values it is in conflict with. e.g. `1 << 1 | 1 << 3` means it is in conflict with whatever is at index 1 and and whatever is at index 3. So I hope that mitigates some of the readability issues. The good things that I see are:   * should be fairly performant   * easy to test new options. I have methods that will give you a sanity check of any options you ask about giving compatibility and conflict lists.    * good for debugging. I simply spit out a combined strategy number into a log and in a compact form I can see what the compatibility choices made were. Small enough I can even put that info into a terse production log as a "code value" **Thoughts?** +1 if you like it. Answers /comments if you have constructive criticism or feedback please side note: To be honest I don't really care about performance here because the task only happens once a day in the middle of the night, but I'm interested in the problem itself and I'm sure this will help me become a better programmer.