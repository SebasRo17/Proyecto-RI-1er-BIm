I have a function that generates lists:               f[n_] := Join @@ Permutations /@ PadLeft@IntegerPartitions[n];      For example               f[3]      > >     {{0, 0, 3}, {0, 3, 0}, {3, 0, 0}, {0, 2, 1}, {0, 1, 2}, >      {2, 0, 1}, {2, 1, 0}, {1, 0, 2}, {1, 2, 0}, {1, 1, 1}} >   `f[3]` returns 10 lists of three elements, which I want to classify this according to certain laws; `{0, 0, 3}, {0, 3, 0}` and `{3, 0, 0}` belong one class with 3 members because `RotateLeft` can transform any one of these into any of the others. Similarly, `{0,1,2}, {1,2,0}` and `{2,0,1}` belong one class with 3 members. `{0, 2, 1}, {2, 1, 0}` and `{1, 0, 2}` belong one class with 3 members. `{1, 1, 1}` belongs to a class of which it is the only member. So the result I want is ![enter image description here](http://i.stack.imgur.com/uHWOG.jpg) I have code that will generate the desired result               m = AbsoluteTime[];     f[n_Integer] := Join @@ Permutations /@ PadLeft@IntegerPartitions[n];     f2[list_] := Module[{n = 1, m = 0},       While[n <= Length[data1],         If[Or @@ (SameQ[data1[[n, 1]], #] & /@             NestList[RotateLeft, list, Length[list] - 1]), data1[[n, 2]]++;          m++; Break[]];        n++];       If[m == 0, AppendTo[data1, {list, 1}]]]     data1 = {{First@f[7], 1}};     f2 /@ Drop[f[7], 1];     Length[f[7]]     data1 // Length     AbsoluteTime[] - m      but it's too slow. When `n = 7`, it takes about 11 seconds, but I want to work with `n` is the range from 14 to 20. how can I improve efficiency the efficiency of my code?