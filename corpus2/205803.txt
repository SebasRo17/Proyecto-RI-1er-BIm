I recently read this question that features, the arrow anti-pattern. I have something similar in code I'm trying to refactor except that it branches. It looks a little something like this:               if(fooSuccess==true&&barSuccess!=true){         if(mooSuccess==true){                .....         }else if (mooSuccess!=true){                .....         }     }else if(fooSuccess!=true&&barSuccess==true){         if(mooSuccess==true){                .....         }else if (mooSuccess!=true){             if(cowSuccess==true){                         .....             }else if (cowSuccess!=true){                         .....             }         }     }     ......      In short it looks like this               if        if          if            if              do something            endif         else if          if            if              do something             endif         endif         else if          if            if              do something             endif         endif      endif      Outline borrowed from Coding Horror article on the subject And the code goes on through different permutations of true and false for various flags. These flags are set somewhere 'up' in the code elsewhere, either by user input or by the result of some method. How can I make this kind of code more readable? My intention is that eventually I will have a Bean-type object that contains all the choices the previous programmer tried to capture with this branching anti-pattern. For instance, if in the outline of the code above we really do only have three, I have an enum set inside that bean:               enum ProgramRouteEnum{         OPTION_ONE,OPTION_TWO,OPTION_THREE;              boolean choice;         void setChoice(boolean myChoice){             choice = myChoice;         }         boolean getChoice(){             return choice;         }     }      Is this an acceptable cure? Or is there a better one?