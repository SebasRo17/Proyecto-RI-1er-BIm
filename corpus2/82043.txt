I just ran across an answer to another question that references the Halting Problem. He starts with this snippet:               def halts( code_block ):         # Some magical code          def whistler():         while halts(whistler):              sys.whistle( 1 )      and then explains how the routine `halts` cannot be defined correctly because it essentially ends up being logically equivalent to "this sentence is false". Aside from the Python-style syntax, this is basically the standard explanation of the halting problem, and I've never understood the concept. Every time I look at that type of example, I think "but why in the world would anyone approach the problem in that way in the first place?" If I wanted to determine a difficult property of a piece of code, such as answering the question of whether or not it halts, there's no way I would put the analysis _inside the code to be analyzed!_ First off, that leads to contradictions like this example, and second, adding analysis code changes the nature of the thing being analyzed. I would almost certainly go about looking for the answer to the question with external tools, not internal ones. So yes, I understand that there's no way to write a correct implementation of `halts` in the example above. But let's restrict ourselves solely to the realm of code that actually can be written correctly, instead of hypotheticals. What's an example of code that can actually be written and executed, for which it is impossible to determine by external analysis whether the code will end up in an infinite loop or whether it will terminate?