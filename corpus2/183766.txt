I have been developing an Immutable queue in java, but the version I have developed is supposedly slow and I have been suggested to create a faster version of the same and I have no idea as to how to accomplish that.               import java.util.ArrayList;     import java.util.List;     import java.util.NoSuchElementException;     public class ImmutableQueueImpl<E> implements ImmutableQueue<E>     {              private List<E> queue;         public ImmutableQueueImpl()         {            queue=new ArrayList<E>();         }              public ImmutableQueueImpl(List<E> queue)         {            this.queue=queue;         }              public ImmutableQueue<E> enqueue(E e)         {                 if(e==null) throw new IllegalArgumentException();                 List<E> clone = new ArrayList<E>(queue);                 clone.add(e);                 return new ImmutableQueueImpl<E>(clone);         }              public ImmutableQueue<E> dequeue()         {                 if(queue.isEmpty())                 {                   throw new NoSuchElementException();                 }                 List<E> clone = new ArrayList<E>(queue);                 clone.remove(0);                 return new ImmutableQueueImpl<E>(clone);         }              public E peek()         {                 if(queue.isEmpty()) throw new NoSuchElementException();                 return queue.get(0);         }               public int size()     {         return queue.size();     }     }      Please suggest any improvements in the implementation or the libraries used . We remove elements from immutable lists all the time and dequeue is just a special case of that. The point is that the result is not really the element, but another immutable list without it. The point of this design is mutation safety and way better in parallelized settings than mutable data structures.