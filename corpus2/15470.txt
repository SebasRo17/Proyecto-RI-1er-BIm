I have a notebook with several examples of very similar computations, each involving the same variable/parameter names of the ingredients used in a final `Manipulate`. For example,               (* example 1 *)     c = 1;     L = 1;     f[x_] = 180 x^4 (1 - x);     g[x_] = 1;     \[Lambda][n_] = ((n \[Pi])/L)^2;     a[n_] = 2/L  Integrate[f[x] Sin[Sqrt[\[Lambda][n]] x], {x, 0, L}];     b[n_] = 2/(L Sqrt[\[Lambda][n]] c) Integrate[g[x] Sin[Sqrt[\[Lambda][n]] x], {x, 0, L}];     u[x_, t_] = Sum[(a[i] Cos[Sqrt[\[Lambda][i]] c t] +         b[i] Sin[Sqrt[\[Lambda][i]] c t]) Sin[Sqrt[\[Lambda][i]] x], {i, 1, 10}];          Manipulate[Plot[u[x, t], {x, 0, L}, PlotStyle -> {Thick, Blue}, PlotRange -> {-15, 15},         AxesLabel -> {x, "u"}], {t, 0, 5}]      followed by               (* example 2 *)     k = .2;     L = 1;     f[x_] = 180 x (1 - x)^4;     \[Lambda][n_] = (((2 n - 1) \[Pi])/(2 L))^2;     b[n_] = 2/L  Integrate[f[x] Sin[Sqrt[\[Lambda][n]] x], {x, 0, L}];     u[x_, t_] = Sum[b[i] Sin[Sqrt[\[Lambda][i]] x] Exp[-\[Lambda][i] k t], {i, 1, 10}];          Manipulate[Plot[u[x, t], {x, 0, L}, PlotStyle -> {Thick, Blue}, PlotRange -> {-1, 16},         AxesLabel -> {x, "u"}], {t, 0, 5}]      As discussed in the documentation, evaluating the second block of code dynamically updates the output of the first `Manipulate` since the underlying quantities being plotted share the name $u(x,t)$ (among other parts) in each. My question then is, what are some good ways to mitigate this behavior other than:   1. Choosing distinct names for all underlying quantities for each problem. (This is intractable since I may have 10+ such exercises in each notebook.)   2. Disabling dynamic updating. (This is unsatisfying since the point here is to see the `Manipulate` "movies".)   3. Wrapping everything in a `DynamicModule`, e.g.,               (* example 1a *)     DynamicModule[{a, b, c, f, g, L, \[Lambda], u},      c = 1;      L = 1;      f[x_] = 180 x^4 (1 - x);      g[x_] = 1;      \[Lambda][n_] = ((n \[Pi])/L)^2;      a[n_] = 2/L  Integrate[f[x] Sin[Sqrt[\[Lambda][n]] x], {x, 0, L}];      b[n_] = 2/(L Sqrt[\[Lambda][n]] c) Integrate[g[x] Sin[Sqrt[\[Lambda][n]] x], {x, 0, L}];      u[x_, t_] = Sum[(a[i] Cos[Sqrt[\[Lambda][i]] c t] +          b[i] Sin[Sqrt[\[Lambda][i]] c t]) Sin[Sqrt[\[Lambda][i]] x], {i, 1, 10}];           Manipulate[Plot[u[x, t], {x, 0, L}, PlotStyle -> {Thick, Blue}, PlotRange -> {-15, 15},          AxesLabel -> {x, "u"}], {t, 0, 5}]]      and then               (* example 2a *)     DynamicModule[{a, b, k, f, L, \[Lambda], u},      k = .2;      L = 1;      f[x_] = 180 x (1 - x)^4;      \[Lambda][n_] = (((2 n - 1) \[Pi])/(2 L))^2;      b[n_] = 2/L  Integrate[f[x] Sin[Sqrt[\[Lambda][n]] x], {x, 0, L}];      u[x_, t_] = Sum[b[i] Sin[Sqrt[\[Lambda][i]] x] Exp[-\[Lambda][i] k t], {i, 1, 10}];           Manipulate[Plot[u[x, t], {x, 0, L}, PlotStyle -> {Thick, Blue}, PlotRange -> {-1, 16},         AxesLabel -> {x, "u"}], {t, 0, 5}]]      This at least does what I am after: the variable/parameter names that are recycled across exercises _are_ localized to its respective `Manipulate`. This just felt a little clunky and requires quite a bit of explanation to students about why we need to do this. I was curious if there were other/better ways to accomplish this (that I could then share with them).