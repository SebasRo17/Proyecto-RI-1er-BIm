I want to cythonize a code in python to speed up the code. In the following you can see my attempt to make my python class understandable for cython:               import numpy as np     cimport numpy as np     ctypedef np.double_t DTYPE_T     cpdef double std_G,v_c     std_G=4.3e-9 # Newton's const   in Mpc (km/s)^2 M_sol^{-1}     v_c = 299792.458 #km/s          cdef extern from "math.h":         double log(double) nogil         double sqrt(double) nogil               cdef extern from "gsl/gsl_math.h":         ctypedef struct gsl_function:             double (* function) (double x, void * params)             void * params          cdef extern from "gsl/gsl_integration.h":         ctypedef struct gsl_integration_workspace         gsl_integration_workspace *  gsl_integration_workspace_alloc(size_t n)         void  gsl_integration_workspace_free(gsl_integration_workspace * w)         int  gsl_integration_qags(const gsl_function * f, double a, double b, double epsabs, double epsrel, size_t limit, gsl_integration_workspace * workspace, double *result, double *abserr)          cdef double do_callback(double x, void* params):           return (<ComovingDistMemoization>params).eval(x)                cdef class ComovingDistMemoization(object):          cdef list _memotable          cdef cosmolgy          def __cinit__(self, cosmology, memotable = None):                   if memotable is None:                 self._memotable = []                   self._memotable = memotable              self.cosmology = cosmology          def __call__(self, double z):                      if z in self._memotable:                 return self._memotable[z]                 def eval(z):                      return 1./sqrt(self.cosmology.hubble2(z))             cdef gsl_integration_workspace* w =gsl_integration_workspace_alloc(1000)             cdef gsl_function F                              F.function = &do_callback              F.params = <void*>self              cdef double result = 3, error = 5             cdef double y, err, dist             gsl_integration_qags (&F, 0, z, 0, 1e-7, 1000, w, &result, &error)              y, err = result, error                   gsl_integration_workspace_free(w)                   dist = self.cosmology.v_c * y  #to get proper units, ie to put in the hubble length                  self._memotable[z] = dist                  return dist               cdef class cosmology(object):         cdef comovingdist         cdef public double omega_m, omega_l, h, w, omega_r, G, v_c         cdef double H0, hubble_length         def __init__(self, omega_m = 0.3, omega_l = 0.7, h = 0.7, w = -1, omega_r = 0., G = std_G):                  self.omega_m = omega_m             self.omega_l = omega_l             self.omega_r = omega_r             self.h = h             self.w = w             self.G = G             self.v_c = v_c                  self.comovingdist = ComovingDistMemoization(self)         def __copy__(self):                  return cosmology(omega_m = self.omega_m, omega_l = self.omega_l, h = self.h, w = self.w, omega_r = self.omega_r, G = self.G)              property H0:            def __get__(self):                return 100*self.h  #km/s/MPC              def hubble2(self, double z):             cdef double inv_a             inv_a = 1.+z             return (self.omega_r*inv_a**4 + self.omega_m*inv_a**3 + \                       self.omega_l*(inv_a**(3*(1+self.w))) + (1 - self.omega_m - self.omega_l - self.omega_r)*inv_a**2)*self.H0**2              property hubble_length:             def __get__(self):                 return self.v_c / self.H0              def rho_crit(self, double z):             return 3.*self.hubble2(z)/(8*np.pi*self.G)                   def angulardist(self, double z, double z2 = None):                 if z2 is None:                 return self.comovingdist(z) / (1+z)                  return (self.comovingdist(z2) - self.comovingdist(z)) / (1+z2)      However one of the places that raises error and I couldn't find so far any substitution and my investigation just reached to this point that the `__copy__(self)` function is not supported by cython. I have read that with `pickle.Pickler`, it is possible to provide a substitution for an **instance** of a class but I don't know how it should produce a copy of a class inside the class?? Update: Is it a right way to replace `__copy__` with the following piece of code:               def __reduce__(self):         return (self.__class__, (), self.__getstate__())     def __getstate__(self):         return (self.omega_m, self.omega_l, self.omega_r, self.h, self.w, self.G, self.v_c)     def __setstate__(self, data):         (self.omega_m, self.omega_l, self.omega_r, self.h, self.w, self.G, self.v_c) = data      My second question is about `property`, have I defined the property in cython or I also need to have a `__set__` function as well? My last question, at this point the code get compiled without any error message but when I call an instance of `cosmology` class in python all them return zero. I am wondering whether the wayI have called for instance `cosmology` class in `ComovingDistMemoization` class and vice versa caused the problem and can not pass info between them ?