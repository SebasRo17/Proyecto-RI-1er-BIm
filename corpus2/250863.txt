The question is how to cope with absence of variable declaration in Python, PHP, and the like. In most languages there is a way to let the compiler know whether I introduce a new variable or refer to an existing one: `my` in Perl (`use strict`) or `\newcommand` vs. `\revewcommand` in LaTeX. This prevents from two major sources of errors and headache: (1) accidentally using the same name of a variable for two different purposes, such as in (PHP)               $v = $square * $height;     <...lots of code...>     foreach ($options as $k => $v)         echo "For key $k the value is $v\n";     <...lots of code...>     echo "The volume is $v";      or a lot nastier (PHP)               $a = [1, 2, 3];     foreach ($a as $k => &$v)         $v++;     foreach ($a as $k => $v)         echo "$k => $v\n";      (can you see a bug here? try it!); and (2) prevent from typos (PHP):               $option = 1;     $numberofelements = 1;     if ($option)     {         $numberofelenents = 2;     }     echo $numberofelements;      (can you see a bug here? PHP will execute silently). Using something like `my` (Perl)               use strict;      my $option = 1;     my $numberofelements = 1;     if ($option)     {         $numberofelenents = 2;     }     say $numberofelements;      (Perl will immediately report the bug) is a tiny effort and HUGE benefit both in debug time and (much more importantly) in losses (potentially huge) from incorrect programs. However, some languages, notably Python, PHP, and JavaScript, do not give any protection from these types of bugs. My question is how can we effectively cope with this? The only way I can foresee is to create two functions (PHP):               function a ($x)     {         if (isset ($x))             die();         else             return &$x;     }      and               function the ($x)     {         if (isset ($x))             return &$x;         else             die();     }      and use them always:               a($numberofelements) = 1;     the($numberofelenents)++;     say the($numberofelements);      but of course this is extremely cumbersome. Any better way of effectively protecting from such errors? No, "use another language", "be careful and don't make errors", and "split your code in tiny functions" are not good answers (the latter may protect from the errors of type 1 but not type 2).