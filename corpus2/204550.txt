I'm in the middle of a redesign on the part of my current project that deals with user permissions and authorization. I have an interface named `IUserPermissions` that encapsulates this information. One part of a user's permissions are the **Roles** which they are a member of. I'm trying _not_ to violate the Open/Closed Principle by adding every possible role to `IUserPermissions` as a property like this:               interface IUserPermissions {         bool IsAdmin { get; set; }         bool IsDeveloper { get; set; }         // Many more...Yuck.     }      I feel that having an interface like this would suit the OCP better:               interface IUserPermissions {         ICollection<IRole> Roles { get; }         bool IsInRole<T>() where T : IRole;  /* (For convenience; Would probably be                                                  implemented as an extension method) */     }     interface IRole {         string Name { get; }     }     public class AdminRole : IRole {         public string Name { get { return "Admin"; } }     }      Where I'm falling down is how to _implement_ something like this. I'm using the ASP.NET Roles API as the backing store, meaning I'll be given a `string[]` of role names for the user. My `IUserPermissions` implementation would have to start with this collection of strings and somehow work _backwards_ , then instantiate a bunch of appropriate `IRole`s to populate the `Roles` property. This could be done by scanning the assembly for `IRoles` with a parameterless constructor, instantiating them, and reading their `Name` property, but...ugh. How can I fix this design so that I don't _have_ to do this?