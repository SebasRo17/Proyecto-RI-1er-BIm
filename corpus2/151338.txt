I'm learning OpenGL with C and that makes me include the `windows.h` file in my project. I'd like to look at some more specific windows functions and I wonder if you can cite some good sources for learning the basics of Win32 and Win64 programming in C (or C++). I use MS Visual C++ and I prefer to stick with C even though much of the Windows API seems to be C++. I'd like my program to be portable and using some platform-indepedent graphics library like OpenGL I could make my program portable with some slight changes for window management. Could you direct me with some pointers to books or www links where I can find more info? I've already studied the OpenGL red book and the C programming language, what I'm looking for is the platform-dependent stuff and how to handle that since I run both Linux and Windows where I find the development environment Visual Studio is pretty good but the debugger gdb is not available on windows so it's a trade off which environment i'll choose in the end - Linux with gcc or Windows with MSVC. Here is the program that draws a graphics primitive with some use of windows.h This program is also runnable on Linux without changing the code that actually draws the graphics primitive:               #include <windows.h>     #include <gl/gl.h>          LRESULT CALLBACK WindowProc(HWND, UINT, WPARAM, LPARAM);     void EnableOpenGL(HWND hwnd, HDC*, HGLRC*);     void DisableOpenGL(HWND, HDC, HGLRC);               int WINAPI WinMain(HINSTANCE hInstance,                        HINSTANCE hPrevInstance,                        LPSTR lpCmdLine,                        int nCmdShow)     {         WNDCLASSEX wcex;         HWND hwnd;         HDC hDC;         HGLRC hRC;         MSG msg;         BOOL bQuit = FALSE;         float theta = 0.0f;              /* register window class */         wcex.cbSize = sizeof(WNDCLASSEX);         wcex.style = CS_OWNDC;         wcex.lpfnWndProc = WindowProc;         wcex.cbClsExtra = 0;         wcex.cbWndExtra = 0;         wcex.hInstance = hInstance;         wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);         wcex.hCursor = LoadCursor(NULL, IDC_ARROW);         wcex.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);         wcex.lpszMenuName = NULL;         wcex.lpszClassName = "GLSample";         wcex.hIconSm = LoadIcon(NULL, IDI_APPLICATION);;                   if (!RegisterClassEx(&wcex))             return 0;              /* create main window */         hwnd = CreateWindowEx(0,                               "GLSample",                               "OpenGL Sample",                               WS_OVERLAPPEDWINDOW,                               CW_USEDEFAULT,                               CW_USEDEFAULT,                               256,                               256,                               NULL,                               NULL,                               hInstance,                               NULL);              ShowWindow(hwnd, nCmdShow);              /* enable OpenGL for the window */         EnableOpenGL(hwnd, &hDC, &hRC);              /* program main loop */         while (!bQuit)         {             /* check for messages */             if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))             {                 /* handle or dispatch messages */                 if (msg.message == WM_QUIT)                 {                     bQuit = TRUE;                 }                 else                 {                     TranslateMessage(&msg);                     DispatchMessage(&msg);                 }             }             else             {                 /* OpenGL animation code goes here */                      glClearColor(0.0f, 0.0f, 0.0f, 0.0f);                 glClear(GL_COLOR_BUFFER_BIT);                      glPushMatrix();                 glRotatef(theta, 0.0f, 0.0f, 1.0f);                      glBegin(GL_TRIANGLES);                          glColor3f(1.0f, 0.0f, 0.0f);   glVertex2f(0.0f,   1.0f);                     glColor3f(0.0f, 1.0f, 0.0f);   glVertex2f(0.87f,  -0.5f);                     glColor3f(0.0f, 0.0f, 1.0f);   glVertex2f(-0.87f, -0.5f);                      glEnd();                      glPopMatrix();                      SwapBuffers(hDC);                      theta += 1.0f;                 Sleep (1);             }         }              /* shutdown OpenGL */         DisableOpenGL(hwnd, hDC, hRC);              /* destroy the window explicitly */         DestroyWindow(hwnd);              return msg.wParam;     }          LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)     {         switch (uMsg)         {             case WM_CLOSE:                 PostQuitMessage(0);             break;                  case WM_DESTROY:                 return 0;                  case WM_KEYDOWN:             {                 switch (wParam)                 {                     case VK_ESCAPE:                         PostQuitMessage(0);                     break;                 }             }             break;                  default:                 return DefWindowProc(hwnd, uMsg, wParam, lParam);         }              return 0;     }          void EnableOpenGL(HWND hwnd, HDC* hDC, HGLRC* hRC)     {         PIXELFORMATDESCRIPTOR pfd;              int iFormat;              /* get the device context (DC) */         *hDC = GetDC(hwnd);              /* set the pixel format for the DC */         ZeroMemory(&pfd, sizeof(pfd));              pfd.nSize = sizeof(pfd);         pfd.nVersion = 1;         pfd.dwFlags = PFD_DRAW_TO_WINDOW |                       PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;         pfd.iPixelType = PFD_TYPE_RGBA;         pfd.cColorBits = 24;         pfd.cDepthBits = 16;         pfd.iLayerType = PFD_MAIN_PLANE;              iFormat = ChoosePixelFormat(*hDC, &pfd);              SetPixelFormat(*hDC, iFormat, &pfd);              /* create and enable the render context (RC) */         *hRC = wglCreateContext(*hDC);              wglMakeCurrent(*hDC, *hRC);     }          void DisableOpenGL (HWND hwnd, HDC hDC, HGLRC hRC)     {         wglMakeCurrent(NULL, NULL);         wglDeleteContext(hRC);         ReleaseDC(hwnd, hDC);     }