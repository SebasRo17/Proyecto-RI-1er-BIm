I want to implement loose coupling in a project. I know two examples of successful loose coupling designs:   1. On a Unix workstation, shell scripts realise a loose coupling between basic utilities. The loose coupling relies on the shell's ability to _blindly_ redirect data flows between utilities, without having any knowledge on the structure. Utilities agree on a common form to cooperate like a _pipe-separated format_ for sort, cut, paste, awk, etc., a svn dump or a _trivial dump_ of a normalised SGML document (with onsglmls).   2. On a Mac OS X system, Applescripts can be regarded as a loose coupling. In these two examples, I see that cooperating components agree on a common protocol to serialise and deserialise data that needs to be exchanged. Thus components depend on the serialisation protocol rather than on internal representation of data. Is the implementation of a stable communication protocol between application components a winning strategy to implement loose coupling (and good encapsulation)? To solve ties, I also ask what would be a nice name for the protocol artefacts: “data” is a bit vague and there is a lot of them at various places in a software!