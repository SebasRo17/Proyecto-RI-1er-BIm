I've made a little library called SignalR.EventAggregatorProxy Before I push it into 1.0 state I need to fix so it works safely with concurrent operations. Easiest way is lock all operations but thats a huge performance impact. The library queues event subscriptions and when a event comes in it checks the subscriptions and updates the clients using SignalR This is the class that holds the subscriptions There are 3 methods that write/read to the subscription collection(s) (I aggregate the subscription both on a client level and event level, so its two collections)   * Subscribe    * UnsubscribeConnection   * Unsubscribe And one that that reads   * Handle I realize since this is a library I can't make it optimum for all users of the library, but how do I find a good middle way that does not use locks? I think the Handle method is the most important method and should be prioritized for performance over the other 3. I made this little Unittest to test for Concurrency fail **update:** I choose to have locked writes and unlocked reads. The writes didnt mutate existing state but overwrite the collection completely.