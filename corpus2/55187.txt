Recenty,I encounter a problem described as below: > I have a table that owns many boxes,and each box has a sequence like > 1,2,3,4,etc.In addition,every box has a value. > > Now I want to make the value of a box become the average of the values of > boxes that arounding it. > > For example, > > `the value of box 1` become the average of`the values of box 2,11,12`, > > `the value of box 11` become the average of`the values of box 1,2,12,22,21` > > `the value of box 14` become the average of`the values of box > 3,4,5,13,15,23,24,25`               Grid[Reverse@Partition[Range[80], 10], Frame -> All]      ![enter image description here](http://i.stack.imgur.com/ufgS6.png)               sequenceValue = Thread@List[Range[80], RandomInteger[{0, 1}, 80]];     Reverse@Partition[sequenceValue, 10] // Grid[#, Frame -> All] &      ![enter image description here](http://i.stack.imgur.com/Mizh4.png) ### My trial **Extract the sequence of the boundary of table**               ExtractBoundarySequence[length_, width_] := Block[       {bottomData, topData, leftData, rightData, cornerData},      bottomData = Range[2, length - 1];      topData = Range[2 + (width - 1) length, width*length - 1];      leftData = Range[1 + length, 1 + (width - 2) length, length];      rightData = Range[2 length, (width - 1) length, length];       cornerData = {1, length, 1 + (width - 1) length, width*length};      List[cornerData, bottomData, topData, leftData, rightData]     ]      **Extract the sequence of the innerior of table**               ExtractInteriorSequence[length_, width_] := Block[     {},     DeleteCases[      Flatten@Table[{# - 1, #, # + 1} + i *length, {i, -1, 1}], #] & /@      Flatten@Table[Range[2 + length, 2 length - 1]+(i - 1)length , {i, 1, width - 2}]     ]      **Caculate the value of the boundary of table**                CalculateBoundaryValue[SequenceValue_, length_, width_] := Block[      {corner, bottom, top, left, right,       cornerSequence, bottomSequence, topSequence, leftSequence, rightSequence,      value1, value2},      {corner, bottom, top, left, right} =ExtractBoundarySequence[length, width];      bottomSequence = DeleteCases[       Flatten@Table[{# - 1, #, # + 1} + i *length, {i, 0, 1}], #] & /@bottom;      topSequence = DeleteCases[       Flatten@Table[{# - 1, #, # + 1} + i *length, {i, -1, 0}], #] & /@top;      leftSequence = DeleteCases[       Flatten@Table[{#, # + 1} + i *length, {i, -1, 1}], #] & /@ left;      rightSequence = DeleteCases[       Flatten@Table[{# - 1, #} + i *length, {i, -1, 1}], #] & /@ right;          value1 =      Mean /@ (Flatten[       Map[Part[SequenceValue[[All, 2]], #] &,        {bottomSequence, topSequence, leftSequence,          rightSequence}, {2}], 1]);          cornerSequence =     {      DeleteCases[        Flatten@Table[{#, # + 1} + i*length, {i, 0, 1}], #] &[corner[[1]]],      DeleteCases[        Flatten@Table[{# - 1, #} + i *length, {i, 0, 1}], #] &[corner[[2]]],      DeleteCases[        Flatten@Table[{#, # + 1} + i *length, {i, -1, 0}], #] &[corner[[3]]],      DeleteCases[        Flatten@Table[{# - 1, #} + i *length, {i, -1, 0}], #] &[corner[[4]]]     };          value2 =       Mean /@ (Part[SequenceValue[[All, 2]], #] & /@ cornerSequence);           Thread@List[Flatten@{corner, bottom, top, left, right}, Join[value2, value1]]     ]      **Caculate the value of the innerior of table**                CalculateInteriorValue[SequenceValue_, length_, width_] := Block[      {interiorSequence, interiorNumber, value},      interiorSequence =      ExtractInteriorSequence[length, width];      interiorNumber =       Flatten@Table[Range[2 + length, 2 length - 1]+(i - 1)length, {i, 1, width - 2}];      value =          Mean /@ ((Part[SequenceValue[[All, 2]], #] &) /@ interiorSequence);       Thread@List[interiorNumber, value]      ]      **Final sequence-v-alue**               NewSequenceValue[SequenceValue_, length_, width_] := Block[      {NewBoundaryData, NewInteriorData},      NewBoundaryData =      CalculateBoundaryValue[SequenceValue, length, width];      NewInteriorData =      CalculateInteriorValue[SequenceValue, length, width];      SortBy[Join[NewBoundaryData, NewInteriorData], First]     ]      **Using my function:**               Reverse@Partition[NewSequenceValue[sequenceValue, 10, 8], 10] //Grid[#, Frame -> All] &      ![enter image description here](http://i.stack.imgur.com/GyJOm.png) and it can achieve the result. However, I think my method is a little tedious, so my question: is there a better algorithm (method) to solve my problem?