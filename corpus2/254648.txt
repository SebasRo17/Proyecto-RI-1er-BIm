The following code is a test of the IcmpPing routine called from the icmp dll. In debug it works fine but in release it throws an error. The error is caused by the "IcmpCloseHandle" call because calling IcmpSendEcho has somehow changed the handle. It has the feel of a memory problem but so far the only fix I have found it to take a copy of the handle and use that for the close handle call. I have trimmed the code to down to minimum including having the ip address as an integer (127.0.0.1 = $0100007F little endian). What am I doing wrong? I have tested this problem on 2010, XE2 and XE4 all with the same problem. Any ideas * * *               unit icmptest1;          interface          uses     //  Windows, Messages, SysUtils, Variants, Classes, Graphics,     //  Controls, Forms, Dialogs, StdCtrls;       Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,       Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls;          type       TSunB = packed record         s_b1, s_b2, s_b3, s_b4: byte;       end;            TSunW = packed record         s_w1, s_w2: word;       end;            PIPAddr = ^TIPAddr;       TIPAddr = record         case integer of           0: (S_un_b: TSunB);           1: (S_un_w: TSunW);           2: (S_addr: longword);       end;           IPAddr = TIPAddr;            PICMP_ECHO_REPLY = ^ICMP_ECHO_REPLY;       ICMP_ECHO_REPLY = packed record         Address : IPAddr;         Status : ULONG;         RoundTripTime : ULONG;         DataSize : WORD;         Reserved : WORD;         Data : Pointer;       end;            PIP_OPTION_INFORMATION = ^IP_OPTION_INFORMATION;       IP_OPTION_INFORMATION = packed record         Ttl : byte;         Tos : byte;         Flags : byte;         OptionsSize : byte;         OptionsData : Pointer;       end;          type       TForm34 = class(TForm)         Button2: TButton;         procedure Button2Click(Sender: TObject);       private         { Private declarations }       public         { Public declarations }       end;          function  IcmpCreateFile : HWnd; stdcall; external 'icmp.dll';     function  IcmpCloseHandle(const IcmpHandle : HWnd) : longbool; stdcall; external 'icmp.dll';     function  IcmpSendEcho(const IcmpHandle: HWnd; const DestinationAddress: IPAddr ;const RequestData: Pointer;const RequestSize : WORD;const RequestOptions : PIP_OPTION_INFORMATION;const ReplyBuffer : Pointer;const ReplySize : DWORD;const TimeOut : DWORD) : DWORD; stdcall; external 'icmp.dll';          var       Form34: TForm34;          implementation          {$R *.dfm}     {$T+}          function IcmpPing1(): Boolean;     var       dwSize : DWORD;       DW: DWord;       IPAddr: TIPAddr;       EchoReply: ICMP_ECHO_REPLY;       hICMP : HWnd;       Hc: HWnd;          begin       Result := False;       hICMP := IcmpCreateFile;       Hc := hICMP;            if hICMP <> INVALID_HANDLE_VALUE then       begin         try           dwSize := SizeOf(ICMP_ECHO_REPLY) + 8;                IPAddr.S_addr := $0100007F; // 127.0.0.1                ShowMessage(Format('1: %x',[hICMP]));           DW := IcmpSendEcho(hICMP, IPAddr, nil, 0, nil, @EchoReply, dwSize, 500);           hICMP := Hc;           ShowMessage(Format('2: %x',[hICMP]));                Result := (EchoReply.Status = 0);         finally           try             IcmpCloseHandle(hICMP);           except             on e:exception do               ShowMessage(e.Message);           end;         end;       end;     end;          procedure TForm34.Button2Click(Sender: TObject);     begin       ShowMessage(IntToStr(Byte(IcmpPing1())));     end;          end.