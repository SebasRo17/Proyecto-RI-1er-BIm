I'm having a problem I don't understand. I'm developing an OpenGL app for iOS. Because at some points I want to force the orientation of the view programatically, and Apple for whatever reason doesn't make it easy (or even possible), I'm doing it by hand. I return always NO in `shouldAutoRotateToInterfaceOrientation`, and when I want to change the orientation (to portrait, for example), I do something like this in the UIView:               [self setTransform:CGAffineTransformMake(1, 0, 0, 1, 0, 0)];     [self setBounds:CGRectMake(0, 0, 768, 1024)];      This works fine. In order to support Retina devices, I started checking `[UIScreen mainScreen].scale`, and setting `self.contentScaleFactor` accordingly. I also modified the code above to account for the new dimensions, like this:               [self setTransform:CGAffineTransformMake(1, 0, 0, 1, 0, 0)];     [self setBounds:CGRectMake(0, 0, 2*768, 2*1024)];      Same rotation, different size. The weird result with this is that I get a "screen" with the right size, but offsetted half a screen to the bottom and the left. To correct for this, I need to do the following:               [self setTransform:CGAffineTransformMake(1, 0, 0, 1, 0, 0)];     [self setBounds:CGRectMake(-768, -1024, 2*768 - 768, 2*1024 - 1024)];      This works, but it's ugly, I also need to make similar corrections when I get touch coordinates, and worst of all, I don't understand what's going on or why the above "correction" works. Can anyone shed some light on this issue?