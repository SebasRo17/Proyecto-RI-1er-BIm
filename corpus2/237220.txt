I am currently working on a tic tac toe auto-mover game. I have come upon a decent algorithm that allows the computer to easily build towards, and claim victory spots. The problem however is that when the opponent is dangerously close to victory, the computer continues to build towards it's own victory instead of blocking the opponents, is there any way the following algorithm can be optimized to counter that? The algorithm works as follows:   1. Initialize a 3x3 integer array   2. Loop over all possible combinations on the board (0|0, 1|1, 0|2... e.tc).     1. If combination is a immediate victory, stop and return this position.     2. Else initiate a loop (That loops either 1000, 10000 or 100000 times, depending on difficulty)       1. Continually move from both sides randomly till victory is achieved. If victory is by the computer, increment the score counter.   3. Select the board position with the highest score This algorithm works fine and can build towards victory (example:               ·|x|o    ·|x|o    ·|x|o     ·|·|·    x|·|o    x|x|o     ·|·|·    ·|·|·    ·|·|o      However when confronted with a board like this               ·|x|o     o|x|·     ·|·|·      The optimal move should be to break x's chain, but the computer builds towards raising it's own chain i.e moving at 1|2 (The board is 3x3, indexes start from zero. So that'd be the second row's third coloumn). Is there any way to optimize this algorithm such that this weakness goes away?