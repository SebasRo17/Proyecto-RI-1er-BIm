My basic need is I have to take lots of data and other information and assemble it into a function (static parameters). I then need to call the function many times for numerical results for many values of the dynamic parameters. I then need to repeat with a new set of static parameters. I have a workable solution that I'm using now but it does not feel like a slick solution. So I'm looking for some fresh ideas.               MakeRegion[id_, g_, geo_] := (       listend = #[[-1]] & /@ (Select[          FindShortestPath[g, id, #] & /@ (Pick[VertexList[g],              VertexOutDegree[g], 0]), Length[#] > 0 &]);       cond = Table[          {crf, rrf, typerf, ptsrf} = {ApCenter, ApR, Type, ApPoints} /. geo[[listend[[i]]]];          Which[             typerf == "Polygon", PointInPoly[ptsrf, {x, y}],             typerf == "Circle", (x - crf[[1]])^2 + (y - crf[[2]])^2 <= r           ],           {i, 1, Length[listend]}];       Clear[region];       region[x_, y_] := Evaluate[Or @@ cond];       );      I do not think I need to go into the details of the code for you to get the idea. `MakeRegion` takes in geometry information and creates the function `region[x,y]` which is a logical domain that I can use in `NIntegrate` and other functions. Here is a simple example:               Clear[example]     example[a_] := (        Clear[fun];        fun[x_, y_] :=            Evaluate[x Total[RandomVariate[NormalDistribution[], a]] + y ];        );      The function `example` has no return value, but it defines the function `fun`, which I can use until I need to get a new instance of the function `fun` which I do by running `example[a]`.