In a certain wider context, I need to make some delayed definitions, such as `x := a + b + c`, but within these definitions I want `a` and `b` to be evaluated to their current values, not their later values. Here's a bit of code that does the trick:               a = 1; b = 2; c = 5;     With[{a = a, b = b}, x := a + b + c; y := b + c];     a = 10; b = 20; c = 50;      If `x` is printed at the end, it comes out to be `53` and if its definition is inspected with `?x`, it comes out to be `x := 1 + 2 + c`. Likewise at the end `y` is `y := 2 + c`. This is precisely the behaviour I want, but within my wider context, I care about elegance and this is inelegant. So I'd like to be able to define a command (really, a "macro") `WithCurrent`, so that `WithCurrent[{a, b}, delayeddefs]` would be equivalent to `With[{a = a, b = b}, delayeddefs]`. Any ideas?