Most unit testing tutorials/examples out there usually involve defining the data to be tested for each individual test. I guess this is part of the "everything should be tested in isolation" theory. However I've found that when dealing with multi tier applications with a lot of DI, the code required for setting up each test gets very long winded. Instead I've built a number of testbase classes which I can now inherit which has a lot of test scaffolding pre-built. As part of this, I'm also building fake datasets which represent the DB of a running application, albeit with usually only one or two rows in each "table". Is it an accepted practice to predefine, if not all, then the majority of the test data across all the unit tests? **Update** From the comments below it does feel like I'm doing more integration than unit testing. My current project is .net MVC, using Unit of Work over EF Code First, and Moq for testing. I've mocked the UoW, and the repositories, but I'm using the real business logic classes, and testing the controller actions. The tests will often check that the UoW has been committed, e.g:               [TestClass]     public class SetupControllerTests : SetupControllerTestBase {       [TestMethod]       public void UserInvite_ExistingUser_DoesntInsertNewUser() {         // Arrange         var model = new Mandy.App.Models.Setup.UserInvite() {           Email = userData.First().Email         };              // Act         setupController.UserInvite(model);              // Assert         mockUserSet.Verify(m => m.Add(It.IsAny<UserProfile>()), Times.Never);         mockUnitOfWork.Verify(m => m.Commit(), Times.Once);       }     }      `SetupControllerTestBase` is building the mock UoW, and instantiating the `userLogic`. A lot of the tests require having an existing user or product in the database, so I've pre-populated what the mock UoW returns, in this example `userData`, which is just an `IList<User>` with a single user record.