I want to explore the contentions between the two hot topics: Clean code vs. Good performance. (In progress ... please post comments to help me flush out the details of this question. Thanks.) Examples which may help me define the question:   * Windows GDI+ is known to perform work on separate threads, which would have happened in parallel to user's code if run on a multi-processor machine.   * Component Object Model (COM) is a framework which gives class developers the choice to provide parallelizable implementations of interfaces, however bugs which arise from that is not unheard of.   * One way of providing parallelized safety is to ensure that the parallelized work only happen within a single call to the object's method at the outermost API level; the method shouldn't return to the caller until the parallelized work is finished. (Objects and methods which aren't visible to the outside can be parallelized.) Does this make it necessary to build an entire set of flyweight objects just to separate the "Public Objects" from the "Private Objects"?   * SOLID principles encourage extensibility by allowing library users to provide their own implementations of interfaces (through Dependency Injection). How does the library ensure that the user's implementation satisfies the thread-safety requirements?      * Component Object Model uses "thread models" which was an attempt on this issue, however most of the time it only results in deadlocks or failed function calls for the reason that "you are calling from the wrong thread apartment".