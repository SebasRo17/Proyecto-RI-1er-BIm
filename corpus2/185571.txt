So I understand the importance of Polymorphism, including how vital it is. But something I don't quite understand is what about the `Constructor` and any inherited `Class` the initial `Base Class` may have. For example, I have a class to test some criteria- Level of account, Windows Version, and some other checks.               // Base Class     public class CheckInstalled : CheckUserLevel     {            public CheckInstalled()            {                  // Check verify the CheckUserLevel token is true, if it isn't throw an exception and close.                  if (!(_level == true))                  {                         // The above implementation would technically go here.                  }             }                  public virtual void IsInstalled()             {                  // Implementation of initial check of general software.             }     }      So that would in theory be the `Base Class` which will do a Generic check; but there are other applications I need to test if they are installed. So now I would create a `Class` for:   1. Sql   2. IIs   3. Dnn Or whatever you may need to ensure is checked. So for each of those `Classes` I'd inherit the `CheckInstalled Class`. In each one I'd have this:               public override void IsInstalled()     {           // Implementation to check for that specific Class Item is installed.     }      So I see how Polymorphism will really simplify and keep each one of these `Classes` separate. But will provide that flexibility for Object Orientation. **The root of my question, the`Base Class Constructor` contains that inherited token value. But do all other `Classes` that inherit the value? Essentially that `Base Class Constructor` consistently execute? Or does the `_level` token have to be called in each?** Hopefully that makes sense. If not please let me know and I'll try and rephrase it. * * * **Update:** The _level is invoked here:               class CheckUserLevel         {                  // Token Bool:             private bool _level = false;                  #region Constructor:                  protected CheckUserLevel()             {                      // Invoke Method On Creation:                 Elevate();                  }                  #endregion                  public void Elevate()             {                      // Get Identity:                 WindowsIdentity user = WindowsIdentity.GetCurrent();                      // Set Principal                 WindowsPrincipal role = new WindowsPrincipal(user);                      #region Test Operating System for UAC:                      if (Environment.OSVersion.Platform != PlatformID.Win32NT || Environment.OSVersion.Version.Major < 6)                 {                          // False:                     _level = false;                          // Todo: Exception/ Exception Log                      }                      #endregion                      else                 {                          #region Test Identity Not Null:                          if (user == null)                     {                              // False:                         _level = false;                              // Todo: "Exception Log / Exception"                          }                          #endregion                          else                     {                              #region Ensure Security Role:                              if (!(role.IsInRole(WindowsBuiltInRole.Administrator)))                         {                                  // False:                             _level = false;                                  // Todo: "Exception Log / Exception"                              }                              else                         {                                  // True:                             _level = true;                              }                              #endregion                               } // Nested Else 'Close'                      } // Initial Else 'Close'                  } // End of Class.              }      The separate class actually generates the boolean value; as anytime that class is invoked it will assign a value to it. I didn't want to expose too much with this class mostly because of its role in testing for Administration. The problem: > Several methods will require Administrative Permission; my thought was to > inherit on the base `CheckInstalled`. Which in it's creation will > automatically check the boolean state of `_level`. Then from that point; > this `CheckInstalled` can be inherited to other classes; then I can simply > `override IsInstalled` to bend to the desired task for that item. Is that a bad thought on my part?