I made this function:               f[g_] := Table[{ToExpression[ToString[x] <> ToString[n]], 1, 3}, {n, 1, g}]      When I evaluate the function with some g (say 8), I'll have this output:               {{x1, 1, 3}, {x2, 1, 3}, {x3, 1, 3}, {x4, 1, 3}, {x5, 1, 3}, {x6, 1, 3}, {x7, 1, 3}, {x8, 1, 3}}      When I add flatten to the function:               f[g_] := Flatten[Table[{ToExpression[ToString[x] <> ToString[n]], 1, 3}, {n, 1, g}]]      I'll have:               {x1, 1, 3, x2, 1, 3, x3, 1, 3, x4, 1, 3, x5, 1, 3, x6, 1, 3, x7, 1, 3, x8, 1, 3}      When I actually want:               {x1, 1, 3}, {x2, 1, 3}, {x3, 1, 3}, {x4, 1, 3}, {x5, 1, 3}, {x6, 1, 3}, {x7, 1, 3}, {x8, 1, 3}      I have also tried to use the `Flatten[]` with a level:               f[g_] := Flatten[Table[{ToExpression[ToString[x] <> ToString[n]], 1, 3}, {n, 1, g}], 1]      But I was unable to do it. What's happening? I could do it with string manipulation, but I guess there might be a way for `Flatten[]` to work. I'm trying to do this:               ArrayPlot[Table[RandomChoice[{q1, q2, q3} -> Range[1, 3]], {q1, 1, 3}, {q2, 1, 3}, {q3, 1, 3}], Mesh -> True, MeshStyle -> Black]      Where the result of the function is going to replace the `{q1, 1, 3}, {q2, 1, 3}, {q3, 1, 3}`.