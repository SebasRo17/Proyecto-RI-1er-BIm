Currently we have a limited number of ways to perform asynchronous evaluation. The most common is through `Dynamic` and `Manipulate`. Using `Dynamic`, we can have part of a cell update independent of whatever we're working on:               Dynamic["x = " <> ToString@x]     For[i = 0, i < 100, i++, Pause[0.05]; x = i^2];      Similarly, we can use Manipulate to continuously evaluate an expression and output the result:               Manipulate[      {r, v} = {r + dt v, v - dt r};      Show[Graphics@Point[r], PlotRange -> {{-2, +2}, {-2, +2}}],      {{dt, 0.01}, 0.01, 1},           Initialization -> {        r = {0, 1};        v = {1, 0};        }]      We also have a way to submit jobs and have them work independently of each, however it does block any further input:               jobs = Table[        ParallelSubmit[         SingularValueList[RandomReal[1, {1000, 1000}]]],        {10}];          WaitAll[jobs]      The third option gets the closest to being an asynchronous evaluation, however it fails in that it requires any further input to be blocked. What I would love to see is some function, tentatively named `AsynchronousEvaluate`, which does exactly what it name says:               AsynchronousEvaluate[Pause[10];]     Print["Hello!"]; (* Printed immediately *)      Is there any way we can get close to achieving this? My dream is to be able to queue up a job for processing on a parallel kernel with certain constraints (Like `MemoryConstrained`) and be able to just "set and forget." When processing is finished, the result will be returned to me. But in the mean time I can still be productive by doing something else. Asynchronous evaluation is the only piece that's missing from this, and I'd like to do it if it's possible.