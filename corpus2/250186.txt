I'm developing a Django project that basically boils down to:   1. A user submits a form.   2. The Django view parses the form and compiles a representation of that form which is readable by some other 'function'. By 'function', I mean some kind of executable/callable where the Django view may be agnostic about what language that 'function' was written in, or even what hardware it runs on.   3. The Django view passes the compiled form into the 'function'.   4. The 'function' performs its business on the input, then outputs some data in a format readable by the Django view.   5. The Django view reads the output of the 'function' and renders the data to a format that is consumable by the user. In my specific case, the 'function' is a large numerical computation not suitable for plain-vanilla Python. Furthermore, this 'function' has already been developed in C++11 and Python can talk to the compiled binary via os.system and file IO. **My question then is:** _why should I not just use os.system orsubprocess from the Django view_ rather than a) redevelop the 'function' using one of ctypes | swig | Boost.Python | pyrex | cython; b) learn how to write Python extensions and re-write the 'function' accordingly? I have also considered turning the 'function' into a daemon, but I am not experienced enough with daemons to be able to gauge what the consequences of such a design would be. **Are there undesirable/undefined behaviours that would arise from using os.system/subprocess as described above for a Django project that was operating under load?** Is there something else I am missing that is super obvious to everyone else? There is also this related question. But with the scarcity of details in both the OP's use case and in the answers, I am cautious not to fall for my own fallacious confirmation bias.