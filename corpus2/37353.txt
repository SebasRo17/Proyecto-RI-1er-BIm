I'm running code that produces a long combination of rational functions with free constants that need to be tuned such that the combination vanishes. My current method is to put the combination over a single denominator with Together[], then look at the CoefficientArrays[] of the numerator and make sure all entries vanish. The trouble is, the step using Together[] is very time consuming, and seems in some cases to get stuck (basically, the process just runs the CPU with a fixed memory usage for hours, when normally Together has a pattern of rising and falling memory usage as it shrinks the expression it creates). My assumption is that the problem with using Together in this context is that it doesn't just put everything over a single denominator, it also tries to factor out common terms. But I don't _need_ it to factor out common terms, since a failure to factor something will just mean a few more redundant equations to solve. Is there anything like Together, that doesn't bother with trying to cancel things? Or an option to make Together give up after a certain (reasonable) amount of time? Edit: To those suggesting just multiplying through by the product of the denominators, one issue is that not all of the objects are expressed as P/Q. So for example, say I have:               (1/(1-v)-v/(1-w))/((1-v)(1-u)) - (1-w)/(u v w(1-v))      I want this expressed as one object, P/Q, and I don't care about canceling common factors between P and Q. Is there a function that does that? I suppose I could just repeatedly multiply through by all denominators for each subexpression, but that seems inefficient.