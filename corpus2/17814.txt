I have two arrays. The first array consists of tens of millions of rows and three columns with a string, a number, and a string.               array1 = {{string1, 145745, a}, {string2, 56546, a}, {string3, 56546, b},               {string3, 246, b}, {string7, 12355, a}, {string7, 12355, b}}      The second array has hundreds of thousands of rows but also consists of three columns but with a string, a number, and a number.               array2 = {{string1, 145745, 3.14324}, {string3, 56546, -0.34319}, {string7, 12355, 0.23535}}      In `array2`, the first two elements of each row matches the first two elements of a row (or, at most, two rows) in array1. In other words, `array2[[All,{1,2}]]` is a subset of `array1[[All,{1,2}]]`. The goal is to take from `array1` all the rows that have matching rows in `array2` (when comparing only the first two columns from each array). For example, from the two given arrays above, the final result would be               result = {{string1, 145745, a},{string3, 56546, b},{string7, 12355, a},{string7, 12355, b}}      The fastest command I've come up with is               m=Dimensions[array2][[1]];     Do[     Pick[array1,array1[[All,{1,2}]],array2[[i,{1,2}]]]//Sow     ,{i,m}     ]//Reap      but this is still too slow. This is a simple problem, but I am really looking for the fastest method possible. Any ideas? **EDIT** Previously, I erroneously had               array1 = {{string1, 145745, a}, {string2, 56546, a}, {string3, 56546, b},               {string3, 246, b}, {string7, **145745**, a}, {string7, 12355, b}}      which should have been               array1 = {{string1, 145745, a}, {string2, 56546, a}, {string3, 56546, b},               {string3, 246, b}, {string7, **12355**, a}, {string7, 12355, b}}      This has been corrected above.