What's the best way to emulate R's data frames functionality? This includes the ability to select rows and columns in a 2-dimensional table by the string identifiers positioned typically in the first row or column, see this related question, (and thanks to Leonid Shifrin for cluing me to the term 'data frame.') Wrapping a 2D array in the symbol `DF` enables leveraging upvalues to essentially overload `Part` for the getters, here defined separately for singleton and list string arguments; matching uses Position. To select rows at level 1 of the array:               Part[DF[expr_], r_String, rest___] ^:=       expr[[Position[expr, r][[1, 1]], rest]]          Part[DF[expr_], r_List /; And @@ StringQ /@ r, rest___] ^:=       expr[[Position[expr, #][[1, 1]] & /@ r, rest]]      Similarly to get columns at level 2 of the array:               Part[DF[expr_], All, c_String] ^:=       Transpose[expr][[Position[Transpose@expr, c][[1, 1]]]]          Part[DF[expr_], All, c_List /; And @@ StringQ /@ c] ^:=       Transpose[expr][[Position[Transpose@expr, #][[1, 1]] & /@ c]]      These seem to work correctly (though I've not implemented preconditions checks that the header strings are at the correct level or that the array Dimension length is 2), eg given data:               data = {{"ID", "COL1", "COL2", "COL3"}, {"ROW1", 1, 2, 3}, {"ROW2", 4,          5, 6}, {"ROW3", 7, 8, 9}};      yields:               DF[data][[{"ID", "ROW1", "ROW3"}]]          (* {{"ID", "COL1", "COL2", "COL3"}, {"ROW1", 1, 2, 3}, {"ROW3", 7, 8, 9}}*)      and               DF[data][[All, {"ID", "COL2"}]]          (* {{"ID", "ROW1", "ROW2", "ROW3"}, {"COL2", 2, 5, 8}} *)      Note that this mechanism is somewhat more elegant than R, where the string arguments are wrapped in the 'c' function. Several related questions: First, these definitions raise similar errors - why?               UpSetDelayed::write: "Tag String in DF[expr_][[r_String,rest___]] is Protected."      Second - key question - how to define general getter passing row & column arguments to return a subarray, eg `DF[data][[{"ID","ROW1"},{"ID","COL2"}]]` but avoiding replicating the list and singleton combinations above? Is there an implementation of the general case that avoids the special cases?   * Arguments need not include the "ID" row or column, composing the row getter followed by column getter, or vice versa, won't work directly.   * Note the asymmetry and limitation between the methods to access rows and columns: the row accessor is more general since All can be passed as a special case, but also numeric parameters and Spans. Finally, can the UpValues mechanism be used to emulate other data frames functionality? Would it be possible to use as setters? Also, Apparently in R data frames are used to query the data with conditionals. **EDIT** Note, given the comments on computational complexity and scalability, I would like to stress that the primary purpose of this approach is to deal with small to medium datasets imported from Excel, where string headers, unlike RDBMS, are not separated as metadata. In many data analysis applications, for example biomedicine and healthcare, Excel-based workflows are the norm (for input data, intermediates and output). Moreover, query (and statistical) development time dominates execution time. So syntax and modular approaches to data frames outweigh computational complexity considerations.