Do I understand correctly that Liskov Substitution Principle cannot be observed in languages where objects can inspect themselves, like what is usual in duck typed languages? For example, in Ruby, if a class `B` inherits from a class `A`, then for every object `x` of `A`, `x.class` is going to return `A`, but if `x` is an object of `B`, `x.class` is not going to return `A`. Here is a statement of LSP: > Let _q(x)_ be a property provable about objects _x_ of type _T_. Then _q(y)_ > should be provable for objects _y_ of type _S_ where _S_ is a subtype of > _T_. So in Ruby, for example,               class T; end     class S < T; end      violate LSP in this form, as witnessed by the property _q(x)_ = `x.class.name == 'T'` * * * _Addition._ If the answer is "yes" (LSP incompatible with introspection), then my other question would be: is there some modified "weak" form of LSP which can possibly hold for a dynamic language, possibly under some additional conditions and with only special types of _properties_. * * * _Update._ For reference, here is another formulation of LSP that I've found on the web: > Functions that use pointers or references to base classes must be able to > use objects of derived classes without knowing it. And another: > If S is a declared subtype of T, objects of type S should behave as objects > of type T are expected to behave, if they are treated as objects of type T. The last one is annotated with: > Note that the LSP is all about expected behaviour of objects. One can only > follow the LSP if one is clear about what the expected behaviour of objects > is. This seems to be weaker than the original one, and might be possible to observe, but I would like to see it formalized, in particular explained who decides what the expected behavior is. Is then LSP not a property of a pair of classes in a programming language, but of a pair of classes together with a given set of properties, satisfied by the ancestor class? Practically, would this mean that to construct a subclass (descendant class) respecting LSP, all possible uses of the ancestor class have to be known? According to LSP, the ancestor class is supposed to be replaceable with any descendant class, right? * * * _Update._ I have already accepted the answer, but i would like to add one more concrete example from Ruby to illustrate the question. In Ruby, each class is a module in the sense that `Class` class is a descendant of `Module` class. However:               class C; end     C.is_a?(Module) # => true     C.class # => Class     Class.superclass # => Module          module M; end     M.class # => Module          o = Object.new          o.extend(M) # ok     o.extend(C) # => TypeError: wrong argument type Class (expected Module)