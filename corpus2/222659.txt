I distinguish three organisation levels while programming: the library level, the component level and the application level. A library defines functions to solve a range of related problems or preform related operations in _tools and no policies_ manner. An application lets several libraries interact and defines policies for diagnostic, error handling, internationalisation,… A component sits between the library and the application, it handles low-level errors and produce diagnostics, it might old global state and is aware of other components. Now I have a library implemented as a functor parametrised by a module holding a constant _n_ and values associated to different values of _n_ have incompatible types—which is the purpose of implementing the library as a functor. I call such a configuration a _hard_ configuration, because it must somehow be hard-coded in the program. Now I am facing the following problem: In this setting, I want to allow the user of the program to choose the value of _n_ for the duration of the program. Since the library is a functor, one feels forced to write the component interfacing the library to the program as a functor. But I want the choosed value of _n_ to be a property of the component, not of the application, and I want component to be regular modules (no functor allowed). How can I wrap a parametric library (implemented as a functor) in a non- parametric component, so that parameters can be chosen when the application starts? I insist on being able to express the application logic at the highest level in terms of non parametric modules, and want to avoid russian-dolls- alike parametrised modules at this level.