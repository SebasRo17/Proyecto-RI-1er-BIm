I'm currently developing a web-app by myself and have made it a point to use descriptive variable and method names (sometimes at the expense of brevity) in order to minimize commenting. The plan was to code each method using this strategy, then comment after I've completed the method I was currently working on. However, I've found that after (more or less) all of the methods I've completed, in-line comments seemed superfluous. I still follow Javadoc conventions for classes and methods, but as of now my code is for the most part, completely devoid of any in-line comments. Fortunately, I'm still relatively early in the development process and all of the methods' workings are fresh in my head, should a situation arise where I need to write in-line comments. Is this a good strategy? If not, where should I include in-line comments? I've included one of my methods below in order to illustrate how self-documenting it currently is. (I'm using Pelops, which is a Java library used to access a Cassandra database. Without going in too deep in to Cassandra's data model, a row basically corresponds to a relational database tuple, and a column corresponds a column in a relation database table). I'd like to think that even without knowledge of Pelops or Cassandra, that one will be able to understand what is going on in the code. Is this the case? If not, where can I insert comments to make it crystal clear? I hope to abstract any suggestions on comment placement in this code in to all the other methods I've written so far.               /**          * Gathers a user's ID and first name from the database, creates a random activation code for that user and stores          * it in the database, and sends an activation e-mail to that user.               * @param eMail                           a String representation of the e-mail of the user that the e-mail is being sent for          * @throws MyAppConnectionException      if any of the queries is unable to be executed or a problem arises because of one, or if a problem arises while sending the e-mail          */         public static void generateAndSendActivation(String eMail) throws MyAppConnectionException, MyAppActivationException         {             eMail = eMail.toLowerCase();                  try             {                 Selector userIDSelector = Pelops.createSelector(pool);                 Column userIDColumn = userIDSelector.getColumnFromRow("Users_By_Email", eMail, "User_ID", ConsistencyLevel.ONE);                 String userIDString = new String(userIDColumn.getValue());                      Selector firstNameAndStatusSelector = Pelops.createSelector(pool);                 SlicePredicate firstNameAndStatus = Selector.newColumnsPredicate("First_Name", "Status");                 List<Column> firstNameAndStatusColumns = firstNameAndStatusSelector.getColumnsFromRow("Users", userIDString, firstNameAndStatus, ConsistencyLevel.ONE);                      char statusChar = Selector.getColumnValue(firstNameAndStatusColumns, "Status").toChar();                      if(statusChar == 'N')                 {                     String firstNameString = Selector.getColumnStringValue(firstNameAndStatusColumns, "First_Name");                          String activationCode = createRandomCode();                     String activationHash = BCrypt.hashpw(activationCode, BCrypt.gensalt());                          Mutator storeActivationHashMutator = Pelops.createMutator(pool);                     storeActivationHashMutator.writeColumn("Users", userIDString,                             storeActivationHashMutator.newColumn("Activation_Code", activationHash)                             );                          storeActivationHashMutator.execute(ConsistencyLevel.ONE);                     sendEmail(firstNameString, userIDString, eMail, activationCode, "sendActivationCode");                 }                 else                 {                     throw new MyAppActivationException("User with ID " + userIDString + "tried to activate an already activated account");                 }                  }             catch(NotFoundException nfe)             {                 MyAppQueryException bqe = new MyAppQueryException("Account for user with e-mail " + eMail + " not found. Cannot send activation code", nfe);                 bqe.accountDoesNotExist = true;                 throw bqe;             }             catch(PelopsException pe)             {                 MyAppQueryException be = new MyAppQueryException("Unable to carry out one of the operations required to generate and store activation code", pe);                 throw be;             }             catch(MyAppMailException bme)             {                 throw bme;             }         }