This is a follow up to this question. So far, I named "explicit" heads to those that appear explicitly in the expression. For example, `f[x]` has an explicit head. I called "implicit" heads to those that are returned by `Head` but do not appear in the expression. For example, `5` has `Integer` as implicit head. In the comments of the original question, rcollyer pointed out that the head of `Complex[1,2]` is explicit but `f@@Complex[1,2]` is not "decapitated" because `AtomQ@Complex[1, 2]` returns `True`. Then, I came up with the following code:               myAtom /: AtomQ[myAtom[__]] := True     f @@ myAtom[1, 2, 3]     (*f[1,2,3]*)      _How does`Apply` know when the head can be replaced?_ According to the documentation of Apply: > Applying to atomic objects that do not have subparts effectively does > nothing Thus, it seems that checking with `AtomQ` is not enough. One should also check for the existence of parts. For example, `Complex[1,2][[1]]` returns an error but `myAtom[1, 2, 3][[1]]` does not. Incidentally, `TreeForm[Complex[1, 2]]` shows "parts". Hence the question: **Is there a function that makes both checks at once?** * * * Follow up: **Is there any way to make a head non-decapitable?** Is there a statement similar to `myAtom /: AtomQ[myAtom[__]] := True` such that               Map[f, {1, {2, myAtom[3]}}, {-1}]      will return `{f[1], {f[2], f[myAtom[3]]}}`?