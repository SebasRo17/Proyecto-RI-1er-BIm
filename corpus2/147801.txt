I have a fairly large software project written in `c++`. In there, there is a `class foo` which represents a structure (by which i don't mean the programmers struct) in which `foo`-objects can be part of a `foo`-object. Here's `class foo` in simplest form:               class Foo     {         private:             std::vector<unsigned int> indices;         public:             void addFooIndex(unsigned int);             unsigned int getFooIndex(unsigned int);     };      Every `foo`-object is currently stored in an object of `class bar`.               class Bar     {         private:             std::vector<Foo> foos;         public:             void addFoo(Foo);             std::vector<Foo> getFoos();     }      So if a `foo`-object should represent a structure with a "inner" foo-object, I currently do               Foo foo;     Foo innerFoo;     foo.addFooIndex(bar.getFoos().size() - 1);     bar.addFoo(innerFoo);      And to get it, I obviously use:               Foo foo;     for ( unsigned int i = 0; i < foo.getFooIndices().size(); ++i )     {         Foo inner_foo;         assert( foo.getFooIndices().at(i) < bar.getFoos().size() );         inner_foo = bar.getFoos().at(foo.getFooIndices().at(i));     }      So this is not a problem. It just works. But it's not the most elegant solution. I now want to make the inner `foo`s to be "more connected" with the `foo`-object. It would be obviously to change `class foo` to:               class Foo     {         private:             std::vector<Foo*> foo_pointers;         public:             void addFooPointer(Foo*);             std::vector<Foo*> getFooPointers();     };      So now, for my question: How to gently change this basic class without messing up the whole code? Is there a "clean way"?