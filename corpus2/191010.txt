I do not consider myself a DDD expert but, as a solution architect, do try to apply best practices whenever possible. I know there is a lot of discussion around the pro's and con's of the no (public) setter "style" in DDD and I can see both sides of the argument. My problem is that I work on a team with a wide diversity in skills, knowledge and experience meaning that I cannot trust that every developer will do things the "right" way. For instance, if our domain objects are designed so that changes to the object's internal state is performed by a method but provide public property setters, someone will inevitable set the property instead of calling the method. Use this example:               public class MyClass     {         public Boolean IsPublished         {             get { return PublishDate != null; }         }              public DateTime? PublishDate { get; set; }              public void Publish()         {             if (IsPublished)                 throw new InvalidOperationException("Already published.");                  PublishDate = DateTime.Today;                  Raise(new PublishedEvent());         }     }      My solution has been to make property setters private which is possible because the ORM we are using to hydrate the objects uses reflection so it is able to access private setters. However, this presents a problem when trying to write unit tests. For example, when I want to write a unit test that verifies the requirement that we can't re-publish, I need to indicate that the object has already been published. I can certainly do this by calling Publish twice, but then my test is assuming that Publish is implemented correctly for the first call. That seems a little smelly. Let's make the scenario a little more real-world with the following code:               public class Document     {         public Document(String title)         {             if (String.IsNullOrWhiteSpace(title))                 throw new ArgumentException("title");                  Title = title;         }              public String ApprovedBy { get; private set; }         public DateTime? ApprovedOn { get; private set; }         public Boolean IsApproved { get; private set; }         public Boolean IsPublished { get; private set; }         public String PublishedBy { get; private set; }         public DateTime? PublishedOn { get; private set; }         public String Title { get; private set; }              public void Approve(String by)         {             if (IsApproved)                 throw new InvalidOperationException("Already approved.");                  ApprovedBy = by;             ApprovedOn = DateTime.Today;             IsApproved = true;                  Raise(new ApprovedEvent(Title));         }              public void Publish(String by)         {             if (IsPublished)                 throw new InvalidOperationException("Already published.");                  if (!IsApproved)                 throw new InvalidOperationException("Cannot publish until approved.");                  PublishedBy = by;             PublishedOn = DateTime.Today;             IsPublished = true;                  Raise(new PublishedEvent(Title));         }     }      I want to write unit tests that verify:   * I cannot publish unless the Document has been approved   * I cannot re-publish a Document   * When published, the PublishedBy and PublishedOn values are properly set   * When publised, the PublishedEvent is raised Without access to the setters, I cannot put the object into the state needed to perform the tests. Opening access to the setters defeats the purpose of preventing access. How do(have) you solve(d) this problem?