I'm trying to create a matrix in which the elements are functions of two variables, but I can't figure out how to do it. Is it possible? The only way I could figure out is to define the matrix in terms of two variables, then replace those variables with values later on. Here's my code:               row1 = {};     row2 = {};     For[ii = 1, ii <= Length[modes], ii++,       {l, m} = modes[[ii]];       G1lm = sglm[-2, l, m, \[Theta]] + (-1)^l sglm[-2, l, -m, \[Theta]];       G2lm = sglm[-2, l, m, \[Theta]] - (-1)^l sglm[-2, l, -m, \[Theta]];       AppendTo[row1, G1lm Cos[m \[Phi]]];       AppendTo[row1, G1lm Sin[m \[Phi]]];       AppendTo[row2, G2lm Sin[m \[Phi]]];       AppendTo[row2, -G2lm Cos[m \[Phi]]];       ];     proj = {row1, row2};      Theta and Phi are my variables. Later on, when I want proj for a specific Theta and Phi I use replace:               pN = proj /. {\[Theta] -> a, \[Phi] -> b};      where a and b are some numbers. The problem with this solution is that if I use Theta and Phi for something else later on, say I set Theta = 0.5, then proj will permanently have Theta = 0.5, regardless of the replace I use. This happened to me: I was calling proj in a loop, but I kept getting the same results. After ripping my hair out for a few hours, I realized I had Theta set to a specific value in a block of code further up in my notebook. The simple solution is to simply not use Theta and Phi anywhere else in the notebook, but that doesn't seem very stable. The root problem here is I'm using global variables to do something that should really be local to proj, but I don't know how to fix that. The ideal would be if I could somehow make proj a function of Theta and Phi so that later on I can simply do `pN = proj[a,b]`. I know how to make the Gnlm's functions of theta, but then I don't know how to make row1, row2, and by extension proj, functions of Theta (and Phi). Any help would be greatly appreciated.