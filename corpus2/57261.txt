In Wellin's Programming with Mathematica book, here's one of his implementations of the Newton method, where the iteration runs until the error tolerance is reached. ![Mathematica graphics](http://i.stack.imgur.com/EnGoj.png) ![Mathematica graphics](http://i.stack.imgur.com/i4rj2.png)               Clear[findRoot]     findRoot[expr_, {var_, init_}, ϵ_] :=      Module[{xi = init, fun = Function[fvar, expr]},       While[Abs[fun[xi]] > ϵ,        xi = N[xi - fun[xi]/fun'[xi]]];       {var -> xi}]          findRoot[x^3 - 2, {x, 2.0}, 0.0001]     (* {x -> 2.} *)      As you could see the result is clearly wrong. I think it's because of the presence of `fvar` in the body of `Function`, which was never defined. I think he meant to use `var`. I tried that, and it works, but there was a warning that `"The variable name has been used twice in a nested scoping construct, in a way that is likely to be an error"`, with `var` highlighted in red. ![Mathematica graphics](http://i.stack.imgur.com/pU2zC.png) Should I be concerned about this warning? In what circumstances would that be an issue? Please feel free to come up with examples of your own. **Edit** : Here's a way that I found that avoid the scoping warning: ![Mathematica graphics](http://i.stack.imgur.com/RpuBw.png) Is this a better way? I think the main reason of using `Function` in Wellin's case and defining a function within the `Module` here is to make a regular expression (which can't take in variable directly) become a function that could take in a value (`xi` in this function). What's the best way to do it? This is closely related to this question here.