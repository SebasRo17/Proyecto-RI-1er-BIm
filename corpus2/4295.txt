I want to repeatedly call a module by using a Table statement. When I use an `i` iterator in the Table command calling the module, I receive the error message "Table::itraw: Raw object 1 cannot be used as an iterator. >>" The module also contains a separate Table statement with the `i` iterator. I noticed that when I change the iterator in the Table statement calling the module to something else, say `v` I no longer get the error message above. This makes me think the `i` iterator is leaking into the module, so .... _Question 1_ : Am I correct that the value of the `i` iterator from the Table statement calling the Module is leaking into the module? _Question 2_ : Is this expected behavior? _Question 3_ : Why does this happen? _Question 4_ : Is there another way to solve this problem, other than to avoid the use of `i` as an iterator in both the Table calling the module and the module itself? Thank you for any advice! Todd * * * Here is a snippet of the offending code:               errorcorrection[signaltype_,chipid_,probesetpostocheck_]:=Module[{clusters,positions,loopindex,groupminuscurrent,similarprobesets},          loopindex=1; (* initialize while loop index to 1; this loop continues for the length of the number of probesets that need checked for unusual signal - which is the length of the probesetpostocheck *)          While[loopindex<=2(*Length[probesetpostocheck[chipid]]*),          clusters=Flatten[Drop[Sort[FindClusters[signaltype[chipid][[probesetpostocheck[chipid][[loopindex]]]],3,DistanceFunction->EuclideanDistance,Method->"Agglomerate"]],-1]]; (* locate probe signals within the current probeset being evaluated that are unreliable and need replaced *)          Print[clusters];          With[{i=i},positions=Flatten[Table[Position[signaltype[chipid][[probesetpostocheck[chipid][[loopindex]]]],clusters[[i]]],{i,1,Length[clusters]}]]]          Print[positions];          If[MemberQ[controlchips,chipid],          (groupminuscurrent=DeleteCases[controlchips,x_/;x==chipid];     similarprobesets=Table[signaltype[groupminuscurrent[[i]]][[probesetpostocheck[chipid][[loopindex]]]],{i,1,Length[groupminuscurrent]}]),          (groupminuscurrent=DeleteCases[experimentchips,x_/;x==chipid];     similarprobesets=Table[signaltype[groupminuscurrent[[i]]][[probesetpostocheck[chipid][[loopindex]]]],{i,1,Length[groupminuscurrent]}])]          Print[similarprobesets];          loopindex++]]      * * *               run2 = Table[       errorcorrection[pmsignal, experimentchips[[i]], pmpostocheck], {i,         1, 1}]               {11719.,1567.,2149.,2001.,1781.,1693.}          Table::itraw: Raw object 1 cannot be used as an iterator. >>          Table[Position[pmsignal[GSM356796][[pmpostocheck[GSM356796][[loopindex$112290]]]],clusters$112290[[1]]],{1,1,Length[clusters$112290]}]      * * *               run3 = Table[       errorcorrection[pmsignal, experimentchips[[v]], pmpostocheck], {v,         1, 1}]          {11719.,1567.,2149.,2001.,1781.,1693.}          {7,6,8,9,17,20}      * * * After considering everyone's responses below, I have been able to get my code to work better by replacing the `With[{i=i},positions=Flatten ....` statement inside the errorcorrection module with `Module[{i=i},positions=Flatten ....` As noted `Block` also works fine. I am still puzzled, however, why `i` takes on a value of 1 inside the `errorcorrection` module, when the module is called by this statement:               run2 = Table[errorcorrection[pmsignal, experimentchips[[i]], pmpostocheck], {i, 1, 1}]      An example of output showing the iterator `i` is here:               run2 = Table[errorcorrection14[pmsignal, experimentchips[[i]], pmpostocheck], {i, 1, 1}]               {11719.,1567.,2149.,2001.,1781.,1693.}      `i` equals 1               {7,6,8,9,17,20}      _Question 5_ : (continuing from numbering above): Doesn't the `Table` command in `run2=Table[errorcorrection14[pmsignal, experimentchips[[i]], pmpostocheck], {i, 1, 1}]` localize the iterator? _Question 6_ : If so, why does that value show up in the `errorcorrection` module? _Question 7_ : If `i` did NOT take on the value of 1 (or any value) in the `errorcorrection` module, would my original `With[{i=i},positions=Flatten` statement have worked ok? It seems to me (in my naivety) that the problem with using With in this case, is that `i` is taking on a value in the module from the `Table` statement calling the module .... but I thought Table should localize `i` and prevent its value from going into the module?? Thank you again, as I struggle to understand at a "deeper" level.