Is there a known method or pattern to implement a simple controller for an MVC design in pure C or the switch case approach is the standard? **Background :** I have an embedded application and I'm pleased with how the business logic turned out. I also finished the UI which boils down to basically 2 functions:               uint8_t getInput(void);     void display(logger toDestination, char* message, ...)      Inputs can come from multiple sources and outputs can be sent to several destinations. All of that is taken care of so the application has no idea if its run by a PC on on the device. It also has no idea if the events come from humans or are faked by unit tests. Where I struggle is with the application logic. My views are in charge of where and how to display the outputs. My drivers, regrouped into behavioral models providing clear features, know _how_ to do their jobs very well but not _when_. Here's my functional rough draft, which in my opinion violates principles like DRY, cohesion, flexibility and may present scalability problems: **Rough draft :** (I faked the names and reduced the size but you get the idea) _menu.h_               void goToMainMenu(void); // This is the entry point of the application after everything was setup correctly              void goToFirstSubMenu(void);             void firstFunctionality(void); //The last levels are the ones doing the calls to the business logic             void secondFunctionality(void);             //Other functionality or nested sub-sub-menus              void goToSecondSubMenu(void);             void thirdFunctionality(void);              int doSomethingWithTheBusinessLogic(int arg1, char arg2, void* arg3);              //Other sub-menus and options              /* And so on, the function prototype are indented to reflect the logical level of the menus.*/      Then most of the functions will roughly look like this: _menu.c_               void goToMainMenu(void)     {       uint8_t choice = 0;       resetDefaultState();             do       {         display(toTerminal, "Press 1 to go to sub-menu 1" ENDL);         display(toTerminal, "Press 2 to go to sub-menu 2" ENDL);         display(toTerminal, "Press 3 to do something with the drivers" ENDL);         display(toTerminal, "Press z to go back." ENDL);              choice = getChar(); /* Blocking thread waiting for events to pop from the other threads */              if     (choice == '1'){ goToFirstSubMenu(); }         else if(choice == '2'){ goToSecondSubMenu(); }         else if(choice == '3'){ doSomethingWithTheBusinessLogic(); }            }while(choice != 'z');            resetDefaultState();        /* When a submenu returns we're taken to the parent menu's do-while loop */     }        * Is it a good way to do things for small-medium systems?   * How could this be improved considering the limits of C and embedded environnements? **What has been tried :** I tried a n-ary tree approach where nodes are menus and leaves are functionality but without polymorphism it's hard to define elegently how both should behave to inputs. The strongly typed system also makes it hard to do a simple callbacks system because I end up needing tons of wrappers around the drivers to unifiy a single callback signature (`void myCallback(void*)`). It also seem to be overkill for this simple state-flow; I feel like I'm working against KISS and productivity only because I've been hammered with "chains of if-elses is the devil". **What I would like :** With higher level languages usually you can bind events and callbacks. Something along the lines of `bind(myMenu, thisInput, theCallback)` so whenever `myMenu` is focused and an event `thisInput` it raised `theCallback` is called. I'm unsure how to do this in C without going way overboard.