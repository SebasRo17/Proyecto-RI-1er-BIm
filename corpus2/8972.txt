I have two variables A and B that are linked such that changes to one causes the other to be updated to the same value. However at each change I'd also like to know which variable cause the update to happen. I've implemented this functionality using two Dynamic expressions.                label = "Initial";      A = 0; B = 0;           {Dynamic[(If[B != A, (B = A); label = "A"]);, TrackedSymbols :> {A}],        Dynamic[(If[A != B, (A = B); label = "B"]);, TrackedSymbols :> {B}]}           Dynamic[{label, A, B}]      Row[{Button["++A", ++A],Button["++B", ++B]}]       I would like to hide the output of these dynamic expressions in a similar fashion to `DynamicWrapper`, however there seems to be a problem in that `DynamicWrapper` doesn't respect `TrackedSymbols`, and of course only allows a single expression to be tied to an object. The mentioned problem with `DynamicWrapper` is present if the `Dynamic` elements are simply substituted for Dynamic wrappers thus this instead. This, however, is not the main problem, since it seems impossible to have a single `DynamicWrapper` with               DynamicWrapper["Something",     {Dynamic[(If[B != A, (B = A); label = "A"]);, TrackedSymbols :> {A}],      , Dynamic[(If[A != B, (A = B); label = "B"]), TrackedSymbols :> {B}]}     ]      It seems that it will reevaluate the entire expression no matter which symbol changes, however even using multiple wrappers does not work, so the following is not what I want, since I still need multiple elements associated with each event, however I would expect that it worked if it did indeed respect the `TrackedSymbols`:               DynamicWrapper["Something", (Print["A event"];If[B != A, (B = A); label = "A"]);, TrackedSymbols :> {A}]     DynamicWrapper["Something", (Print["B event"];If[A != B, (A = B); label = "B"]),  TrackedSymbols :> {B}]      This to the original working example with Print statements inserted the difference is that the `DynamicWrapper` calls the A event first no matter which variable changed, which seems wrong since changing B should call B event first, then call A event. This seems consistent with `DynamicWrapper` not respecting `TrackedSymbols`, and thus triggering both events on the change, and then adding an additional triggering of B when B=A is set in the A event. **Clarification** There seems to be some confusion, so let me clarify I do not just want an invisible object that when in sight will run the events, ideally I would like to have something akin to:                DynamicWrapper[      Dynamic[{label, A, B}],      {Dynamic[(If[B != A, (B = A); label = "A"]);, TrackedSymbols :> {A}],        Dynamic[(If[A != B, (A = B); label = "B"]);, TrackedSymbols :> {B}]}      ]      Which displays as the expression but keeps the dynamic evaluations "in scope" if it is visible.