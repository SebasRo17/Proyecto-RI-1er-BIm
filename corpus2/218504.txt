When I do my code layout, I like to start with a rather high level view, and then start to delegate actual computation to class or functions that have a bit more detail. Then in these classes of functions, I do the same, layer by layer, until I get to the bottom where I have to do the 'real' action. Example:               def build_table():         legs = get_legs()         plate = get_plate()         return put_together(legs, plate)          def get_legs():         legs = []         for i in [0,1,2,3]:             legs.append(get_leg_from_warehouse())         return legs          def get_plate():         plate = get_plate_from_warehouse()         return finish_plate(plate)          def put_together(legs, plate):         table = Table()         for i in [0,1,2,3]:            table.mount(legs[i])         table.mount(plate)         return table          class Table:         self.component = []         def mount(self, item):             self.component.append(item)      In this way, I find it easy to think about the layout, and hide complexity. I mostly have short pieces of code that are easy to understand. The downside of this is, that when I discover I need a piece of information available at the top of the stack further down, I pass arguments from function to function. In the above example, I might gather 'screws' at the top, and then keep passing them down to a function where they are actually drilled into the wood. This makes it feel that it is not so easy to modify the code, and I wondered what I could do about this. In this example the modified code would look like this:               def build_table():         legs = get_legs()         plate = get_plate()         screws = get_screws()         return put_together(legs, plate, screws)          def get_legs():         legs = []         for i in [0,1,2,3]:             legs.append(get_leg_from_warehouse())         return legs          def get_plate():         plate = get_plate_from_warehouse()         return finish_plate(plate)          def get_screws():         drive_to_hardwarestore()         screws = buy_screws()         drive_home()         return screws          def put_together(legs, plate, screws):         table = Table()         for i in [0,1,2,3]:            table.mount(legs[i], screws)         table.mount(plate, screws)         return table          class Table:         self.component = []         def mount(self, item, screws):             self.component.append((item, screws.pop()))      So besides adding the code for getting screws, I had to modify 4 lines. This would increase linearly with the amount of layers. How can I refactor? On the other hand, how can I avoid this in the first place? Is my design process 'wrong'?