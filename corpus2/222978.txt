Is it a bad idea to add a new method (that implements a new algorithm) to a class library for its new version and expose a version option the consumers can select? It is just for backward compatibility where an old application might need a constant sequence of random numbers for a certain seed number. The following code might speak my idea much better. Hopefully you get the essence.               //Class Library:     namespace MyGenerator     {         public sealed class MyRandom         {             public enum Version { One, Two }// add more options in the future              private int current;             private Version version;                  public MyRandom(int seed, Version version = Version.One)             {                 current = seed;                 this.version = version;             }                  public int Next()             {                 switch (version)                 {                     case Version.One:                         AlgorithmOne();                         break;                     case Version.Two:                         AlgorithmTwo();                         break;                     // add more options in the future                 }                 return current;             }                  private int AlgorithmOne()             {                 current = (current * 1234567890 + 987654321) & 0x7FFFFFFF;                 return current;             }                  private int AlgorithmTwo()             {                 current = (current * current + current) & 0x7FFFFFFF;                 return current;             }             // add more algorithm in the future         }     }      and               //Console Application (for testing purposes):          using MyGenerator;     using System;          namespace ConsoleApplication1     {         class Program         {             static void Main(string[] args)             {                 const int seed = 12345;                 MyRandom rnd = new MyRandom(seed, MyRandom.Version.Two);                 Console.WriteLine(rnd.Next());                 Console.ReadLine();             }         }     }