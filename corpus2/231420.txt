The following Scala code works and can be passed to a Java method expecting a function. Is there a cleaner way to do this? Here's my first pass:               val plusOne = new java.util.function.Function[Int,Int] {       override def apply(t:Int):Int = t + 1            override def andThen[V](after:function.Function[_ >: Int, _ <: V]):         function.Function[Int, V] = ???            override def compose[V](before:function.Function[_ >: V, _ <: Int]):         function.Function[V, Int] = ???     }      Here's my second pass - it uses a generic wrapper for the Java-8 Function interface to make the Scala syntax simpler:               // Note: Function1 is Scala's functional interface,     // Function (without the 1) is Java 8's.     case class JavaFunction1[U,V](f:Function1[U,V]) extends Function[U,V] {       override def apply(t: U): V = f(t)       override def compose[T](before:Function[_ >: T, _ <: U]):         Function[T, V] = ???       override def andThen[W](after:Function[_ >: V, _ <: W]):         Function[U, W] = ???     }          val plusOne = JavaFunction1((x:Int) => x + 1)     val minusOne = JavaFunction1((x:Int) => x - 1)      Can we do better? As a follow-up, is there any chance that Scala will someday use the invoke- dynamic op-code as Java 8 does for its first-class function application? Will that make everything magically work, or will there still need to be a syntactic conversion?