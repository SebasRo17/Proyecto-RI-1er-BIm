It commonly happens that one wants to define some function `foo` which in turn calls some other function (e.g., `Plot`) that can take a vast variety of optional arguments, and one would like to arrange things so that the caller of `foo` can pass optional parameters intended for the second function (e.g., `Plot`) among the arguments to `foo`. The latter is expected to simply pass those arguments right through. The pattern for doing this, according to the documentation, is something like:               foo[x_, y_, z_, opts:OptionsPattern[]] :=         Plot[..., Evaluate[FilterRules[{opts}, Options[Plot]]]]      But now suppose that `foo` in fact makes _two_ calls to `Plot` (for example), and that one wants to provide the caller the opportunity to pass separate sets of optional parameters for the two calls to `Plot`. (In general, these two parameter sets would differ.) How can one retool `foo` so that it can accept 2 sets of optional parameters? Also, how would one actually _invoke_ the function thus defined, with two different, non-empty sets of optional parameters?