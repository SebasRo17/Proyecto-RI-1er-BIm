Let's say I have a method `DoTheThing()` which requires the precondition-check `CanTheThingBeDone()` to return true. The latter method is time consuming as it accesses the database. I'm finding it hard to find a perfect way to perform the precondition check effectively (i.e. _once_ ) while maintaining both readability and API integrity. Observe these examples: **Example 1:**               class System() {         public void DoTheThing() {             if (!CanTheThingBeDone()) throw new Exception(...);             // Do it         }              public bool CanTheThingBeDone() {             // Some time consuming code         }     }          class Consumer() {         public void SomeLargerOperation() {             try {                   system.DoTheThing();             }              catch (Exception) {                  // Error handling             }         }     }      **Example 2:**               class System() {         public void DoTheThing() {             // Do it         }              public bool CanTheThingBeDone() {             // Some time consuming code         }     }          class Consumer() {         public void SomeLargerOperation() {             if (system.CanTheThingBeDone()) {                  system.DoIt();             }         }     }      Both approaches are ok, but both have drawbacks. In _Example 1_ , I'm forcing the consumer to wrap the code in a try-catch for faulty states. These states can be user-triggered so some graceful handling is required. I'm unsure if try-catch for handling user-errors is a good approach. In _Example 2_ I'm handing the responsibility of state-checking over to the consumer, opening up for non-descriptive runtime errors. In _this_ example, CanTheThingBeDone() is checked, but when Jimmy enters the team 1 year from now to develop module 2, that might change. **Example 3:**               class System() {         public bool DoTheThing() {             if (!CanTheThingBeDone()) return false;             // Do it              return true;         }              public bool CanTheThingBeDone() {             // Some time consuming code         }     }          class Consumer() {         public void SomeLargerOperation() {             if (!system.DoTheThing()) ProduceSomeErrorMessage();         }     }      Now in this example, I avoid try-catch for user errors and prevent the actual Do-code to be executed if invalid state, while ensuring the check-code is run only once. But I feel I'm breaking some naming/coding principle when the method is both performing check and modifying class state (I'm pretty sure it even has a name). As a fourth example, I could envision a combination of #1 & #2 where both the consumer and `DoTheThing` calls `CanTheThingBeDone`, but then we're doing the work twice. To sum up - I can't seem to find a best approach. Anyone have a better idea than mine, or suggestions on how to tweak one of these approaches for a better result?