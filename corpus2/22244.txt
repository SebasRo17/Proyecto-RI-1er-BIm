As what is proving to be a difficult, but entertaining task, I am attempting to adapt a 2D meshing algorithm created for MATLAB and port it to Mathematica. I understand meshing functions already exist in Mathematica so this is purely for fun/learning. The paper here describes in great detail the algorithm created for MATLAB, in terms of the non code specific logic and each step of the code. I intend to modify this question as/if suggestions are made to show its progress. To start off simple, I have a box that I'm creating a random selection of meshing points within. I modify these using Delaunay's Triangulation Algorithm and then create an initial triangular mesh. Next, imagining all these points are joined my 'magic springs', if the length, L, of a spring is less than a certain chosen scale length, L0, then it exerts a force on each joining point in the direction of increasing separation, proportional to L-L0. Thus you create a new set of points at a later artificial timestep due to the effect of these psuedoforces. Then if any points are outside of the original box, you drag 'em back in and repeat this process until some sort of equilibrium condition is met. This is the code I've done so far:               SeedRandom[2];     bboxL = 10;     bboxH = 10;     Nnodes = 100;     p0 = Table[0, {i, Nnodes}, {i, 2}];     Do[       p0[[i, 1]] = RandomReal[{0, bboxL}];       p0[[i, 2]] = RandomReal[{0, bboxH}];       , {i, Nnodes}];          timeStep = 0.2;          Needs["ComputationalGeometry`"];     dt = DelaunayTriangulation[p0];     toPairs[{m_, ns_List}] := Map[{m, #} &, ns];     edges = Flatten[Map[toPairs, dt], 1];     Graphics[GraphicsComplex[       p0, {Line[edges], Red, PointSize[Medium], Point[p0]}]]          L0 = 1;     displacement[{m_, ns_List}] :=        Total[Map[         If[Norm[p0[[#, All]] - p0[[m, All]]] <             bboxL*bboxH/Nnodes, -p0[[#, All]] + p0[[m, All]], {0, 0}] &,          ns]];          Do[       p0 = p0 + timeStep*Map[displacement, dt];       Do[        p0[[i, 1]] = Max[p0[[i, 1]], 0];        p0[[i, 2]] = Max[p0[[i, 2]], 0];        p0[[i, 1]] = Min[p0[[i, 1]], bboxL];        p0[[i, 2]] = Min[p0[[i, 2]], bboxH];        , {i, Nnodes}];       dt = DelaunayTriangulation[p0];       edges = Flatten[Map[toPairs, dt], 1];            , {i, 400}];          Graphics[GraphicsComplex[       p0, {Line[edges], Red, PointSize[Medium], Point[p0]}]]       You start off with this mesh: ![](http://i.stack.imgur.com/szgd0.png) Then after some iterations you get: ![](http://i.stack.imgur.com/xhuvg.png) What I'd like to do next is instead of meshing to a boring old square I'd like to be able to mesh to any geometry whether its given in a functional form or an array of points. Can anybody suggest how to proceed? Maybe just a simple circle would be a nice next step for practice? Everyone feel free to edit my post and join in the fun. Many thanks for any help :) Also many thanks go to MarkMcClure for helping me on getting to this stage!