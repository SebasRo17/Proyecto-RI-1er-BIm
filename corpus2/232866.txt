# Background I often use the following lazy initialization pattern:               public class Clazz {       private Object object;            private Object getObject() {         Object object = this.object;              if( object == null ) {           object = createObject();           setObject( object );         }              return object;       }            public Object setObject( Object object ) {         this.object = object;       }            protected Object createObject() { return new Object(); }     }      Member variables are only ever used directly twice (in the accessors), which includes internal calls. This also allows subclasses to inject new behaviour by overriding `createObject()`. # Problem This is a lot of code to ensure every member variable is always initialized. # Question What Java mechanism (syntactic sugar) can simplify the code? For example, Scala has the `lazy` keyword. # Ideas Ideally I would like to code:               public class Clazz {       @lazypolymorph       private Object object;            public Clazz() {         // Uses the object...         System.out.println( getObject().toString() );       }     }      The compiler would then expose a public mutator, a private value accessor, and a protected polymorphic creation method (used by the value accessor), following the typical Java naming conventions introduced in the background section.