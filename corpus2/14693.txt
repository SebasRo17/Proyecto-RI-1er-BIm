I wrote a module which numerically solves an ODE using `NDSolve`. The result from this is e.g. either `InterpolatingFunction[{{0.,1000.}},<>][t]` or `InterpolatingFunction[{{0.,1000.}},<>][t$1062]`, depending whether the independent varialbe `t` is global or local in the module. So far, I didn't care that it is global and everything worked fine. As this is imho is a source of upcoming trouble, I would like to switch to the local variable-version. As therefore I can't use a replacement rule like `InterpolatingFunction[{{0.,1000.}},<>][t] /. t->3` to extract single values or to plot the function any more, I tried to wrap it into a function as the following minimal example demonstrates.               compute[] := Module[{res, f},        points = Table[{x, x}, {x, 0, 10}];        res = Interpolation[points];        f[x_] := res[x];        f     ];      Using this code works fine.               In[109]:= ex = compute[];               ex[3]     Out[110]= 3      I now want to run this computation with different parameters so I put it into a `ParallelTable`. The resulting list then does not contain the correct functions anymore but only their symbols.               In[111]:= a = ParallelTable[compute[], {i, 0, 100}];               a[[1]][3]          Out[112]= f$1870[3]      Note that this works perfectly when `ParallelTable` is replace by a normal `Table`. Can you explain to me why this happens? Has this something to do with the definitions of the functions "living" on the sub-kernels and not being passed back to the main kernel? **Edit** Another aspect of the problem, a solution to which would help me too, is the following. If I multiply the `InterpolatingFunction` by a number and try to then extract values from it, it doesn't work as I would expect. Using the above example and assuming tha `res` is returned (indicated by the use of `res` in the following).               In[150]:= fcn=5*res;               fcn[3]          Out[151]= (5 InterpolatingFunction[{{0,10}},<>])[3]      Is there maybe a workaround for this?