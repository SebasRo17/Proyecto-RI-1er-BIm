I need some help on this ACM ICPC problem. My current idea is to model this as a shortest path problem, which is described under the problem statement. **Problem** There are `N = 1000` nuclear waste containers located along a 1-D number line at _distinct_ positions from `-500,000 to 500,000`, except `x=0`. A person is tasked with collecting all the waste bins. Each second that a waste container isn't collected, it emits 1 unit of radiation. The person starts at `x = 0` and can move `1` unit every second, and collecting the waste takes a negligible amount of time. We want to find the minimum amount of radiation released while collecting all of the containers. **Sample Input:** `4` Containers located at `[-12, -2, 3, 7]`. The best order to collect these containers is `[-2, 3, 7, -12]`, for a minimum emitting of `50` units. Explanation: the person goes to `-2` in 2 seconds and during that time `2 units` of radiation are emitted. He then goes to `3` (distance: `5`) so that barrel has released `2 + 5 = 7` units of radiation. He takes `4` more seconds to get to `x = 7` where that barrel has emitted `2 + 5 + 4 = 11` units. He takes `19` seconds to get to `x = -12` where that barrel has emitted `2 + 5 + 4 + 19 = 30` units. `2 + 7 + 11 + 30 = 50`, which is the answer. **Notes** There is an obvious `O(N!)` solution. However, I've explored greedy methods such as moving to the closest one, or moving to the closest cluster but those haven't worked. I've thought about this problem for quite a while, and have kind of modeled it as a graph search problem:   1. We insert `0` in as a baseline position (This will be the initial state)   2. Then, we sort the positions from least to greatest.   3. We then do a BFS/PFS, where the `state` consists of      * Two integers `l` and `r` that represent a contiguous range in the sorted position array that we have visited already     * An integer `loc` that tells us whether we're on the left or right endpoint of the range     * An integer `time` that tells us the elapsed time     * An integer 'cost' that tells us the total cost so far (based on nodes we've visited)   4. From each state we can move to [l - 1, r] and [l, r + 1], tweaking the other 3 integers accordingly   5. Final state is [0, N], checking both ending positions. However, it seems that `[L, R, loc]` does not uniquely define a state, and we have to store `L, R, loc, and time`, while minimizing `cost` at each of these. This leads to an exponential algorithm, which is still way too slow for any good. Can anyone help me expand on my idea or push my into the right direction? **Edit:** Maybe this can be modeled as a dynamic programming optimization problem? Thinking about it, it has the same issues as the graph search solution - just because the current `cost` is low doesn't mean it is the optimal answer for that sub problem, since the `time` also affects the answer greatly. Greedy doesn't work: I have a greedy selection algorithm that estimates the cost of moving to a certain place (e.g. if we move right, we double the distances to the left barrels and such). Could you do a Priority-first search, with a heuristic? The heuristic could combine the cost of the current trip with the amount of time elapsed.