There is a good example on Wikipedia regarding the violation of SOLID principles. > The ISP was first used and formulated by Robert C. Martin while consulting > for Xerox. Xerox had created a new printer system that could perform a > variety of tasks like stapling a set of printed papers and faxing. The > software for this system was created from the ground up and performed its > tasks successfully. As the software grew, making modification became more > and more difficult so that even the smallest change would take a > redeployment cycle of an hour. This was making it near impossible to > continue development. The design problem was that one main Job class was > used by almost all of the tasks. Anytime a print job or a stapling job had > to be done, a call was made to some method in the Job class. This resulted > in a huge or 'fat' class with multitudes of methods specific to a variety of > different clients. Because of this design, a staple job would know about all > the methods of the print job, even though there was no use for them. The > solution suggested by Martin is what is called the Interface Segregation > Principle today. Applied to the Xerox software, a layer of interfaces > between the Job class and all of its clients was added using the Dependency > Inversion Principle. Instead of having one large Job class, a Staple Job > interface or a Print Job interface was created that would be used by the > Staple or Print classes, respectively, calling methods of the Job class. > Therefore, one interface was created for each job, which were all > implemented by the Job class. > > http://en.wikipedia.org/wiki/Interface_segregation_principle I tried to find a good PHP solution for this, I got this far:                class Job implements StampleJob, PrintJob {      }           class Print {        protected $objPrintJob;        public function __construct(PrintJob $objPrintJob) {          $this->objPrintJob = $objPrintJob;        }      }           class Staple {        protected $objStapleJob;        public function __construct(StapleJob $objStapleJob) {          $this->objStapleJob = $objStapleJob;        }      }      I can understand how the interface will limit knowledge but this will not actually change the big Job class or remove the SRP violation. Can you clarify how this solution actually solves the problem: "The design problem was that one main Job class was used by almost all of the tasks"?