You are writing a videogame about trading beans. Red beans, black beans, pinto beans, you name it. As everybody knows all beans are the same. You write the "Inventory" class for a trader in that videogame as follows (skipping all the null checks):                   class BeansInventory{     HashMap<BeanType,Integer> amountsOwned;          public void receive(BeanType typeReceived, int amount)     {amountsOwned.put(typeReceived,amountsOwned.get(typeReceived)+amount)}          public void remove(BeanType typeRemoved, int amount)     {amountsOwned.put(typeRemoved,amountsOwned.get(typeRemoved)-amount)}          public Integer amountOwned(BeanType type)     {amountsOwned.get(type)}     }      It works fine for years. Then suddenly somebody else has the great idea to add to the game trading coffee beans. As everybody knows each single coffee bean is completely different from the other. So you can't just add coffee as another bean type. Each coffee bean is its own instance. The coffee inventory class looks something like this:               class CoffeeInventory{         HashMap<CoffeType,List<CoffeeBeans>> coffeOwned;              public void receive(CoffeType typeReceived, CoffeeBeans... beans)         {coffeOwned.get(typeReceived).addAll(beans)}              public void remove(CoffeType typeRemoved, CoffeeBeans... beans)         {coffeOwned.get(typeRemoved).removeAll(beans)}              public Integer amountOwned(CoffeType type)         {amountsOwned.get(type).size()}         }      But now you have tons of problems. You have two APIs for the same task. All the trading infrastructure now has to check carefully if it is trading pinto beans or coffee beans and call a different inventory and a different method with a different signature for what is after all the same task: "store this". So now I have this code that is getting filled of `if` checks and `instanceof` and all the other signs of code smell. But I can't figure out a way to use a single simple API. I have no idea what's the right oo thing to do.