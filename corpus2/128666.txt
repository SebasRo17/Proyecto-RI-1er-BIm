I have two business classes: TimesheetDay and TimeSlot. One TimesheetDay can have one or more TimeSlots. The TimesheetDay and TimeSlot classes will be dependent on an object that implements a corresponding TimesheetDayData and TimeSlotData interface. That way, I can write data classes to map the objects to a MySQL database, but if I use another way to store the data in the future, I can inject objects from a different dataclass. These objects will not create other objects, and I refuse to use the "new" keyword in them. I want them to be testable in complete isolation. For example, I instantiate a TimesheetDay object like this (in a container):               $mTimesheetDayData = new TimesheetDayMysqlData($databaseHost, $timesheetDayId);     $mTimesheetDay = new TimesheetDay($mTimesheetDayData);      TimeSlot objects will be constructed the same way:               $mTimeSlotData = new TimeSlotMySqlData($databaseHost, $timeSlotId);     $mTimeSlot = new TimeSlot($mTimeSlotData);      My problem lies in getting TimeSlot objects that the TimesheetDay contains. I can't have the TimesheetDay class creating objects. Otherwise, I might write a method that returns an array of TimeSlot objects, something like:               $timeSlotsForThatDay = array();     $timeSlotsForThatDay = $mTimesheetDay->getTimeSlots();      But, that would require the method getTimeSlots() to create objects. How would you handle this?