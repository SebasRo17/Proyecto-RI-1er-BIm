I have an interface `Serializer` with methods `serialize` and `isSerializerFor`. I created a first implementation of this using TDD, and ended up with a nice clean test case fully covering a nice clean implementation. To get a more concrete idea, here is one relevant commit. Now someone else (who is not used to doing TDD) started with writing the second implementation of this `Serializer` interface. This person figured the test needed for the second implementation would have some overlap with my initial test. So an abstract base class for serializer tests was created, holding the methods that are suspected to be common to all serializer test cases. I'm not happy with this for two main reasons. First of all, the only reason inheritance is used here is for code reuse, which is a big code smell. Secondly, this breaks the TDD cycle. If I now want to create another implementation of `Serializer`, and create a derivative of the base test class, I end up having to implement all production code in one step. On the other hand, simply duplicating the common code in the test classes seems rather odd as well. I'm hoping composition can be used here in a sane way to avoid these problems. This seems like a reasonably common situation. How would you solve this? What would you do differently?