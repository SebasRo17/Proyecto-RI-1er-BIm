Exploring methods to index and search tree-structured key:value pairs via named-entity index (key paths) as opposed to Position-based indexing.   * Using `Rule` as `key->value` causes difficulties for `Cases`, which is unfortunate since `Rule` could be combined with `ReplaceAll` to yield lightweight path queries.    * Using `List` as `{key,value}` works but too many parentheses are visually confusing especially in data fusion tasks where multiple datasets are imported separately but must be joined and indexed properly for subsequent analysis.   * Using `Equal` prevents the key from being a string, eg `"key1" = value1 --> "Set::setraw : Cannot assign to raw object key1"` Why does `Cases` interpret `Colon` shortcut `(key:value_)` differently than `Colon[key,value_]`? dataR (* for comparison *)                Out[110]= {row1 -> {key1 -> value1, key2 -> value2},       row2 -> {key1 -> value3, key2 -> value4}}           In[69]:= dataC = dataR /. Rule -> Colon           Out[69]= {row1 \[Colon] {key1 \[Colon] value1, key2 \[Colon] value2},       row2 \[Colon] {key1 \[Colon] value3, key2 \[Colon] value4}}      Then, using `Cases`:                In[113]:= Cases[dataC, Colon[row1  , v_] -> v]           Out[113]= {{key1 \[Colon] value1, key2 \[Colon] value2}}           In[114]:= Cases[dataC, (row1 : v_) -> v]           Out[114]= {row1 \[Colon] {key1 \[Colon] value1, key2 \[Colon] value2},       row2 \[Colon] {key1 \[Colon] value3, key2 \[Colon] value4}}      `Levelspec` can be specified to match the inner keys, eg `key2` at `Level 3`. Is there a more convenient syntax or method to rapidly restructure arbitrary tree-shaped data? XPath and XQuery, are W3C standards that could be adapted or improved. In particular, XQuery strikes me as being similar in flexibility as Cases in the ability to match and transform data. I've posed similar questions to Wolfram Tech Support. Has been suggested for implementation.