I have a module that I need to call 1-10 million times in my program. Currently, it is taking several hours to run so I am hoping that I can cut down some runtime with your help.               r = RandomReal[NormalDistribution[0., 1./2.], 6];          es = Eigensystem[H0[\[Omega]0, r[[1]], r[[2]], r[[3]], r[[4]], r[[5]], r[[6]] ];          \[Epsilon] = es[[1]];     v = es[[2]];     vS = Conjugate[v];          (*elements of v and vS are called later; v[[1]], vS[[1]] etc...*)      H0 is a compiled function which sped things up a little. It looks like this: ![enter image description here](http://i.stack.imgur.com/9UA7T.png). In copy-paste form, H0[] is                {{0, (ωz1 - ωz2)/      2, (-ωx1 + ωx2)/(2 Sqrt[2]) - (I ωy1)/(      2 Sqrt[2]) + (I ωy2)/(      2 Sqrt[2]), (ωx1 - ωx2)/(2 Sqrt[2]) - (      I ωy1)/(2 Sqrt[2]) + (I ωy2)/(      2 Sqrt[2])}, {(ωz1 - ωz2)/2,       0, (ωx1 + ωx2)/(2 Sqrt[2]) + (I ωy1)/(      2 Sqrt[2]) + (I ωy2)/(      2 Sqrt[2]), (ωx1 + ωx2)/(2 Sqrt[2]) - (      I ωy1)/(2 Sqrt[2]) - (I ωy2)/(      2 Sqrt[2])}, {(-ωx1 + ωx2)/(2 Sqrt[2]) + (      I ωy1)/(2 Sqrt[2]) - (I ωy2)/(      2 Sqrt[2]), (ωx1 + ωx2)/(2 Sqrt[2]) - (      I ωy1)/(2 Sqrt[2]) - (I ωy2)/(      2 Sqrt[2]), ω0 + (ωz1 + ωz2)/2,      0}, {(ωx1 - ωx2)/(2 Sqrt[2]) + (I ωy1)/(      2 Sqrt[2]) - (I ωy2)/(      2 Sqrt[2]), (ωx1 + ωx2)/(2 Sqrt[2]) + (      I ωy1)/(2 Sqrt[2]) + (I ωy2)/(2 Sqrt[2]),      0, -ω0 + 1/2 (-ωz1 - ωz2)}}      Is there anything else that can be optimized here?