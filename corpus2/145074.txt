I am assuming the implementations/compilers/generated C code (referred to hereinafter as generic, 'interpreter') for most functional programming languages are written in non-pure functional languages. If this is the case, the underlying interpreter for any given functional programming language exhibits destructive updates and is referentially opaque. Functional constructs are designed to make certain guarantees, such as concurrency and provability. If the interpreter is indeed an imperative program, how is it able to guarantee the 'no side-effects' properties of pure functional programs? Surely optimisations to functional code by the interpreter include changing the nature of recursive functions to imperative ones? My question is: **How do imperative interpreters still make guarantees about the functional program they are executing without being inherently functional themselves?**