I have two lists of equal lengths but for my task I will use 3-element lists , namely `{x,y,z}` and `{f,g,h}`. The first contains variables and the second functions. I want to produce `{f[x],g[y],h[z]}` with input the above lists in as many ways as possible. Until now I have devised the following ones:               Inner[#1[#2]&,{f,g,h},{x,y,z},List]      and               MapThread[#1[#2]&,{{f,g,h},{x,y,z}}]      As pointed out , there is a very similar thread at wolfram's community. If I come up with more solutions I will add them here. **Update** I am updating with the one-liners. In _Wolfram's Community_ forum there are also solutions changing Attributes or using Append but I will omit them here.               MapThread[#1[#2]&,{{f,g,h},{x,y,z}}]          Inner[#1[#2]&,{f,g,h},{x,y,z},List]          Diagonal[Through/@Distribute[{f,g,h}[{x,y,z}],List]          MapThread[Compose,{{f,g,h},{x,y,z}}]      `Apply[List,{f,g,h}.{x,y,z}/.Times->(Operate[##1,0]&)]` and `Apply[List,{f,g,h}.{x,y,z}/.Times->(#1[#2]&)]` work only because f,g,h are before x,y,z in alphabetical order as very well pointed out by @andre                Apply[Compose,Thread[{{f,g,h},{x,y,z}}],{1}]           (#1[[1]][#1[[2]]]&)/@Transpose[{{f,g,h},{x,y,z}}]