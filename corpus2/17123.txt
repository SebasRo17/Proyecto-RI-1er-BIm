I'm using `WaitNext` in _Mathematica_ for parallel processing on Mac OS X. I have 4 processors on my MacBook and `LaunchKernels[]` has launched 4 kernels in _Mathematica_ , in addition to the master kernel. However, each of these 4 kernels gets approximately 75-80% of a processor, while the master kernel gets 70-75%. It seems to me that the master kernel should be just waiting, instead of using CPU. The relevant code is               While[Length[parallelJobs] > 0,      {result, pJ, parallelJobs} = WaitNext[parallelJobs];      Write[outputstream, result];      setofresults = Join[setofresults, result]     ]      where `parallelJobs` is a list of process IDs of the form `ParallelSubmit[{...},...]`, and each of the jobs should take about an hour. Thus, there is no reason for the master kernel to be running. A similar code with `WaitAll` instead of `WaitNext` leaves the master kernel with 0% CPU and gives 100% to each of the launched parallel kernels. But the reason I want to use `WaitNext` instead is because I want to write the results as they're generated. I'd be grateful for any explanation of what's going on or ideas for getting around this waste of CPU. Thanks. Later: Here's a fix. I bundle more stuff into the `ParallelSubmit[...]` parts, in order to Write there, and then I use `WaitAll` on the list of `ParallelSubmit` items. This seems to result in considerably less overhead CPU used by the master kernel. It now seems to be an academic question: why does `WaitNext` (seem to?) use so much more overhead than `WaitAll`?