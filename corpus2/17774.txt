Earlier today I had a discussion with a representative at Premier Support about the 2 questions I've asked here over the past couple of days:   * Seeking strategies to deploy a function securely without a front-end   * Can on launch a player pro kernel independently of the front front end Neither the conversation nor the answers to the above questions have produced a solution as good as compiling my function to C code. This leaves me with some problems as the function I need to deploy uses 4 high-level Mathematica functions which don't (or maybe don't readily) compile:               CholeskyDecomposition[]     IdentityMatrix[]     LinearSolve[]     Simplify[]      Yesterday I made some progress developing/adapting solutions for procedural versions of `CholeskyDecomposition[]` and `IdentityMatrix[]`, so these at least should compile. Given the anticipated use of my function, maybe I can get away without using `Simplify[]`. This would leave me still needing a procedural equivalent to `LinearSolve[]` or some means of compiling it. Maybe simpler because, I don't need a `myLinearSolve[]` to do everything Mathematica's version does. Interestingly, in my conversation with the guy from support, he suggested that given the limited nature of what I wanted to do, he thought that setting options on `LinearSolve[]` should give me a reduced scope version of `LinearSolve[]` that Mathematica could compile. He couldn't specify which options. So let's explore this. A typical use of `LinearSolve[]` in my current function looks like this:               c = {0.516344, 0.287671, 0.216344, 0.176796, 1};       A = {{0, 1, 1/2, 1/2, 1/2}, {0, 0, Sqrt[3]/2, 1/(2 Sqrt[3]), 1/(2 Sqrt[3])}, {0, 0, 0, Sqrt[2/3], 1/(2 Sqrt[6])}, {0, 0, 0, 0, Sqrt[5/2]/2}, {1, 1, 1, 1, 1}};          LinearSolve[A, c]          {0.173339, 0.206027, 0.187944, 0.209058, 0.223631}      No symbolic processing. No imaginary numbers. No `SparseArray` objects. `A` always a square matrix; `c` always a vector; and its usage always outputs a real vector. **Question 1** \-- Does anyone have any insight into how to set options for the above use of LinearSolve[] so it will compile or if this is even possible? _Note: Oleksandr's answer inWhy is MainEvaluate being used when LinearSolve can be compiled? may have some bearing on this._ ... If no way forward comes from the above, I may still have a chance to implement a limited procedurally based `proceduralLinearSolve[]`. If very distant memory serves me, one can use the inverse of a square matrix for some problems addressable with `LinearSolve[]`. This might give me a more specific way forward except Mathematica's implementation of it, `Inverse[]`, doesn't fall on the list of compilable functions either. I have found some code for calculating the inverse of a square matrix. Not even certain of the language, but I can probably follow its logic and port it to a proceduralInverse[] function in Mathematica. This background takes me to my second question... **Question 2** \-- Does creating a `proceduralLinearSolve[]` or `proceduralInverse[]` seem like a viable way to go (has anyone tried this kind of thing and succeeded) and/or can anyone point me in the direction of resources or solutions that could help me do this?