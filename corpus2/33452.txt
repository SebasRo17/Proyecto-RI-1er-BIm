This question is a further question to my previous one. The solution for that question works well as long as the original input `Manipulate` code is still provided in the notebook. But in general, there are cases that only the output cell is included and the input code omitted. In such case, I think we could possily make the `Manipulate` remembers its own input code, and by request (e.g. a button) we can show the code. A first attempt starts with either `DynamicModule` or `Pattern`. For instance, I tried               DynamicModule[{mc = HoldComplete@Manipulate[      Column[{        Plot[Sin[x - n], {x, 0, 12.4}],        Button["show code",         NotebookPut[Notebook[{Cell[BoxData[ToBoxes[mc]], "Intput"]}],           EvaluationNotebook[]]         ]}], {n, .3, 11.8}]},      ReleaseHold[mc]]      where mc is the short for 'manipulatecode'. But the code will not be shown if we click the button, only the output instead. I also tried               mem : Manipulate[     Column[{     Plot[Sin[x - n], {x, 0, 12.4}],     Button["show code",      NotebookPut[Notebook[{Cell[BoxData[ToBoxes[mc]], "Intput"]}],        EvaluationNotebook[]]      ]}],     {n, .3, 11.8},     Initialization :> (mc := HoldComplete[mem];)]      But this will not work also. Is there a way to let the button creates a new cell and show the `Manipulate` code in this cell (better in expression format)?