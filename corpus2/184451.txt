Reading about concurrency in Erlang, reminds me of the Akka concurrency toolkit. Both give you tools to prevent or limit race conditions. But you can send links to mutable data to other processes using the Akka toolkit, which is still unsafe. I see Akka as a useful tool, but it does not provide _protection_ against out-of-order access to objects and data leading to race- conditions, deadlock, and/or starvation. It doesn't prevent you from writing unsafe code the way Java or C# protects you from writing most of the kinds of memory leaks you can write in C++ (you can still create memory leaks in Java by tricking the garbage collector, but it is less of a problem than having to remember to free every byte you allocate). Does Erlang guarantee a degree of correctness, performance, and robustness in concurrent programming? I think operating systems provide protection when accessing system resources (assuming the driver writers did their jobs well). ACID databases provide protection for reads and updates. So it seems this is a solvable problem. Or would a generic safe solution would erase the performance gains that concurrency provides? Do other languages or toolkits provide the kind of concurrent safety that Erlang does (or doesn't)? This is a follow-up question to @Malfist's comment on @user1249's answer to What programming language generates fewest hard-to-find bugs?.