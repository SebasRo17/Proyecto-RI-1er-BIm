Haskell often provides two versions of a given function f, i.e:               f :: Int ...     genericF :: Integral i => i ...      There exist many standard library functions with those two versions: length, take, drop, etc. Quoting the description of `genericLength`: > The genericLength function is an overloaded version of length. In > particular, instead of returning an Int, it returns any type which is an > instance of Num. It is, however, less efficient than length. My question is: where does the efficiency loss comes from? Can't the compiler detect that we are using `genericLength` as an Int and therefore us `length` for better performance? Why isn't `length` generic by default?