So I thought about this, and I don't know if it's included or not in any methodology. I think the advantages of this coding style is that, at the lowest level, the code is extremely testable, and then the integration tests should also be very easy to build. I also think this would make the code more readable and the UML would be understood faster. So here's my example:               class CoolObject{     var member1; //needed for instance in lifecycle events     var member2; //same comment             //This method could be for instance an event handler        //Notice this contains only assignments and method calls. No library calls or lower level stuff        [public] method high_level(params...){          var local_var1;         var local_var2;         local_var1 = call method lower_level1(param1,param2);         local_var2 = call method lower_level2(param1, local_var1);         member1 = call method lower_level3(local_var2);        }             //Notice this contains only library calls and lower level processing        [private] method lower_level1(param1, param2){         return param1 + param2 + libraryXXY123.function142(current_date);        }             //Notice this contains only library calls and lower level processing        [private] method lower_level2(param1, param2){          var return_value;          loop over param2{             if(condition){                add param1 to return_value;             }          }          return return_value + libraryASDF123.function3132(system_user);             }          }      Please note that this is not written in any specific language, as I only wanted to illustrate the concept. So do you know some methodologies that use this, or that warn against it? Please elaborate on the answer, as I think this would be a good idea, and would like this either confirmed, or the opposite.