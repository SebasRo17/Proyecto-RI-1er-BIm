Do you think programming novices should learn objects from day 1, as seen in the book "Objects First With Java: A Practical Introduction Using BlueJ" by David Barnes? Or do you think this is a bad idea? For those unfamiliar with the book, here is a list of the topics discussed in the chapters: > Chapter 1 deals with the most fundamental concepts of object-orientation: > objects, classes and methods. It gives a solid, hands-on introduction to > these concepts without going into the details of Java syntax. It also gives > a first look at some source code. We do this by using an example of > graphical shapes which can be interactively drawn, and a second example of a > simple laboratory class enrolment system. > > Chapter 2 opens up class definitions and investigates how Java source code > is written to create behavior of objects. We discuss how to define fields > and implement methods. Here, we also introduce the first types of > statements. The main example is an implementation of a ticket machine. We > also look back to the laboratory class example from chapter 1 to investigate > that a bit further. > > Chapter 3 then enlarges the picture to discuss interaction of multiple > objects. We see how objects can collaborate by invoking each other's methods > to perform a common task. We also discuss how one object can create other > objects. A digital alarm clock display is discussed that uses two number > display objects to show hours and minutes. As a second major example, we > examine a simulation of an email system in which messages can be sent > between mail clients. > > In Chapter 4, we continue by building more extensive structures of objects. > Most importantly, we start using collections of objects. We implement an > electronic notebook and an auction system to introduce collections. At the > same time, we discuss iterations over collection and have a first look at > loops. The first collection being used is an ArrayList. In the second half > of the chapter we introduce arrays as a special form of a collection, and > the for loop as another form of a loop. We discuss an implementation of a > web log analyzer as an example for array use. > > Chapter 5 deals with libraries and interfaces. We introduce the Java > standard library and discuss some important library classes. More > importantly, we explain how to read and understand the library > documentation. The importance of writing documentation in software > development projects is discussed, and we end by practicing how to write > suitable documentation for our own classes. Random, Set and Map are examples > of classes that we encounter in this chapter. We implement an Eliza-like > dialogue system and a graphical simulation of a bouncing ball to apply these > classes. > > Chapter 6, titled Well-behaved objects, deals with a whole group of issues > connected to producing correct, understandable, and maintainable classes. It > covers issues ranging from writing clear, understandable code - including > style and commenting - to testing and debugging. Test strategies are > introduced and a number of debugging methods are discussed in detail. We use > an example of a diary for appointment scheduling and an implementation of an > electronic calculator to discuss these topics. > > In Chapter 7, we discuss more formally the issues of dividing a problem > domain into classes for implementation. We introduce issues of designing > classes well, including concepts such as responsibility-driven design, > coupling, cohesion, and refactoring. An interactive, text-based, adventure > game (World of Zuul) is used for this discussion. We go through several > iterations of improving the internal class structure of the game and > extending its functionality, and end with a long list of proposals for > extensions that may be done as student projects. > > Chapters 8 and 9 introduce inheritance and polymorphism with many of the > related detailed issues. We discuss a simple database of CDs and videos to > illustrate the concepts. Issues of code inheritance, subtyping, polymorphic > method calls and overriding are discussed in detail. > > In Chapter 10 we implement a predator/prey simulation. This serves to > discuss additional abstraction mechanisms based on inheritance, namely > interfaces and abstract classes. > > Chapter 11 introduces two new examples: an image viewer and a sound player. > Both examples serve to discuss how to build graphical user interfaces > (GUIs). > > Chapter 12 then picks up the difficult issue of how to deal with errors. > Several possible problems and solutions are discussed, and Java's exception > handling mechanism is discussed in detail. We extend and improve an address > book application to illustrate the concepts. > > Chapter 13 steps back to discuss in more detail the next level of > abstraction: how to structure a vaguely described problem into classes and > methods. In previous chapters we have assumed that large parts of the > application structure already exist, and we have made improvements. Now it > is time to discuss how we can get started from a clean slate. This involves > detailed discussion of what the classes should be that implement our > application, how they interact, and how responsibilities should be > distributed. We use class-responsibilities-collaborators (CRC) cards to > approach this problem, while designing a cinema booking system. > > In Chapter 14, we try to bring everything together and integrate many topics > from the previous chapters of the book. It is a complete case study, > starting with the application design, through design of the class > interfaces, down to discussing many important functional and non-functional > characteristics and implementation details. Topics discussed in earlier > chapters (such as reliability, data structures, class design, testing, > extendibility, etc.) are applied again in a new context.