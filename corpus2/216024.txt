Question: Why can't Java/C# implement RAII? Clarification: I am aware the garbage collector is not deterministic. So with the current language features it is not possible for an object's Dispose() method to be called automatically on scope exit. But could such a deterministic feature be added? My understanding: I feel an implementation of RAII must satisfy two requirements:   1\. The lifetime of a resource must be bound to a scope.   2\. Implicit. The freeing of the resource must happen without an explicit statement by the programmer. Analogous to a garbage collector freeing memory without an explicit statement. The "implicitness" only needs to occur at point of use of the class. The class library creator must of course explicitly implement a destructor or Dispose() method. Java/C# satisfy point 1. In C# a resource implementing IDisposable can be bound to a "using" scope:               void test()     {         using(Resource r = new Resource())         {             r.foo();         }//resource released on scope exit     }      This does not satisfy point 2. The programmer must explicitly tie the object to a special "using" scope. Programmers can (and do) forget to explicitly tie the resource to a scope, creating a leak. In fact the "using" blocks are converted to try-finally-dispose() code by the compiler. It has the same explicit nature of the try-finally-dispose() pattern. Without an implicit release, the hook to a scope is syntactic sugar.               void test()     {         //Programmer forgot (or was not aware of the need) to explicitly         //bind Resource to a scope.         Resource r = new Resource();          r.foo();     }//resource leaked!!!      I think it is worth creating a language feature in Java/C# allowing special objects that are hooked to the stack via a smart-pointer. The feature would allow you to flag a class as scope-bound, so that it always is created with a hook to the stack. There could be options for different types of smart pointers.               class Resource - ScopeBound     {         /* class details */              void Dispose()         {             //free resource         }     }          void test()     {         //class Resource was flagged as ScopeBound so the tie to the stack is implicit.         Resource r = new Resource(); //r is a smart-pointer         r.foo();     }//resource released on scope exit.      I think implicitness is "worth it". Just as the implicitness of garbage collection is "worth it". Explicit using blocks are refreshing on the eyes, but offer no semantic advantage over try-finally-dispose(). Is it impractical to implement such a feature into the Java/C# languages? Could it be introduced without breaking old code?