Here is a toy example:               f[t_] := NIntegrate[Sin[x], {x, 0, t}];     Plot[f[t], {t, 0, 10}] // Timing      Even such a simple example will take 2.8 seconds on my computer. Since many of the plot family functions have the attribute `HoldAll`, _Mathematica_ evaluates `f[t]` only after assigning specific numerical values to `t`, thus causing a lot of repeated evaluations of `NIntegrate`. The integration to a smaller upper-limit is **forgotten** when integrating to a bigger upper-limit. On the other hand, I can’t benefit from wrapping the function in `Evaluate`, because of the numerical nature of `NIntegrate`. Something stuck here. So the questions are:   * Can NIntegrate remember or make full use of the result of a smaller upper-limit integral? Or generally, how to speed up the plot involving `NIntegrate` or is there any principle to do it?   * Is it possible to realize **ParametricNIntegrate** just as `ParametricNDSolve` in version 9? **Edit** Following the way of changing the integral to `NDSolve` (Thanks to Mark McClure) ,I’ve come up with one possible way to realize ParametricNIntegrate. Here is the code for a more general way compared to the toy model:               sol=ParametricNDSolveValue[{f'[x] == Sin[a x], f[0] == 0},f,{x,0,10},{a}];     Manipulate[Plot[{sol[a][t], 1/a (1 - Cos[a t])}, {t, 0, 10}], {a, 1, 5}]      Now I can change the parameter and plot the integral in real-time.Any better ideas?