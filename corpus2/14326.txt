Because `NIntegrate[]` does not support parallel computation out of the box, I'm doing a simplified version by breaking the integration limit into pieces and using `ParallelTable[]`. The following code is just a minimum working example in which I used `Sinc[]` as the integrated function.               iser[x_] := NIntegrate[Sinc[t + x], {t, 0, 100}];          ipar[x_] := Total[ParallelTable[                  With[{xx = x}, NIntegrate[Sinc[t + xx], {t, ii*25, ii*25 + 25}]                  ], {ii, 0, 3}]                 ];      where `iser[]` is the usual serialize version, and `ipar[]` is the parallel version. Then I do `DistributeDefinitions[ipar]`. Passing a value to `iser[]` and `ipar[]` and **both give the correct answer** :               In[28]:= ipar[3]          Out[28]= -0.270322      But, when I try to run `Plot[ipar[x], {x, 0, 10}] // Timing` I get error messages that says                NIntegrate::inumr: The integrand Sinc[t+x] has evaluated to non-numerical values for all sampling points in the region with boundaries {{0,25}}.           NIntegrate::inumr: The integrand Sinc[t+x] has evaluated to non-numerical values for all sampling points in the region with boundaries {{50,75}}.           NIntegrate::inumr: The integrand Sinc[t+x] has evaluated to non-numerical values for all sampling points in the region with boundaries {{75,100}}.           NIntegrate::inumr: The integrand Sinc[t+x] has evaluated to non-numerical values for all sampling points in the region with boundaries {{25,50}}.           NIntegrate::nlim: t = 25. ii is not a valid limit of integration.                General::stop: Further output of NIntegrate::nlim will be suppressed during this calculation.           $Aborted      I know I can just generate a table of values and use `ListPlot[]` instead, but it's not easy to do adaptive sampling as `Plot[]` does. How can this be fixed?