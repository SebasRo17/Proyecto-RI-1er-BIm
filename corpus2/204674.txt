# Problem I was just trying to debug a set of file-manipulation routines I wrote for a program I am working on. One of them kept returning an `INVALID_HANDLE` error. # Explanation I figured out what the problem was. It turns out that because I provided several overloads so that I could call the function with either a file handle or filename, I ended up creating ambiguous overloads. For example (not variadic functions; the ellipses are just for simplification purposes):               INT CopyFileSection ( HANDLE fIn, HANDLE fOut, … );     INT CopyFileSection ( HANDLE fIn, TCHAR* fOut, … );     INT CopyFileSection ( TCHAR* fIn, HANDLE fOut, … );     INT CopyFileSection ( TCHAR* fIn, TCHAR* fOut, … );      The first one (`HANDLE, HANDLE`) does the main work while the others just open the file pointed to by the filename and call the first function. The problem is that a `HANDLE` is just a pointer, so the compile can’t figure out which one I am calling (even though to me it was obvious), and ends up calling `HANDLE, HANDLE` even when I pass a pointer to a string, so naturally it fails since the pointer is not a file handle. # Question I want to provide maximum flexibility, so short of re-writing to use `std::string` _instead of_ `TCHAR*` for the filenames (which I actually did include as well), what suggestions are there to deal with this sort of scenario?    # Related As a related side note—a separate question?—I was wondering about the ease, safety, and feasibility of providing overloads for all (or at least a set of) possible permutations. For example, with a function that takes two files, you could use `HANDLE`, `TCHAR*`, and `string` (probably others, but in this case we’ll stick with these three). This means there are up to nine overloads just for the files: `HH, HT, HS, TH, TT, TS, SH, ST, SS`. Let alone if there are other arguments that could provide more overloads. Surely there must be a better way to both provide flexibility in calling the function and clean, understandable, and maintainable code.