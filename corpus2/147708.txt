Usually, tree data structures are organised in a way that each node contains pointers to all its children.                      +-----------------------------------------+            |        root                             |             | child1            child2         child3 |            +--+------------------+----------------+--+               |                  |                |     +---------------+    +---------------+    +---------------+     |    node1      |    |     node2     |    |     node3     |     | child1 child2 |    | child1 child2 |    | child1 child2 |     +--+---------+--+    +--+---------+--+    +--+---------+--+        |         |          |         |          |         |      This seems natural, but it comes with some problems. For example, when the number of child nodes varies, you need something like an array or list to manage the childs. By using only (first)child and (next)sibling pointers instead, we get something that looks like that:                      +-------------------+            |        root       |            | child    sibling  +--->NULL            +--+----------------+               |                  +----------------+    +----------------+    +----------------+     |    node1       |    |     node2      |    |     node3      |     | child  sibling +--->| child  sibling +--->| child  sibling +--->NULL     +--+-------------+    +--+-------------+    +--+-------------+        |                     |                     |      Oviously, this kind of structure can represent trees just as well, but it also offers some advantages. Most important is that we don't have to worry about the number of child nodes any more. When used for a parse tree, it offers a natural representation for a term like "a+b+c+d+e" without becoming a deep tree. Do collection libraries offer tree structures like that? Do parsers use such a structure? If not, what are the reasons?