In the following I am using one function `makeFunc` to assemble two functions `a[t]` and `b[t]` to pass to use in the formation of a `Table`. `makeFunc` appears to be doing its job appropriately because the error messages and `Trace` show that it has assembled `a[t]` and that the `Table` construct has evaluated the `t` portion of the function. However, `a[t]` is not evaluating itself and so the `Table` appears as `a[0]`, `a[30]`, etc.               tempMakeTableAn[{analEqs_, concs_, initConcs_, rateConstants_,          timeDom_, timeInc_}] :=       Module[{a, b},        a[t_] :=          aZero Exp[-k1 t] /. Evaluate[Join[initConcs, rateConstants]];        b[t_] :=          bZero + 1 - aZero a[t] /. Evaluate[Join[initConcs, rateConstants]];             makeFunc[conc_, time_] := Evaluate[conc[time]];             Column[{Table[{a[t], b[t]}, {t, 0, 300, 30}],          Table[makeFunc[#, timeDom[[1]]] & /@ concs, {t, 0, 300, 30}]}]         ];          tempMakeTableAn[{{Hold[a[t_] := aZero Exp[-k1 t],          b[t_] := bZero + 1 - aZero a[t]]}, {a, b}, {aZero -> 1,         bZero -> 0}, {k1 -> .01}, {t, 0, 300}, {30}}]      > { {{{1, 0}, {0.740818, 0.259182}, {0.548812, 0.451188}, {0.40657, 0.59343}, > {0.301194, 0.698806}, {0.22313, 0.77687}, {0.165299, 0.834701}, {0.122456, > 0.877544}, {0.090718, 0.909282}, {0.0672055, 0.932794}, {0.0497871, > 0.950213}}}, > > {{{a[0], b[0]}, {a[30], b[30]}, {a[60], b[60]}, {a[90], b[90]}, {a[120], > b[120]}, {a[150], b[150]}, {a[180], b[180]}, {a[210], b[210]}, {a[240], > b[240]}, {a[270], b[270]}, {a[300], b[300]}}} } This appears to have something to do with the way that I am utilizing the `Slot` (#) as you can see that when I entered in `a[t]` and `b[t]` directly, the `Table` works. I _think_ that this may have to do with scoping of the variables, because if I remove `a` and `b` as declared variables in the `Module`, everything works as expected. I.e. `a` and `b` get defined globally and the expected `Table` appears. I have also tried some judiciously placed `Evaluate` statements to see if that is what was needed, but that didn't make any changes. I have found a couple of questions that I thought might be applicable (Using pure functions in Table,Evaluate[] seems to not work inside Button[]), but since the construct works when the variables are declared globally, I don't understand why it doesn't work when they are declared within the module. Any help would be appreciated. [If somebody can come up with a better Title, have at it. This was the best that I could figure out].