I take a good deal of criticism from other programmers due to my use of full proper casing for all my variables. For example, your typical programmer will use `employeeCount` for a variable name, but I use `EmployeeCount`. I use full proper casing for _everything_ , be it a void method, return method, variable, property, or constant. I even follow this convention in Javascript. That last one _really_ rustles people's jimmies. The typical reason given as to why I shouldn't follow this "non-standard" casing convention is because full proper case should be reserved for properties and void methods. Local variable and methods that return a value should have the first word in lowercase like `int employeeCount = getEmployeeCount()`. However, I don't understand why. When I question this, it seems that I just get an arbitrary answer of _that's the standard_. Whatever the answer is, it usually always boils down to _That's just the way it is and I don't question it. I just follow it._. Arbitrary answers are never good enough for me. Ever since my early days of programming Excel 97 macros with the Office IDE, I've never needed a casing convention to tell me whether or not something is a local variable or property. This is because I've always used a very intuitive naming convention. For example, `GetNuggetCount()` clearly suggests a method that goes somewhere an gets a count of all the nuggets. `SetNuggetCount(x)` suggests that you are assigning a new value to the count of nuggets. `NuggetCount` all by itself suggests a property or local variable that is simply holding a value. To that last one, one may be tempted to say, "Ah ha! That is the question. Property or variable? WHICH IS IT?" To that, I'd reply with, "Does it really matter?" So here's the tl;dr;: What are the objective, logical, non-arbitrary reasons to use lowercase for the first word in your variable or return method? **Edit:** For MainMa Replace _this_ code with the first code sample in your answer and see how well your argument holds up:               public void ComputeMetrics()     {         const int MaxSnapshots = 20;              var Snapshots = this.LiveMeasurements.IsEnabled ?             this.GrabSnapshots(MaxSnapshots, this.cache) :             this.LoadFromMemoryStorage();              if (!Snapshots.Any())         {             this.Report(LogMessage.SnapshotsAreEmpty);             return;         }              var MeasurementCount = Measurements.Count();         this.Chart.Initialize((count + 1) * 2);              foreach (var s in Snapshots)         {             this.Chart.AppendSnapshot(s);         }     }