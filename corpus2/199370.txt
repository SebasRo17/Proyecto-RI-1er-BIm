Should classes, that modify the state of the parent class, but not itself, be unit tested separately? And by separately, I mean putting the test in the corresponding unit test class, that tests that specific class. I'm developing a library based on chained methods, that return a new instance of a new type in most cases, where a chained method is called. The returned instances only modify the root parent state, but not itself. Overly simplified example, to get the point across:                   public class BoxedRabbits         {             private readonly Box _box;             public BoxedRabbits(Box box)             {                 _box = box;             }                  public void SetCount(int count)             {                 _box.Items += count;             }         }              public class Box         {             public int Items { get; set; }             public BoxedRabbits AddRabbits()             {                 return new BoxedRabbits(this);             }         }          var box = new Box();     box.AddRabbits().SetCount(14);      Say, if I write a unit test under the `Box` class unit tests:               box.AddRabbits().SetCount(14)      I could effectively say, that I've already tested the `BoxedRabbits` class as well. Is this the wrong way of approaching this, even though it's far simpler to first write a test for the above call, then to first write a unit test for the `BoxedRabbits` separately?