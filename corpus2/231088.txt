I have several classes that all behave according to one interface. But in each class there are additional functions defined that give each class slightly different behavior. What I want to do is have th programmer using this API to simply create one instance based on some parameter which generates the correct class type. And then he/she would only see the methods available to that type while programming So for example My interface               interface IChange     {         string Change(string inputString);     }      And say I have two classes that implement this interface               class Changer1 : IChange     {            public string Change(string input){            ...       }            public void DoSomethingSpecial1(){            ///code that does something specific to Changer1 class       }          }          class Changer2 : IChange{            public string Change(string input){            ...       }            public void DoSomethingSpecial2(){            ///code that does something specific to Changer2 class       }               }      Then I would have a wrapper that sets the appropriate Changer based on an enumeration or some other user input.               public enum ChangerType     {         Type1,         Type2     }          class MasterObject{                  public MasterObject(ChangerType type)             {                 if (type == ChangerType.Type1)                     SetChanger(new Changer1());                 if (type == ChangerType.Type2)                     SetChanger(new Changer2());             }                  private IChange _change;                  private void SetChanger(IChange change)             {                 this._change = change;             }               }      Then as a user of this, in my main program I want to do something like the following where the user creates the main object but it gets created in such a way that they only have access to the appropriate functions. I.e. Have available only DoSomethingSpecial1 or only DoSomethingSpecial2 based on the type you created.               class Program     {         static void Main(string[] args)         {             MasterObject obj1 = new MasterObject(ChangerType.Type1);             obj1.DoSomethingSpecial1();             string result1 = obj1.Change("test");                  /// OR                  MasterObject obj2 = new MasterObject(ChangerType.Type2);             obj2.DoSomethingSpecial2();             string result2 = obj2.Change("test");              }          }      I have a feeling this is Factory type pattern or maybe Abstract factory, but I'm not sure how to fix my code to implement it correctly.