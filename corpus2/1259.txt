I have a complicated function that I need multiple times, so I want to memoize it and have the first evaluation done in parallel. Unlike in my example below it's not a continuous function, so interpolation is not an option. (In fact, it's values are also functions.) The naive approach clearly does not work, because the memoized value is then only known on the kernel it was evaluated on:               LaunchKernels[2];     f[x_] := f[x] = (Pause[3]; N[Sin[x]]); (*Expensive calculation*)     ParallelDo[f[x], {x, 3}];          ParallelEvaluate[AbsoluteTiming[f[1]]]          (* ==> {{3.000632, 0.841471}, {0.000024, 0.841471}} *)      I believe I found a workaround by doing something like this:               f[x_] := (Pause[3]; N[Sin[x]]); (*Expensive calculation - NO memoization*)     t = ParallelTable[f[x], {x, 3}];     Do[f[x] = t[[x]], {x,3}];      Using `SetSharedFunction[f]` before `ParallelDo` also yields a non-optimal result:               {{0.012051, 0.841471}, {0.012202, 0.841471}}      0.01 s is still a long time to look up a value (see above, it should be < 1 ms). Is there something more elegant or do I have to keep it like this? Edit: Just to be clear, the workaround above without Shared Functions works, it runs in parallel and the main kernel knows the values afterwards, but it strikes me as an ugly hack. I was wondering if there was an "official" solution.