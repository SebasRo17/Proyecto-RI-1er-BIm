In Douglas Crockford's "JavaScript: The Good Parts", he walks through three types of inheritance: classical, prototypal, and functional. In the part on functional inheritance he writes: > "The functional pattern also gives us a way to deal with super methods." He then goes on to implement a method named "superior" on all Objects. However, in the way he uses the superior method, it just looks like he is copying the method on the super object for later use:               // crockford's code:     var coolcat = function(spec) {         var that = cat(spec),             super_get_name = that.superior('get_name');         that.get_name = function (n) {             return 'like ' + super_get_name() + ' baby';         };         return that;     };      The original `get_name` method is copied to `super_get_name`. I don't get what's so special about functional inheritance that makes this possible. Can't you do this with classical or prototypal inheritance? What's the difference between the code above and the code below:               var CoolCat = function(name) {         this.name = name;     }          CoolCat.prototype = new Cat();          CoolCat.prototype.super_get_name = CoolCat.prototype.get_name;     CoolCat.prototype.get_name = function (n) {         return 'like ' + this.super_get_name() + ' baby';     };      Doesn't this second example provide access to "super methods" too?