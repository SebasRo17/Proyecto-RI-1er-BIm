I've just finished reading The Art of Unit Testing, by Roy Osherove. It was an interesting book, but I'm having trouble with something he mentions near the end (section 11.2.2): > Identifying "roles" in the application and abstracting them under interfaces > is an important part of the design process. An abstract class shouldn’t call > concrete classes, and concrete classes shouldn’t call concrete classes > either, unless they’re data objects (objects holding data, with no > behavior). This allows you to have multiple seams in the application where > you could intervene and provide your own implementation. Specifically, I don't understand what he means when he says that concrete classes shouldn't call concrete classes. Consider the following examples in C#:               double roundedAge = Math.Floor(exactAge);      Is this not considered a call to a class because Math.Floor is a static method? Or is Osherove saying that the line of code above is bad design? Another example:               using (StreamReader reader = new StreamReader(path))     {         // do things     }      Is this bad design due to the use of a StreamReader? Or is this instance of StreamReader simply an object that holds data, as described in the quote above? Rather than starting a discussion on whether or not it's bad practice to have classes call other classes, my goal here is to try and better understand what Osherove means in the passage I've quoted. Does he really mean that the code in the two examples above should be avoided? Thanks in advance for any replies. EDIT: Below is an illustration from the book which is possibly elucidating. ![Nice](http://i.stack.imgur.com/7Jb0F.png)