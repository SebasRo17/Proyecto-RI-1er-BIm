> This is part of a series of questions which focuses on a project called the > Abstraction Project, which aims to abstract the concepts used in language > design in the form of a framework. > > Another page associated to it related to structural typing can be viewed > here. The meta-topic associated to an inquiry about the framework and the > proper place to post can be found here. How easy should it be to use a Language Development Framework? I've written large scale code generation frameworks which also included the ability to send the result to the language-specific compiler. The topic of ease of use comes up from one such framework example: CodeDOM, or the Code Document Object Model. It is a framework written by Microsoft that describes common code structures, but generally left a lot out (expression coercions) and tended to be a bit abstract in its representation of certain constructs, to downright emitting bad code based upon what you were doing: earlier CodeDOM poorly handled emitting `PrivateImplementationType` on `CodeMemberMethod`, when the type used was a generic interface. CodeDOM was my original reason for writing my first code generator. One thing I'm trying to do, to simplify the framework, is reduce the amount of work you need to do something, and focusing on actions versus the specific types that make up those actions. Here's a side by side comparison of how the framework I'm writing works:               //Truncated...     /* *      * From a project that generates a lexer, this is the       * state->state transition character range selection logic.      * */     var nextChar = nextMethod.Parameters.Add(new TypedName("currentChar", typeof(char).GetTypeReference()));     //...     char start = rangeElement.B.Value.Start;     char end = rangeElement.B.Value.End;     /* *      * 'start' <= nextChar && nextChar <= 'end'      * */     currentExpression = start.LessThanOrEqualTo(nextChar).LogicalAnd(nextChar.LessThanOrEqualTo(end));      Versus CodeDOM:               //Truncated...     var nextChar = new CodeVariableReferenceExpression("nextChar");     //...     var start = new CodePrimitiveExpression(rangeElement.B.Value.Start);     var end = new CodePrimitiveExpression(rangeElement.B.Value.End);     currentExpression = new CodeBinaryOperatorExpression(new CodeBinaryOperatorExpression(start, CodeBinaryOperatorType.LessThanOrEqual, nextChar), CodeBinaryOperatorType.BooleanAnd, new CodeBinaryOperatorExpression(nextChar, CodeBinaryOperatorType.LessThanOrEqual, end));      The focus of the framework is language enthusiasts, as well as those interested in generating code or applications. Given its focus on compilation, code generation, and language development, should the framework focus on ease of use or raw power? My primary goal is to increase the availability of such tools, so those interested in the domain don't require a lot of experience in the language theory domain before they can start to work on their own language-centric projects. Given that I'm the author of the framework, my view of "usability" is biased. Thus, I must ask another if the focus and goal make sense to others who aren't associated to the project.