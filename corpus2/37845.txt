**Prehistory** I am trying to make some statistical analysis of some experimental data, arises from measurements made ​​on an ordinal scale. I faced with the problem of _rank aggregation_ : to get from many "individuals" orderings (on the same set of objects) one "collective" ordering. The most "natural" approach to this problem is _Kemeny-Young method_ (better look primary source). Surprisingly I found out that there is no program application for this method!!! (There is one C++ code, but it does not allow weak orderings, i.e., does not allow cases when several objects share same position at ordering). Previously I asked some points (one, two) for constructing needed code, but now I have decide to tell all at once — because the problem is more complicated than I thought at first, and I can miss some points since I am null in _Mathematica_ and programming. **Description** Let $R_1, R_2, R_3, ..., R_N$ denote "individuals" weak orderings of $N$ given objects $a, b, c, ...$. Let consider $R$ as set of ordered pairs of objects. Then $(a, b)\in R$ has the usual interpretation: "$a$ is _ordered at least as good as b_ at $R$". In case $(b, a)$ is also in $R$ we say that " _both are ordered equally good_ ". Where in case $(b,a)$ is not in $R$ we say that "$a$ is _ordered above_ $b$" or "$b$ is _ordered below_ $a$". (After introducing metric we will see that it is possible to neglect — since they don't make further difference — such pairs as $(a, a), (b, b), (c, c)...$.) > To demonstrate orderings notation, here are all possible orderings for > $N=3$: > > $\ R_1=\\{(a, b), (a, c), (b, c)\\}$ > > $\ R_2=\\{(a, c), (a, b), (c, b)\\}$ > > $\ R_3=\\{(a, b), (a, c), (b, c), (c, b)\\}$ > > $\ R_4=\\{(b, a), (b, c), (a, c)\\}$ > > $\ R_5=\\{(b, c), (b, a), (c, a)\\}$ > > $\ R_6=\\{(b, a), (b, c), (a, c), (c, a)\\}$ > > $\ R_7=\\{(c, a), (c, b), (a, b)\\}$ > > $\ R_8=\\{(c, b), (c, a), (b, a)\\}$ > > $\ R_9=\\{(c, a), (c, b), (a, b), (b, a)\\}$ > > $R_{10}=\\{(a, b), (b, a), (a, c), (b, c)\\}$ > > $R_{11}=\\{(a, c), (c, a), (a, b), (c, b)\\}$ > > $R_{12}=\\{(b, c), (c, b), (b, a), (c, a)\\}$ > > $R_{13}=\\{(a, b), (b, a), (a, c), (c, a), (b, c), (c, b)\\}$ For such notation we may introduce metric $\delta$ (so-called _Kemeny distance_ ) between any two orderings $R_1$ and $R_2$ by next way: $$\delta(R_1,R_2)=|R_1\setminus R_2|+|R_2\setminus R_1|$$ where $\setminus$ means set-theoretic difference; and $||$ means cardinality of set (i.e., number of elements, because sets are finite). The required "collective" ordering $Ω$ (so-called _Kemeny mean_ ) is such ordering of given objects, that minimizes the sum of the squares of Kemeny distances to all "individuals" orderings, i.e.: $$Ω=\min \sum_{i=1}^{N } \delta(R_i,Ω)^2$$ In fact, $Ω$ may be not unique, there may be several $Ω_1, Ω_2, ...$ for which the appropriate sums of the squares of Kemeny distances are equal and minimal. So in general case $Ω$ is set of such $Ω_i$. **How to attack** So we have several of $R_i$ as input and the goal is to output $Ω$. It looks, like there should be brute-force with one-by-one generating of possible ordering, calculating the sum of the squares of Kemeny distances to all input orderings and verifiaction for minimum. Even for small $N$ number of possible orderings is huge (for my data case $N=10$, there are over $10^8$ possible orderings), so we should keep less data.