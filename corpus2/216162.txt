I have hardware I communicate with via TCP. This hardware accepts ~40 different commands/requests with about 20 different responses. I've created a HardwareProxy class which _has a_ TcpClient to send and receive data. I didn't like the idea of having 40 different methods to send the commands/requests, so I started down the path of having a single SendCommand method which takes an ICommand and returns an IResponse, this results in 40 different SpecificCommand classes. The problem is this requires semantic coupling, i.e. the method that invokes SendCommand receives an IResponse which it has to downcast to SpecificResponse, I use a future map which I believe ensures the appropriate SpecificResponse, but I get the impression this code smells. Besides the semantic coupling, ICommand and IResponse are essentially empty abstract classes (Marker Interfaces) and this seems suspicious to me. If I go with the 40 methods I don't think I have broken the single responisbility principle as the responsibility of the HardwareProxy class is to act as the hardware, which has all of these commands. This route is just ugly, plus I'd like to have Asynchronous versions, so there'd be about 80 methods. Is it better to bite the bullet and have a large class, accept the coupling and MarkerInterfaces for a smaller soultuion, or am I missing a better way? Thanks. ## Possible Solution Based on DXM's response this is what I came up with:               struct Proxy     {        template<class C, class R>        ICommand<C, R>* CreateCommand()        {           return new C(this);        }             void Send(std::string s)        {           //tcp send here for now print command name           cout << s << endl;        }     };          template<class Derived>     struct IResponse     {};          struct DerivedResponse1 : IResponse<DerivedResponse1>     {        std::string GetValue()        {           return "DerivedResponse1";        }     };          template<class Derived, class Response>     struct ICommand     {     protected:        Proxy* pProxy;     public:        Response* Send()        {           std::string msg = "Sent: " + static_cast<Derived*> (this)->GetName();           pProxy->Send(msg);           //wait for future here           Response* pResponse = new Response; //replace with future value           return pResponse;        }     };          struct DerivedCommand1 : public ICommand<DerivedCommand1, DerivedResponse1>     {        DerivedCommand1(Proxy* pProxy)        {           this->pProxy = pProxy;        }             std::string GetName()        {            return "DerivedCommand1";        }     };          int main()     {        Proxy proxy;             ICommand<DerivedCommand1, DerivedResponse1>* pDerivedCommand =                 proxy.CreateCommand<DerivedCommand1, DerivedResponse1>();        DerivedResponse1* pDerivedResponse = pDerivedCommand->Send();        cout << "Received :" << pDerivedResponse->GetValue() << endl;             return 0;     }      How does that look? It seems like I may not even need the IResponse interface, we'll have to see when I implment it. I realize there is a lot of important stuff missing, like the futures, but I wanted to get the template stuff down first. What do you think of passing in the proxy to the command? Also what about having the send in the ICommand as opposed to writting it for every command? Am I violating any other OO principles? Thanks.