I'm exploring a piece of code in Architecture Explorer in Visual Studio 2010 to study the relations between methods. I noticed a strange behavior. Take the following source code. It generates a hello message based on a template and a template engine, the template engine being a method (a sort of strategy pattern simplified at a maximum for demo purposes).               public string GenerateHelloMessage(string personName)     {         return this.ApplyTemplate(             this.DefaultTemplateEngine, this.GenerateLocalizedHelloTemplate(), personName);     }          private string GenerateLocalizedHelloTemplate()     {         return "Hello {0}!";     }          public string ApplyTemplate(         Func<string, string, string> templateEngine, string template, string personName)     {         return templateEngine(template, personName);     }          public string DefaultTemplateEngine(string template, string personName)     {         return string.Format(template, personName);     }      The graph generated from this code is this one: ![enter image description here](http://i.stack.imgur.com/khnYr.png) Change the first method from this:               public string GenerateHelloMessage(string personName)     {         return this.ApplyTemplate(             this.DefaultTemplateEngine, this.GenerateLocalizedHelloTemplate(), personName);     }      to this:               public string GenerateHelloMessage(string personName)     {         return this.ApplyTemplate(             (a, b) => this.DefaultTemplateEngine(a, b),             this.GenerateLocalizedHelloTemplate(), personName);     }      and the graph becomes: ![enter image description here](http://i.stack.imgur.com/bWuuh.png) While semantically identical, those two versions of code produce different dependency graphs, and Architecture Explorer shows no trace of the lambda expression (while Visual Studio's code coverage, for example, shows them, as well as Code analysis seems to be able to understand that the link exists). How would it be possible, without changing the source code, to:   * Either force Architecture Explorer to display everything, including lambda expressions,   * Or make it traverse lambda expressions while drawing a dependency through them (so in this case, drawing the dependency from `GenerateHelloMessage` to `DefaultTemplateEngine` in the second example)?