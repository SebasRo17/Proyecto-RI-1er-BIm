I'm writing a database interface in PHP and I have a base `dbTables` class, as well as a base `dbTableFields` class. `dbTables` has a function, `getFields()`, that instantiates `dbTableFields` objects, each of which carries essential data on each table field, and puts it into `dbTableFields->fields=array();` `dbTables` has several children. Now I've realized that the children need to use different versions of `getFields()`. But they only differ in one place: they need to instantiate `dbTableFields` children, rather than `dbTableFields` objects. I've solved this problem. I took advantage of PHP's ability to use variables to represent class names. All I had to do was, in `dbTables->getFields()` replace:               $this->fields = new dbTableFields();      with               $this->fields = new self::$field_model();      Where `self::$field_model = 'dbTableFields'; // string value for class` Now, in the child classes, I just have to override the `$field_model` property with the name of the appropriate `dbTableFields` descendents. Is this parallel inheritance scheme good form? Or am I creating an uncompromising mess? Is there some more-elegant and more maintainable method for achieving the same effect?