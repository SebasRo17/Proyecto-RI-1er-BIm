I am relatively new to Haskell and I am trying to learn how different actions can be executed in sequence using the do notation. In particular, I am writing a program to benchmark an algorithm (a function)               foo :: [String] -> [String]      To this purpose I would like to write a function like               import System.CPUTime          benchmark :: [String] -> IO Integer     benchmark inputList = do                              start <- getCPUTime                              let r = foo inputList                              end <- getCPUTime                              return (end - start) -- Possible conversion needed.      The last line might need a conversion (e.g. to milliseconds) but this is not the topic of this question. Is this the correct way to measure the time needed to compute function foo on some argument inputList? In other words, will the expression `foo inputList` be completely reduced before the action `end <- getCPUTime` is executed? Or will `r` only be bound to the thunk `foo inputList`? More in general, how can I ensure that an expression is completely evaluated before some action is executed?