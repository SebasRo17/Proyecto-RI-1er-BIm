Is it a good practice to use reflection if greatly reduces the quantity of boilerplate code? Basically there is a trade-off between performance and maybe readability on one side and abstraction/automation/reduction of boilerplate code on the other side. Edit: Here is an example of a recommended use of reflection. To give an example, suppose there is a an abstract class `Base` which has 10 fields and has 3 subclasses `SubclassA`, `SubclassB` and `SubclassC` each with 10 different fields; they are all simple beans. The problem is that you get two `Base` type references and you want to see if their corresponding objects are of same (sub)type and are equal. As solutions there is the raw solution in which you first check if the types are equal and then check all fields or you can use reflection and dynamically see if they are of the same type and iterate over all methods that start with "get" (convention over configuration), call them on both objects and call equals on the results.               boolean compare(Base base1, Base, base2) {         if (base1 instanceof SubclassA && base2 instanceof SubclassA) {               SubclassA subclassA1 = (SubclassA) base1;              SubclassA subclassA2 = (SubclassA) base2;              compare(subclassA1, subclassA2);         } else if (base1 instanceof SubclassB && base2 instanceof SubclassB) {              //the same         }         //boilerplate     }          boolean compare(SubclassA subA1, SubclassA subA2) {         if (!subA1.getField1().equals(subA2.getField1)) {              return false;         }         if (!subA1.getField2().equals(subA2.getField2)) {              return false;         }         //boilerplate     }          boolean compare(SubclassB subB1, SubclassB subB2) {         //boilerplate     }          //boilerplate          //alternative with reflection      boolean compare(Base base1, Base base2) {             if (!base1.getClass().isAssignableFrom(base2.getClass())) {                 System.out.println("not same");                 System.exit(1);             }             Method[] methods = base1.getClass().getMethods();             boolean isOk = true;             for (Method method : methods) {                 final String methodName = method.getName();                 if (methodName.startsWith("get")) {                     Object object1 = method.invoke(base1);                     Object object2 = method.invoke(base2);                     if(object1 == null || object2 == null)  {                         continue;                     }                     if (!object1.equals(object2)) {                         System.out.println("not equals because " + object1 + " not equal with " + object2);                         isOk = false;                     }                 }             }                  if (isOk) {                 System.out.println("is OK");             }     }