Our application stores settings in the platform's "transactional key-value store".               prefs.edit().putInt("a", 1).commit();      int a = prefs.getInt("a");      I'd like to refactor our code for the following goals:   * Better type safety (ex.: int a = prefs.getA(); prefs.setA(1);)   * Hide away the complexity of storing values It looks like I need a Preferences class and a class to translate it to/from storage.               public class Preferences {         private int a;              public int getA() {             return a;         }              public void setA(int a) {             this.a = a;         }     }          public class PreferencesMapper {         IValueStore valueStore;              public PreferencesMapper(IValueStore valueStore) {             this.valueStore = valueStore;         }              public void save(Preferences prefs) {             this.valueStore                     .edit()                     .putInt("a", prefs.getA())                     .commit();         }              public Preferences load() {             Preferences prefs = new Preferences();                  prefs.setA(this.valueStore.getInt("a"));                  return prefs;         }     }      Now the weak typing is concentrated in that single class and the rest of the application is more robust. However, the code still leaks load/save complexity and I wonder if it's necessary.               Preferences p = preferenceMapper.load();     p.setA(1);     preferencesMapper.save(p);      I think the ideal situation, with respect to single responsibility design, is to have a single Preferences class that knows how to load/save (or delegates to something else on its own). I'm looking for direction on making this situation better.