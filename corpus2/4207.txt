For some experiments I need some basic timer function. I tried various methods, and neither of them are fully satisfactory. What I need is a button, that starts/stops a timer, resets timer with each restart, updates some other variables as well besides the timer and has a trigger effect when started/stopped too. It should also be customizable for having any text on the button. Let's see how `Trigger` behaves. First, define a switch that tests whether the counter is `active` or not, a `total` time of 50, and continuous variables for the running `time` and `timeLeft`:               active = False;     time = 0;     total = timeLeft = 50;      The `Trigger` should switch `active` and update `time` and `timeLeft`:               Trigger[Dynamic[time, (time = #; timeLeft = total - #;          active = 0 < # < total) &], {0, total}]          Dynamic@Column@{time, timeLeft, active}      This however has the following issues:   * There seems to be no way to stop the timer other than the `Trigger`'s own pause button.   * The way `active` is set is wasteful, it is unnecessary to test for it every timestep. Sadly, no other way I could figure out how to call a function _only once_ when the `Trigger` is started or stopped. I've tried to play with the start/end arguments (as in `Dynamic[var, {start, update, end}]`) with no success. Perhaps layering a button above the trigger? See next issue.   * No label can be given for the button. The option `Appearance` does not seem to have any effect here, and even if I remove all buttons via `AppearanceElements->{}`, I cannot overlay a normal button over it and wrap it in an `EventHandler` that passes events down to the trigger, as the Trigger object cannot be set to have the same `ImageSize` as the `Button`: .               EventHandler[Overlay[{        Button[Dynamic@If[active, "Stop", "Start"]],        Trigger[         Dynamic[time, (time = #; timeLeft = total - #) &], {0, total},          AppearanceElements -> {"TriggerButton"(*,"PauseButton",           "ResetButton"*)}]        }],      {"MouseClicked" :> (active = ! active)}, PassEventsDown -> True]     Dynamic@Column@{time, timeLeft, active}      ![Mathematica graphics](http://i.stack.imgur.com/Iizlj.png) I also tried to construct my own clock function, as follows. It uses a global clock, that starts immediately when the cell is generated, thus it always runs in the background, and the actual stopwatch is created by subtracting the start time (the moment the button is pushed) from the global clock.               active = False;     total = 50;     start = end = time = 0;          Column@{       Dynamic[globalTime = Clock[{0, total}]; time = globalTime - start;         globalTime],       Dynamic@If[active, time, end - start],       Dynamic@Button[If[active, "Stop", "Start"],          If[active, end = globalTime, start = globalTime];          active = ! active]       }      ![Mathematica graphics](http://i.stack.imgur.com/wEpI8.png) (Note that the actual dynamic value of `globalTime` (upper value) is not copied correctly via Szabolcs's otherwise magnificent image upload palette, and it shows less than _time_ (lower value).) However, It has the annoying feature that if `globalTime` does not appear on screen, no dynamic updating is done. Thus if I want to hide it, I have to wrap it into `Style[..., Opacity[0]]`. Also, `time` is constantly (and unnecessarily) updated, even if the button was not pushed. **Question** **Is there any reliable built-in way to provide such a functionality? How would you solve this problem?** I am interested in any idea, as for the last 3 months, I had to construct 3 guis with three different timing functions, and there is always something new (request/issue/feature) I have to deal with.