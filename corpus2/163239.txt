I am currently designing an n-tier solution which is using Entity Framework 5 (.net 4) as its data access strategy, but am concerned about how to incorporate dependency injection to make it testable / flexible. My current solution layout is as follows (my solution is called Alcatraz): **Alcatraz.WebUI** : An asp.net webform project, the front end user interface, references projects _Alcatraz.Business_ and _Alcatraz.Data.Models_. **Alcatraz.Business** : A class library project, contains the business logic, references projects _Alcatraz.Data.Access_ , _Alcatraz.Data.Models_ **Alcatraz.Data.Access** : A class library project, houses _AlcatrazModel.edmx_ and `AlcatrazEntities` DbContext, references projects _Alcatraz.Data.Models_. **Alcatraz.Data.Models** : A class library project, contains POCOs for the Alcatraz model, no references. My vision for how this solution would work is the web-ui would instantiate a repository within the business library, this repository would have a dependency (through the constructor) of a connection string (not an `AlcatrazEntities` instance). The web-ui would know the database connection strings, but not that it was an entity framework connection string. In the Business project:               public class InmateRepository : IInmateRepository     {         private string _connectionString;              public InmateRepository(string connectionString)         {             if (connectionString == null)             {                 throw new ArgumentNullException("connectionString");             }                  EntityConnectionStringBuilder connectionBuilder = new EntityConnectionStringBuilder();                  connectionBuilder.Metadata = "res://*/AlcatrazModel.csdl|res://*/AlcatrazModel.ssdl|res://*/AlcatrazModel.msl";             connectionBuilder.Provider = "System.Data.SqlClient";             connectionBuilder.ProviderConnectionString = connectionString;                  _connectionString = connectionBuilder.ToString();         }              public IQueryable<Inmate> GetAllInmates()         {             AlcatrazEntities ents = new AlcatrazEntities(_connectionString);                  return ents.Inmates;         }     }      In the Web UI:               IInmateRepository inmateRepo = new InmateRepository(@"data source=MATTHEW-PC\SQLEXPRESS;initial catalog=Alcatraz;integrated security=True;");          List<Inmate> deathRowInmates = inmateRepo.GetAllInmates().Where(i => i.OnDeathRow).ToList();      I have a few related questions about this design.   1. Does this design even make sense in terms of Entity Frameworks capabilities? I heard that Entity framework uses the Unit-of-work pattern already, am I just adding another layer of abstract unnecessarily?   2. I don't want my web-ui to directly communicate with Entity Framework (or even reference it for that matter), I want all database access to go through the business layer as in the future I will have multiple projects using the same business layer (web service, windows application, etc.) and I want to have it easy to maintain / update by having the business logic in one central area. Is this an appropriate way to achieve this?   3. Should the Business layer even contain repositories, or should that be contained within the Access layer? If where they are is alright, is passing a connection string a good dependency to assume? Thanks for taking the time to read!