I was just reviewing the _Mathematica_ benchmark code linked from the Julia language home page http://julialang.org/. The stated goal of the benchmarks is to test the performance of specific algorithms, expressed in a _reasonable idiom_ in each language, and all languages use the same algorithm. In particular, the Fibonacci benchmarks are all recursive, and the _Mathematica_ code reads               ClearAll[fib];     fib = Compile[{{n, _Integer}},          If[n < 2, n, fib[n - 1] + fib[n - 2]],         CompilationTarget -> "WVM"     ];      Now, dynamic programming is certainly a _reasonable idiom_ in _Mathematica_ :               fib[n_Integer]:= fib[n]= If[n < 2, n, fib[n - 1] + fib[n - 2]]      and this dynamic _uncompiled_ code will be much faster than the benchmark code, especially for large n (unless the WVM compiler is smart enough to do automatic memoization). The test only computes fib[20] and it would be most interesting to try say fib[100] in the various languages (the times for R, MATLAB, and OCTAVE are excessive even for n=20). It would also be useful, I think, for better coding of all the benchmark examples, if someone has the time and energy ...