I have the fallowing code (the functions within that code are replaced by simpler ones, but the code structure is identical): $$$$               g[x_, y_, z_] := x^2 + y^2 + z^2;     f[x_, y_, z_] := (buffer = Minimize[g[x, y, z], x];        xmin = x /. buffer[[2]];        g[xmin, y, z]);          Plot3D[f[x, y, z], {y, 0, 4}, {z, 0, 4}, PlotPoints -> 2]         It takes my computer about 7 seconds to process that code. With my actual functions it takes several minutes. This is only one step in a longer chain of steps my program needs to process. Is there a way to speed that step up? Maybe something faster than using the function Minimize. $$$$ $$$$ If i modify my code like this:                g[x_, y_, z_] := x^2 + y^2 + z^2;      f[x_, y_, z_] := (buffer = Minimize[g[x, y, z], x];            xmin = x /. buffer[[2]];            g[xmin, y, z]);         Plot3D[f[x, y, z], {y, 0, 4}, {z, 0, 4}, PlotPoints -> 2,                  RegionFunction -> Function[{x, y, z}, x + y < 3]]      $$$$ The result is what i want, but it actually takes more time, even though in the resulting plot are less data points. I assume mathematica plots first my function and then it cuts with RegionFunction in my plot. Is there a way to make Mathematica just plot the resulting area and not plot the area that is later cut out anyway? I've tried it like this:                g[x_, y_, z_] := x^2 + y^2 + z^2;      f[x_, y_, z_] := (buffer = Minimize[g[x, y, z], x];            xmin = x /. buffer[[2]];            g[xmin, y, z]);         Plot3D[f[x, y, z], {y, 0, 4}, {z, 0, 4 - y}, PlotPoints -> 3]      $$$$ But the resulting plot doesn't exactly look like the one resulting using RegionFunction, it looks abit more 'bumpy'. So i've increased the PlotPoints from 2 to 3, then the resulting plot looks pretty much like the one with RegionFunction. But the Problem is, now plotting takes longer then with RegionFunction ;) $$$$ Thanks for your help. $$$$ $$$$ Your answeres (using the function Evaluate[]) helped me solve the problem for the above described situation. However it does not work with my actual functions, so i have to write them down here after all.               bindeaa[e0_] := e0;     c[e0_] := 40 e0;     bindeab[e0_] := 1.27 e0;           alpha[gamma_, p_, epsilon_] := p (gamma  - epsilon);     beta[b_, epsilon_, n2_] := b epsilon^2 n2^(3/2);                 eisl[b_, e0_, g_, gamma_, p_, epsilon_, n2_, x_] :=                  g c[e0] (epsilon)^2 - bindeaa[e0] +                  e0 ((-2 Log[E^(1/2) x])/x^2 + alpha[gamma, p, epsilon]/x +                  beta[b, epsilon, n2]/x^(3/2));               eislminx[b_, e0_, g_, gamma_, p_, epsilon_, n2_]:=      (minxzwischen = FindMinimum[{eisl[b, e0, g, gamma, p, epsilon, n2, x], 0 < x},x];                   minx = x /. minxzwischen[[2]];                             eisl[b, e0, g, gamma, p, epsilon, n2, minx]);           Plot[eislminx[10, 1, 0.7, 0.3, 4.9, 0.05, n2], {n2, 0, 10},       PlotPoints -> 2, Evaluated -> True]      Mathematica gives the following error messages: FindMinimum::nrgnum: The gradient is not a vector of real numbers at {x} = {1.}. >> FindMinimum::nrgnum: The gradient is not a vector of real numbers at {x} = {1.}. >> FindMinimum::nrgnum: The gradient is not a vector of real numbers at {x} = {1.}. >> General::stop: Further output of FindMinimum::nrgnum will be suppressed during this calculation. >> ReplaceAll::reps: {x} is neither a list of replacement rules nor a valid dispatch table, and so cannot be used for replacing. >> ReplaceAll::reps: {x} is neither a list of replacement rules nor a valid dispatch table, and so cannot be used for replacing. >> What is the problem here?