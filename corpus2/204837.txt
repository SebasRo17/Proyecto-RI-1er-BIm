I currently have a set of components named DataValues, ValueParsers, ValueFormatters and ValueValidators. The first one defines an abstract base class DataValue and contains a whole load of implementations. The 3 other components each define in interface similar to their name (minus the "s"), and also contain a bunch of implementations of those. These 3 depend on DataValues. There are no further dependencies. In other words, each component currently contains a whole inheritance hierarchy. I recently re-watched EP16 of Robert C. Martin's Clean Coders, where he points out this is one of the most common mistakes made in package design. This made me realize that this exact thing is going on for the here described packages. The question then is how to best improve upon the current component design. Luckily none of those components have seen their first release yet, so things can still be moved around, and boundaries can still be redefined. Releases for these are on the horizon though, so I better get it right now. What I'm thinking of doing now is to create a new component to hold the mentioned abstract class and interfaces for all these components. It would also contain the Exceptions of these components and perhaps some trivial implementations of the interfaces. This new component would then be needed by all the current ones, and by all the ones needing the current ones. Then again, in this later category, there will be a number components that can just depend on the new and get rid of their current dependency on the much more concrete and unstable ones containing all the interface implementations. This is great for the stable dependencies principle, and equally nice for the reuse release equivalence principle. It's however doing rather bad when it comes to the common closure and common reuse principles. Concretely this means that components that need the ValueParsers interface but don't care about the ValueValidators one will still depend on it as it is in the same package. They can thus be affected by it for no good reason. Then again, considering how abstract/stable this new component ends up being, I don't really see this causing much problems. I'm looking for ideas on how to better draw the component boundaries and concerns or suggestions about the alternative I described.