Assume you have two classes, a `Manager` who holds a set of `Client`s and the `Client` holds a backreference to the `Manager`.               class Manager {     public:         void addClient(Client* client) {             m_clients.push_back(client);             client->setManager(this);         }     private:         std::list<Client*> m_clients;     };          class Client {     public:         void setManager(Manager* manager) {             m_manager = manager;         }          private:         Manager* m_manager;     };      The confusing, probably even dangerous feature of this API is that Client exposes a setManager() method that can be called by anyone, yet should only be called by the Manager::addClient() method. `assert(manager->hasClient(this))` in setManager() would prevent wrong calling at runtime, however I would prefer a solution that doesn't allow the user to call methods he isn't supposed to call. What would be common solution? I don't   * want to use `friend` to expose all of Clients members to Manager so that he can establish the binary connection in `addChild()`   * want both classes to share some kind of Composite base class. They should remain unrelated inheritancewise.