I want a function that compares an expression with a specific pattern. The expression has always the following form:               expr = F1[x1]F2[y1] + F1[x2]F2[y2] + F1[x3]F2[y3]      which is a sum of three terms, each term being the product of`F1[..]*F2[..]` with arbitrary arguments. Now what I need is a function that searches the arguments of the expression for a specific pattern. As an example, I want the following pattern: `x1! = x2`, `x1 == x3`, `y1 != y 2`, `y2 != y3`.               v = F1[a]*F2[b] + F1[c]*F2[d] + F1[a]*F2[e]; IsMyPattern[v] (*True*)     w = F1[a]*F2[a] + F1[c]*F2[c] + F1[a]*F2[e]; IsMyPattern[w] (*True*)     x = F1[a]*F2[b] + F1[a]*F2[d] + F1[a]*F2[e]; IsMyPattern[x] (*False, because x1 == x2*)     y = F1[a]*F2[b] + F1[c]*F2[d] + F1[f]*F2[e]; IsMyPattern[y] (*False, because x1 != x3*)     z = F1[a]*F2[b] + F1[c]*F2[b] + F1[a]*F2[e]; IsMyPattern[z] (*False, because y1 != y2*)      The only idea I have is to use `ToString` and apply string manipulations, but thats ugly and most likely slow. **Update** A followup question on the same issue: How can I make the IsMyPattern function more general, such that it matches inputs which have (complex) coefficients and different signs?               k = 2*F1[a]*F2[b] + F1[c]*F2[d] + F1[a]*F2[e]; IsMyPattern[k] (*True*)     l = F1[a]*F2[b] - F1[c]*F2[d] - F1[a]*F2[e]; IsMyPattern[l] (*True*)     m = I*F1[a]*F2[b] + 3*F1[c]*F2[d] - F1[a]*F2[e]; IsMyPattern[m] (*True*)      **Update2** The solution to this problem is remarkable simple, one just needs to add a BlankNullSequence. The function (for arbitrary number of arguments) looks like this:                IsMyPattern[expr_] := MatchQ[expr, ___ F1[x1__]*F2[y1__] + ___ F1[x2__]*F2[y2__] + ___ F1[x3__]*F2[y3__] /; {x1} =!= {x2} && {x1} === {x3} && {y1} =!= {y2} && {y2} =!= {y3}]