This question regards the usage of the Decorator pattern to add little functionality to objects of large classes. Following the classic Decorator pattern, please consider the following class structure: ![enter image description here](http://i.stack.imgur.com/FCyEd.png) For example, imagine this happens inside a game. Instances of `ConcreteCharacterDecorator` are meant to add little functionality to the `ConcreteCharacter` they are 'wrapping'. For instance, `methodA()` returns an `int` value representing the damage the character inflicts on enemies. The `ConcreteCharacterDecorator` simply adds to this value. Thus, it only needs to add code to `methodA()`. The functionality of `methodB()` stays the same. `ConcreteCharacterDecorator` will look like this:               class ConcreteCharacterDecorator extends AbstractCharacterDecorator{              ConcreteCharacter character;              public ConcreteCharacterDecorator(ConcreteCharacter character){             this.character = character;         }              public int methodA(){             return 10 + character.methodA();         }              public int methodB(){             character.methodB(); // simply delegate to the wrapped object.         }          }      This is no problem with small classes containing two methods. **But what if`AbstractCharacter` defined 15 methods?** `ConcreteCharacterDecorator` would have to implement all of them, even though it's only meant to add little functionality. I will end up with a class containing one method that adds a little functionality, and another 14 methods that simply delegate to the inner object. It would look like so:               class ConcreteCharacterDecorator extends AbstractCharacterDecorator{              ConcreteCharacter character;              public ConcreteCharacterDecorator(ConcreteCharacter character){             this.character = character;         }              public int methodA(){             return 10 + character.methodA();         }              public int methodB(){             character.methodB(); // simply delegate to the wrapped object.         }         public int methodC(){             character.methodC(); // simply delegate to the wrapped object.         }         public int methodD(){             character.methodD(); // simply delegate to the wrapped object.         }         public int methodE(){             character.methodE(); // simply delegate to the wrapped object.         }         public int methodF(){             character.methodF(); // simply delegate to the wrapped object.         }         public int methodG(){             character.methodG(); // simply delegate to the wrapped object.         }         public int methodH(){             character.methodH(); // simply delegate to the wrapped object.         }         public int methodI(){             character.methodI(); // simply delegate to the wrapped object.         }         public int methodJ(){             character.methodJ(); // simply delegate to the wrapped object.         }         public int methodK(){             character.methodK(); // simply delegate to the wrapped object.         }         public int methodL(){             character.methodL(); // simply delegate to the wrapped object.         }         public int methodM(){             character.methodM(); // simply delegate to the wrapped object.         }         public int methodN(){             character.methodN(); // simply delegate to the wrapped object.         }         public int methodO(){             character.methodO(); // simply delegate to the wrapped object.         }          }      Obviously, very ugly. I'm probably not the first to encounter this problem with the Decorator. How can I avoid this?