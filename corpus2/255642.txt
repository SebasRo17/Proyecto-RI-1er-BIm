I am working on an plugin for some game-server. The information about the plugin is not really necessary. _Few points you might find helpful to answer to this question:_ **The server** The server is programmed very badly. The whole design structure and how it handles things, therefore I cannot implement anything that will need to make me change how the server handles packets. The server has a list of all "being-sent" packets, and **sends them to the client every 600ms** So basically, the client is being updated every 600ms if there are incoming packets from the server. **My plugin** My plugin needs to update a few UIs of the client, such as new player names, change the current opened interface window, and so on. I can use a `DataMapper` class, which contains the object which has ability & access to add new packets to the list (it's not really a list; it's just a list of bytes and frames). Now look at this _dummy_ snippet (Note - this is not my plugin, but just a simple example of what I mean):               public class MyPluginPlayer {              private DataMapper mapper;         private int state;              public void setState(int state) {             this.state = state;         }              public void getState() {             return this.state;         }              public void selectWindowForState() {             if (this.state == 5) {                 mapper.createLongWindow();             }             else if (this.state == 4) {                 mapper.createWideWindow();             }             // .... etc ....         }     }      In my _dummy_ example, `MyPluginPlayer` is the lass which is responsible to handle business logic for the player that is part of my plugin, let's say my plugin is a small mini-game, like a cards game. So basically, imagine there is a manager class, which contains a List of `MyPluginPlayer` objects, and it loops through them all and works them out, setting the current state, and then calls `selectWindowForState()`. `selectWindowForState()` method basically reads all possible states, and then reads which state is the current state, and then calls the suitable method in the `DataMapper`, to send the right packet. The `DataMapper` class basically does all the dirty work such as creating new packet frame, writing the bytes, `int`s and whatever that is needed for the specific packet. **The problem** I call the use of `DataMapper` above bad, because I don't feel like the domain class should really have direct access to the `DataMapper`. I thought of making a `Queue` list and instead of calling `mapper.createWideWindow()` or whatever, it will add the action to the queue list, and then the `DataMapper` will access that list, and process all these packets to the server's global outgoing packet list. The `DataMapper` will do that at the end of every loop cycle that's done in the manager class.               for (Player p : players) {         MyPluginPlayer domain = p.getDomain();         // ...... management ..... //              p.getMapper().update(); //goes through the Queue list and adds all packets to the server outgoing packets     }      But I am not really sure on how to define these packet updates. The only method I can think of is, every packet will have an own class which implements an interface. But I will need to create a class for each packet, and I don't really like the design of many many classes for a small thing. What do you think of both of these methods? Could you suggest something better?