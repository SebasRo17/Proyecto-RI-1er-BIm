In an answer to another question, I suggested creating a randomized value for input to a specific method. In my experience this has been useful for making tests more readable and it lets you skip the "trivial phase" where you hardcode specific results in a method. Here's the unit test code pasted from the other answer, for quick reference:               [Test]     public void FullHouseReturnsTrue()     {         var roll = AnyFullHouse();              Assert.That(sut.IsFullHouse(roll));     }     [Test]     public void StraightReturnsFalse()     {         var roll = AnyStraight();              Assert.That(sut.IsFullHouse(roll), Is.False);     }      A couple of comments in response suggested that this strategy would not work well, because the helper method would need to be tested also. In my experience, I've never had a need to test methods like this, since creating the corresponding production code also tests my test code. Do `AnyStraight()` and `AnyFullHouse()` need to have their own unit tests? If so, how do you solve the chicken-and-egg problem that presents? **EDIT** Would I still want to create dedicated unit tests for the `AnyFullHouse` algorithm if I inlined the method?               [Test]     public void FullHouseReturnsTrue()     {         var roll = listOfHardCodedFullHouseRolls[_random.Next(0, listOfHardCodedFullHouseRolls.Length)];              Assert.That(sut.IsFullHouse(roll));     }