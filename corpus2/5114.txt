In this great answer a compiled version of the Nelder-Mead algorithm is presented. Since it works on arbitrary dimensions (i.e. arbitrary number of arguments), it has to use apply on the objective function. The problem is that `Apply` is not directly supported inside `Compile`. To overcome this limitation the following code is used:               (* Produces compiled code for the Nelder-Mead algorithm with the objective function inlined *)     ClearAll[apply];     SetAttributes[apply, HoldAll];     apply[f : (_Function | _CompiledFunction), vars : {__Symbol}] :=         With[{applied := f @@ vars},           Function[arglist, Block[vars, vars = arglist; applied]]          ];      This seems to work (inside the package), but I have no idea, how it works. **Could somebody explain the techniques behind this code snippet?** Specifically:   * What does `SetDelayed` do inside `With`?    * Why does `vars` appear twice in the arguments to `Block`?    * Why doesn't this minimal example work? (I believe it mimics what is done in the mentioned answer...)              Clear[a, b, c, x, y, z, objectiveFunction, cfunc];     objectiveFunction = Compile[{a, b, c, x, y, z} ,        (a - x)^2 + 50 (b - y)^2 + (c - z)^2];          cfunc = With[{f = apply[objectiveFunction, {a, b, c, x, y, z}]},       Compile[ {{pts, _Real, 1}}, f@pts]       ]     << CompiledFunctionTools`     CompilePrint[cfunc]      **EDIT:** Here is the working snippet. Note that `"InlineCompiledFunctions"` must be set to `True` to avoid the call to `MainEvaluate`.               ClearAll[a, b, c, x, y, z, apply, objectiveFunction, cfunc];     (* Produces inlinable code for use inside Compile (where Apply is not \     supported directly) *)     SetAttributes[apply, HoldRest];     apply[f : (_Function | _CompiledFunction), vars : {__Symbol}] :=            Function[arglist, Block[vars, vars = arglist; f @@ vars]];          objectiveFunction = Compile[{a, b, c, x, y, z} ,        (a - x)^2 + 50 (b - y)^2 + (c - z)^2];     apply[objectiveFunction, {a, b, c, x, y, z}]     cfunc = With[{f = apply[objectiveFunction, {a, b, c, x, y, z}]},       Compile[ {{pts, _Real, 1}}, f@pts,         CompilationOptions -> {"InlineCompiledFunctions" -> True}]       ]     << CompiledFunctionTools`     CompilePrint[cfunc]