What are some OOP strategies for working with a database but keeping things unit testable? Say I have a User class and my production environment works against MySQL. I see a couple possible approaches, shown here using PHP:   1. Pass in a $data_source with interfaces for `load()` and `save()`, to abstract the backend source of data. When testing, pass a different data store.              $user = new User( $mysql_data_source );     $user->load( 'bob' );     $user->setNickname( 'Robby' );     $user->save();        2. Use a factory that accesses the database and passes the result row to User's constructor. When testing, manually generate the $row parameter, or mock the object in UserFactory::$data_source. (How might I save changes to the record?)              class UserFactory {         static $data_source;              public static function fetch( $username ) {             $row = self::$data_source->get( [params] );                  $user = new User( $row );             return $user;         }     }      I have _Design Patterns_ and _Clean Code_ here next to me, but I'm struggling to find applicable concepts.