I am trying to solve numerically an integral equation, and from a couple of tests I can see that the result has a strong logarithmic divergence. For my specific problem it is very important to have accurate results in the region of very small arguments, but that doesn't work since I am forced to replace the lower limit of integration (zero, that is) with non-zero values (0.0001 or whatever) otherwise the program crashes. So I though about integrating on a logarithmic grid, but I don't know how that works in Mathematica. (I have searched in the mathematica references, but could not find an answer). Anyone has an idea?               α = 2.85;     g = (Pi/2) α;     Nf := 2;          cs[x_] := 2 ArcCos[x]/Sqrt[1 - x^2];     csh[x_] := 2 ArcCosh[x]/Sqrt[x^2 - 1];     prefB[p_, k_, d_] :=      (p^2 + k^2 (1 - 1/d^2))/Sqrt[p^2 d^4 - 1/4 ((p^2 + k^2) d^2/k - k )^2];     pieceB[k_, d_] :=        If[d B[k]/k^2 < 1, cs[d B[k]/k^2], If[d B[k]/k^2 > 1, csh[d B[k]/k^2], 2]];          B[p_] = p^2 ;     iterstep :=      (values =      Parallelize[     Table[{p, p^2 +  g/(Pi^3  Nf) (NIntegrate[             prefB[p, k, d] ((d^2 B[k]^2/k^4 - 1) (Pi - g pieceB[k, d]) +                 B[k ]/k^2 d  g^2 csh[g])/(d^2 B[k]^2/k^4 + g^2 - 1),             {d, 0, 1/(1 + p)}, {k, p d/(d + 1), p d/(1 - d)},             WorkingPrecision -> 16,             PrecisionGoal -> 2,             MaxRecursion -> 100,            AccuracyGoal -> 16,             Method -> {"SymbolicPreprocessing", "OscillatorySelection" -> False}] +            NIntegrate[            prefB[p, k, d] ((d^2 B[k]^2/k^4 - 1) (Pi - g pieceB[k, d]) +                 B[k ]/k^2 d  g^2 csh[g])/(d^2 B[k]^2/k^4 + g^2 -1),             {d, 1/(1 - p), Infinity},             {k, p d/(d + 1), p d/(d - 1)},              WorkingPrecision -> 16, PrecisionGoal -> 2,             MaxRecursion -> 100, AccuracyGoal -> 16,            Method -> {"SymbolicPreprocessing","OscillatorySelection" -> False}])},             {p, 0, 0.99999, 1/20}]];          B[p_] = Interpolation[values , p, InterpolationOrder -> 4,   Method -> "Hermite"])               Do[iterstep, {3}] // AbsoluteTiming