I can never do too many Haskell tutorials. There is always something to refine and learn. So, I am working through chapter 10 of Real World Haskell, and everything makes sense. _but_ Why do               newtype Parse a = Parse { runParse :: ParseState -> Either String (a, ParseState) }          identity :: a -> Parse a     identity a = Parse (\s -> Right (a, s))          getState :: Parse ParseState     getState = Parse (\s -> Right (s, s))          putState :: Parse ()     putState = Parse (\s -> Right ((), s))      Why not simply do               type Parse a = ParseState -> Either String (a, ParseState)          identity :: a -> Parse a     identity a = \s -> Right (a, s)          getState :: Parse ParseState     getState = \s -> Right (s, s)          putState :: Parse ()     putState = \s -> Right ((), s)      In other words, what is the purpose of the wrap and unwrap pattern in here (which I see used in a lot of different places in Haskell)? We get the same `Parse Whatever` data type, but without the extra indirection.