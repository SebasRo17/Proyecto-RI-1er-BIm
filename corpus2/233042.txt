In this question I asked: Is the cost of designing more levels of abstraction to allow loose coupling worth the benefits, or not? People said that it's often worth the cost, but one should sense whether his/her application will actually be using this underlying design later on, or if it's just going to be a waste of time. My new question is: Should one create the infrastructure to allow flexibility and maintainability **in advance** \- thus making the development 'cleaner' and more 'organized', as things are developed on existing infrastructure and abstraction levels? With this approach, you desing the underlying infrastructure while not having much knowledge on how things will actually be implemented later. Thus, you might be coding things that might not be used later, and waste your time. But, the development will be cleaner and more organized. Or should one create infrastructure to increase flexibility and make things more loosely coupled, **during** the implementation of something - thus wasting less time on things that might not actually be used later? This approach prevents you from coding things that won't be used, but forces you to design underlying abstraction levels and designs **for existing code** , thus modifying existing code, instead of coding the underlying designs **before** coding the code that uses these designs. **Example for approach 1:** "Okay, now we start making this relatively large part of the application. This part will generally have to do with reacting to a couple of GUIs. Let's make an underlying level of abstraction for this part of the program, to later use when we implement it." **Example for approach 2:** "Okay, I'm in the middle of designing this part of the program. While working on it, I see this part better be loosely coupled. Let's make another level of abstraction to allow it, and modify this code to use that level of abstraction". Which approach makes more sense, or is more common?