I am trying to apply DDD to the design of a Release Management system. ## **Domain Entities**   * `Project`: The project/product/system.   * `ProjectEnvironment`: The environments (Test, Staging, Prod) that exist for this project. Each project has its own defined environments.   * `ProjectVersion`: A specific version of the project. This would be associated with a deployment package. ![Class diagram of entities](http://i.stack.imgur.com/rJhEW.png) ## **Aggregate Boundary** From this I would have `Project` be the aggregate root and `ProjectEnvironment` and `ProjectVersion` be aggregates of `Project`. Neither of these can exist without `Project`. ## **Repository** I would then only have a `ProjectRepository` which would provide persisted `Projects` with all the included `ProjectVersion` and `ProjectEnvironment` aggregates (and consequently can only be accessed through their respective `Project`). ## **Questions**   1. Should there be a `VersionRepository` and a `EnvironmentRepository`? A `GetVersionById()` method on the `ProductRepository` sounds wrong. But then wouldn't supplying multiple repositories threaten the aggregate boundary?   2. Should there be a 'ProjectService' which would handle and validate the aggregates using the three repositories? In order to safeguard against invalid data, client code would only be able to reference the 'ProjectService'.