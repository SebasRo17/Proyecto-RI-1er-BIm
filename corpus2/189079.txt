I am developing an application which will need to store _inline_ , _intext_ metadata. What I mean by that is the following: let's say we have a long text, and we want to store some metadata connected with a specific word, or sentence of the text. What would be the best way to store this information? My **first thought** was to include in the text some kind of **`Markdown` syntax** that would then be parsed on retrieving. Something looking like this:               Lorem ipsum dolor sit amet, consectetuer adipiscing elit,     sed diam __nonummy nibh__[@note this sounds really funny latin]     euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.      This would introduce two problems I can think of:   1. A relatively small one, is that if said syntax happen to be fortuitously on the said text, it can mess with the parsing.   2. The most important one is that this doesn't maintain this metadata **separate** from the text itself. I would like to have a discrete data structure to hold this data, such a different DB Table in which these metadatas are stored, so that I could use them in discrete ways: querying, statistics, sorting, and so on. * * * **EDIT:** Since the answerer deleted his answer, I think it might be good to add his suggestion here, since it was a _workable_ suggestion that expanded on this first concept. The poster suggested to use a similar syntax, but to link the metadata to the `PRIMARY KEY` of the `metadata` database table. Something that would look like this:               Lorem ipsum dolor sit amet, consectetuer adipiscing elit,     sed diam __nonummy nibh__[15432]     euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.      Where `15432` would be the `ID` of a table row containing the necessary, queriable information, as per example below. * * * My **second thought** was to store information of this kind in a DB Table looking like this:               TABLE: metadata          ID    TEXT_ID    TYPE    OFFSET_START    OFFSET_END    CONTENT     1     lipsum     note    68              79            this sounds really funny latin      In this way the metadata would have a unique id, a `text_id` as a foreign key connected to table storing the texts and it would connect the data with the text itself by using a simple character **offset range**. This would do the trick of keeping the _data_ separated from the _metadata_ , but a problem that I can immediately see with this approach is that the text would be fundamentally _not editable_. Or, if I wanted to implement the editing of the text after the assignation of metadata, I would basically have to calculate characters additions, or removal compared to the previous version, and check whether **each** of this modifications adds or remove characters before or after **each** of the associated metadata. Which, to me, sounds like a really unelegant approach. Do you have any pointers or suggestions for how I could approach the problem? * * * ### Edit 2: some XML problems Adding another case which would make quite necessary for this separation of data and metadata to happen.   * Let's say I want to make it possible for different users to have **different metadata sets of the same text** , with or without the possibility of each user actually displaying the other user metadata. Any solution of the _markdown_ kind (or HTML, or XML) would be difficult to implement at this point. The only solution in this case that I could think about would be to have yet another DB Table which would contain the single user version of the original text, connecting to the original text table by the use of a `FOREIGN KEY`. Not sure if this is very elegant either.   * **XML has a hierarchical data model:** any element which happens to be _within_ the borders of another element is considered as its _child_ , which is most often not the case in the data model I'm looking for; in XML any _children_ element must be closed before the _parent_ tag can be closed, allowing for no overlapping of elements. Example: > `<note content="the beginning of the famous placeholder">` _Lorem ipsum > dolor sit_ `<comment content="I like the sound of amet/elit">` _amet_ > `</note>`, _consectetuer adipiscing elit_ `</comment>` _,_ `<note > content="adversative?">` _sed diam_ **`<note content="funny latin">`** > _nonummy_ `</note>` _nibh_ **`</note>`** _euismod tincidunt ut laoreet > dolore magna aliquam erat volutpat._ Here we have two different problems:   1. **Different elements overlapping:** The first comment starts within the first note, but ends after the end of the first note, i.e. it's not its child.   2. **Same elements overlapping:** The last note and the boldfaced note overlap; however, since they are the same kind of element, the parser would close the lastly opened element at the first closure, and the first opened element at the last closure, which, in this circumstance, is not what is intended.