I'm re-architecting an iOS mobile app that consumes an API with somewhat haphazard and oftentimes slow performance. The reason for the slowness is because the API is actually a layer on top of a variety of other platform- level services, some of which run slowly. You then get into the weakest link type of situation where the time it takes for the API to respond is bound by the slowest lower-level service response. When consuming the API I'm getting dealing with an object, let's call it `Foo`, that I display in a table, and also on a detail screen as necessary. A trade-off made by the API designer/implementer was to provide a call to get a list of `Foo` with some specific properties omitted (getting these properties for more than 1 or 2 objects at a time is very slow) and a "detailed view" call to provide a single object with all the properties filled in. The initial model schema had two model objects `Foo` and `FooDetails`. Feeling that this exposes unnecessary implementation details, I've merged both `Foo` and `FooDetails` into `Foo`, but a way to easily represent whether `Foo` is complete or not is still needed. (Meaning does `Foo` have extra properties present or not.) The best I could come up with was an enum:               typedef enum : NSUInteger {              ELYFooAbridgedState,         ELYFooCompletedState          } ELYFooCompletenessState;      I did not want to go with a `BOOL` due to the possibility of multiple "in between" states in the future as some lower level services are tuned. Can anyone provide an alternative naming or representation for this situation? Are there drawbacks w.r.t. to future proofing when taking this approach? This may the only time it's possible to do a ground up refactor of the app's model schema entirely, and I'd like it to be as resilient as possible.