I'm using SignalR to implement a client/server system, but I guess this question could apply to other tiered/client-server/RPC systems. If you aren't familiar with SignalR, you basically create a server-side class (called a "hub") that contains methods you want to expose to clients. On the client- side, SignalR exposes a "hub proxy" class via which you can invoke the server- side hub methods. Let's say I want to remotely control cars from my client application. My first thought was to create an abstract `CarBase` base class with methods such as Start(), Stop(), Steer(), etc. On the client-side I would implement a concrete `Car` class whose methods would invoke (via the SignalR hub proxy) the relevant methods on the server hub. Similarly, on the server-side I would implement a concrete `Car` class, but this time its methods would carry out the relevant actions on the "physical" car. Let's say the client wants to start a car:-               var car = new Car();     car.Id = 123;     car.Start();      The Car's `Start` method would basically invoke the relevant server method via the hub proxy, e.g.:-               public override void Start()     {         _hubProxy.Invoke("StartCar", this);     }      _Here is my first question_ \- is it acceptable for the Car class to have a dependency on the hub proxy, and pass itself to the remote method like this? I've read that functionality such as persistence is a separate concern and should therefore live in a separate class, and I'm in two minds about whether that guideline applies to what I'm doing here. If so, it would result in client code such as `_hubProxy.StartCar(car);` rather than the more OO- friendly and intuitive "car.Start();". Moving on, on the server-side, the "hub" class's StartCar() method might look something like this:-               public void StartCar(CarBase clientCar)     {         // Instantiate a server-side Car         // (this implementation interacts with the "physical" car).         var serverCar = new Car();              // Map properties from received client car         serverCar.Id = clientCar.Id;         .. etc..              serverCar.Start();     }      Is this an acceptable approach, i.e. having the client-side pass in its Car object? Or should I be passing around something else, e.g. just the car's ID and other pertient properties? I guess I can't avoid instantiating the server- side Car (and mapping its properties) - after all, this is where the functionality to interact with the physical car lives. I've gone round in circles trying to think of a better solution, and have reached the point where I can't see the wood for the trees.