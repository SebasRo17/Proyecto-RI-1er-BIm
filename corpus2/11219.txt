I have got a list:               lis:={     {{1, 2, 3, 4}},     {{1, 2, 3}, {4}},     {{1, 2, 4}, {3}},     {{1, 2}, {3, 4}},     {{1, 2}, {3}, {4}},     {{1, 3, 4}, {2}},     {{1, 3}, {2}, {4}},     {{1, 4}, {2, 3}},     {{1}, {2, 3, 4}},     {{1}, {2, 3}, {4}},     {{1, 4}, {2}, {3}},     {{1}, {2, 4}, {3}},     {{1}, {2}, {3, 4}},     {{1}, {2}, {3}, {4}}     };      and I would like to pick out those lists which satisfy the following condition:               list == Mod[list+2,4,1]      but, they should be "equal" as a set of lists, not in a "element to element" way. For example, `{{1,2},{3,4}}` is a list satisfied the condition, since `Mod[{{1,2},{3,4}}+2,4,1]` is `{{3, 4}, {1, 2}}`, which is not equal to `{{1,2},{3,4}}` since the "position" is not right, but we should regard it as equal in the sense of set, since they are both the set of `{1,2}` and `{3,4}`. An example which not satisfied our condition is that `{{1,2,3},4}`, since `Mod[{{1, 2, 3}, 4} + 2, 4, 1]` is `{{3, 4, 1}, 2}`, as a set they are not equal, one is the union of `{1,2,3}` and `{4}`, but the results is the union of `{1,3,4}` and `{2}`. Can I use a pattern to sort out the one satisfied my condition in the list? I would like to make it work with any list.