I have been working with ordering of oscillators for example $[a,a^\dagger]=1$ and I have a fairly stable code. I have needed to use inverse oscillators for example expressions like $a^m (a^\dagger)^{-n}a^k$ but they are not hard to order because $[a,f(a^\dagger)]=f'(a^\dagger)$. However now I have expressions like $a^{-m}(a^\dagger)^{-n}a^{-k}$. If I attempt to normal order them, the solution is an infinite series (Rosenbaum, D.M.: J. Math. Phys. 10, 1127 (1969)) but if I choose a particular type of ordering, I get a finite series: $$ [a^{-m},(a^\dagger)^{-n}] = \sum_{k=1}^m (-1)^{k-1} k! \binom{m}{k} \frac{\Gamma(n+k)}{\Gamma(n)\Gamma(k+1)} a^{-1} a^{-(m-k)} (a^\dagger)^{-(n+k)} a^{-1} $$ which holds for all positive integer $m$ and $n$. Now if I plug this expression into Mathematica I get an obvious infinite loop because it will keep trying to normal order it i.e. all $a^\dagger$'s to the left and all $a$'s to the right. Is there a way I can tell Mathematica to order it in this particular form for negative integer powers of $a$ and $a^\dagger$ so I get a finite sum? Edit1: The function and the code is too long to paste so here is the pastebin link for the full code. Edit2: Since the code is too long, I will try to explain the gist of the problem as short as I can. I have written a function which when it sees a term like $aa^\dagger$ will change it to $1+a^\dagger a$ because of the commutation relations. This I achieve by something as follows:               func(left___,a,a^\dagger,right___):> 1+ func(left,a^\dagger,a,right)      Now similar to this, I tell the function to do this:               func[left___, InveP[m_, p], InveX[n_, x], right___] :> func[left, InveX[n, x], InveP[m,p],right] - func[left, Sum[(-1)^(k - 1) k! Binomial[m, k] (Gamma[n + k]/(Gamma[n] Gamma[k + 1])) func[InveX[1 + m - k, x], InveP[n + k, p], InveX[1, x]], {k, 1, m}],right]      where `InveX[n,x]` is the operator that represents $(a^\dagger)^{-n}$ and `InveP[n,p]` is the operator that represents $(a)^{-n}$. Now when I do `func[InveP[1,p],InveX[1,x]]` it should give me `InveX[1,x] InveP[1,p] + InveP[1,p]InveX[2,x],InveP[1,p]` according to the commutation relations. But the problem is that now the function will try to order the second term again since I am using `FixedPoint` in the definition of function to make sure everything is properly ordered. And this is why I get infinite loops.