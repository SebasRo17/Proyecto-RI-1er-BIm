MSDN says that to properly clean up an object which contains managed and un- managed resources, you need to implement the 'Dispose Pattern'. Given that the class implements the IDisposable interface, and overrides the Object.Finalize() method (has a destructor), **is there any reason why the compiler shouldn't automatically implement the pattern for you?** For instance, compiling:               public class Example : IDisposable     {         public void Dispose() {             //Disposing managed objects implementation         }              ~Example() {             //Disposing unmanaged objects implementation         }     }      As if it were typed as follows:               public class Example : IDisposable     {         private bool previouslyDisposed = false;              private void CleanResources(bool safeToCleanManagedResources)         {             if (!this.previouslyDisposed)             {                 _finalize();                 if (safeToCleanManagedResources) {                     _dispose();                 }                 this.previouslyDisposed = true;             }         }              public void Dispose() {             CleanResources(true);             GC.SuppressFinalize(this);         }              ~Example() {             CleanResources(false);         }              private void _dispose() {             //The contents of the Dispose() method are moved here.         }              private void _finalize() {             //The contents of the ~Example() method are moved here.         }     }      From what I understand, this should **always be safe and valid**. I can not think of any scenarios where these rules would need to be broken. I know this isn't the most pressing feature the C# team is working on, but asides from that: **Are there any scenarios where an object containing managed and un-managed resources wouldn't want to follow the 'Dispose Pattern'?** I'm talking about the compiler generating a method which functions like `CleanResources()`, and moves the `Dispose()` and `~Example()` methods to anonymous backing methods (similar to how auto-properties generate private backing fields). This would mean that any calls to `Dispose()` or `~Example()` would automatically implement the 'Dispose Pattern'.