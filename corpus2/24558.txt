This is just a wondering I had while reading about interpreted and compiled languages. **Ruby** is no doubt an interpreted language, since source code is compiled by an interpreter at the point of execution.   On the contrary **C** is a compiled language, as one have to compile the source code first according to the machine and then execute. This results is much faster execution. Now coming to **Python** :   * A python code ( **somefile.py** ) when imported creates a file ( **somefile.pyc** ) in the same directory. Let us say the import is done in a python shell or django module. After the import I change the code a bit and execute the imported functions again to find that it is still running the old code. This suggests that *.pyc files are compiled python files similar to executable created after compilation of a C file, though I can't execute *.pyc file directly.   * When the python file (somefile.py) is executed directly ( ./somefile.py or python somefile.py ) no .pyc file is created and the code is executed as is indicating interpreted behavior.  These suggest that a python code is compiled every time it is imported in a new process to crate a .pyc while it is interpreted when directly executed. So which type of language should I consider it as? Interpreted or Compiled? And how does its efficiency compare to interpreted and compiled languages? According to wiki's Interpreted Languages page it is listed as a language compiled to Virtual Machine Code, what is meant by that? ## Update Looking at the answers it seems that there cannot be a perfect answer to my questions. Languages are not **only interpreted** or **only compiled** , but there is a spectrum of possibilities between interpreting and compiling. Also, its not the languages which are interpreted or compiled, but rather their implementations either interpret or compile code.   I also found out about Just in time compilation From the answers by aufather, mipadi, Lenny222, ykombinator, comments and wiki I found out that in python's major implementations it is compiled to bytecode, which is a highly compressed and optimized representation and is machine code for a virtual machine, which is implemented not in hardware, but in the bytecode interpreter. As far as execution speed is concerned the various benchmarks cannot be perfect and depend on context and the task which is being performed. Please let me know if I am wrong in my interpretations.