I can't think of a better place among SO siblings to pose such a question. Originally I wanted to ask "Is python a pure OO language?" but considering troubles and some sort of discomfort people experience while trying to define the term I decided to start with obtaining a clear definition for the term itself. It would be rather fair to start with correspondence by Dr. Alan Kay, who has coined the term (note the inspiration in biological analogy to cells or other living objects). There are following ways to approach the task:   1. Give a comparative analysis by listing programming languages that can exhibit (or fail to do so) certain properties unique and sufficient to define the term (although Smalltalk, Scala, ~~Java~~ , and so on - are possible examples but IMO this way seems neither really complete nor fruitful)   2. Give a formal definition (or close to it, e.g. in more academic or mathematical style).   3. Give a philosophical definition that would totally rely on semantical context of concrete language or a priori programming experience (there must be some chance of successful explanation by the community).  My current version: _"If a certain programming (formal) language that can (grammatically) differentiate between operations and operands as well as infer about the type of each operand whether this type is an object (in sense of OOP) or not then we call such a language an OO-language as long as there is at least one type in this language which is an object. Finally, if all types of the language are also objects we define such language to be pure (strong) OO- language."_ Would appreciate any possible improvement of it. As you can see I just made the definition dependent on the term "object" (often fully referenced as class of objects). [EDIT] In addition, I use (luckily well understood) notion of a _type_ as in typed languages. Data type programming or type oriented programing is not only a syntactical interpretation (of the program text, i.e. how to treat certain values of literals and data variables - something that evolves into type safety) but can be attributed to language grammar and studied in formal way (using mathematical logic) as so called type systems. Notice that requiring particular type system to have a so called _universal type_ is one of the ways defining purity of OO language (there are ways to expand this semantically). _NB_ _**how to answer_** :   * it helps if you specify a book or a reference that supports/explains your understanding of terminology and concepts (usually a good definition covers or references all depended concepts except elementary).   * if possible indicate an indented category of your answer/definition if it is not clear otherwise (see above: 1 - by language example, 2 - mathematical logic, 3 - technical description and programming philosophy)   * _classification is important_ (and also because term pure-OO is included into term OO) while answering try to unmix elements of OO paradigm from other well known methodologies (and by no means confuse/overlap them, e.g. typically elements of modular programming can be covered/embodied with OO programming): try to distinguish OOP from (including or being a part of) Functional programming, Logical programming (especially strongly specialized ), Abstarct Data Types (ADT), Modular, Metaprogramming (generics and LISP's macroexpansion-time), Contracts (e.g. Eiffel), Aspect-oriented (AO), (difference between declarative and functional classification as well as _historical_ definitions of Dijkstra's structured are clear) _**on difficulty of giving a formal definition_** : surprisingly enough it is very easy to give a mathematical description of OOP in form of a certain logical (formal) system (most likely type based) and defining one concept after another. One can even try to do something more practical by applying that formalism to type safety checking or new language design aspects than merely abstract entertainment or exercise (also lookup formulation of OOP in Intuitionistic Type Theory, Dependent types, independently, in FOL formalisms as lambda calculus and just by using category theory). A main point here is that _unsurprisingly_ such formulations IMO are strongly biased (flawed) by most likely initially incomplete understanding of OOP (in computer engineering) and end up being almost inaccessible afterwards (thus hardly contributing backwards to programming world - maybe except certain percentage finds applications back from formal world by being integrated into popular languages). So yes, it is difficult to give exactly a "good" definition, not just definition. But I am positive of asking this here because of your experience and direct involvement, guys.