It is possible to define my own `With` construct where each _local constant_ can depend on the previous defined _local constants_? I wish to replace something like this               With[{m=10},       With[{h=1/m},         Table[{i h}, {i, 0, m}]       ]     ]      with something like this               WithMany[{m=10, h=1/m},         Table[{i h}, {i, 0, m}]     ]      The very basic idea is to use `Fold`:               Attributes[WithMany] := {HoldAll};     WithMany[{vars___}, body_] := Fold[With[{#2}, #1] &, body, {vars}]      but we need to properly evaluate the argumens in a non-standard way, possibly using `Hold` and related constructs. I'm not so fluent with this. An improvement would be to use the minimum number of With constructs depending on the dependencies between variables. Any help will be appreciated. **EDIT** As several people pointed out the original question has already been answered. This solve my immediate needs but I'm still interested to other implementation. @Leonid Shifrin think the referred answer already use the best approach, the simplest, the most elegant, the most efficient and so, but, even if true, I consider an interesting programming exercise to try different approach, like the one in my original question, using functional programming and `Fold` The sketch of a possible implementation is the following:               Attributes[WithMany] := {HoldAll};     WithMany[vars : {__}, body_] :=      Block[{With},       Attributes[With] = {HoldAll};       ReleaseHold@Fold[         With[{#2}, #1] &,         Hold[body],         Reverse@Thread@Hold@vars         ]       ]      I don't understand if there is some limit or issue with this implementation, or if it is fully equivalent to the one in the referred answer and to nested `With` costruct (after adding Syntax coloring and handling `SetDelayed`)? At a first sight I like more my approach (if it works properly of course) and I think is cleaner. It also appears slightly faster, according to some very basic tests. But I recognize that some people might prefer a different approach.