I have been bitten hard by `SaveDefinitions -> True`. I'll describe in detail what happened below. My questions are: Is this a bug? What is the most convenient workaround? * * * Consider a definition issued like this:               Block[{x, y}, f[x_, y_] = x + y;]      Why didn't I use `:=` instead? Because the expression that stands in place of `x+y` in my actual problem is computed (symbolically) within the `Block` so (numerical) evaluations of `f` are going to be sufficiently fast. We can check the definition:               ?f      > f[x_,y_]=x+y Now let's give `x` a value ...               x = 1      ... and test that `f` still works as expected:               f[0, 0]      > 0 (* as expected *) Let's use `f` in `Manipulate` with `SaveDefinitions -> True` ...               Manipulate[f[a, b], {a, -1, 1}, {b, -1, 1}, SaveDefinitions -> True]      ... and check that it works again:               f[0, 0]      > 1 (* oops!! *)               ?f          f[x_, y_] = 1 + y      The definition of `f` has been rewritten _and changed to something else_ as a side effect of `SaveDefinitions`. What is the morale? Probably that `SaveDefinitions` and `Set` are not safe to use together. Note that what happened here is different form the situation when the definition of `f` is overwritten just because a notebook containing a manipulate with SaveDefinitions has been opened. * * * My current workaround is to use the following hack to "neutralize" the `HoldAll` attribute of `SetDelayed`:               Block[{x, y},      (f[x_, y_] := #) &[x + y];]      Alternative suggestions are welcome.