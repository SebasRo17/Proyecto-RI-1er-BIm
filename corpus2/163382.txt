Consider the following exam / interview question: * * * Implement the strcpy() function in C: `void strcpy(char *destination, char *source);` _The`strcpy` function copies the C string pointed by `source` into the array pointed by `destination`, including the terminating null character. Assume that the size of the array pointed by `destination` is long enough to contain the same C string as `source`, and does not overlap in memory with `source`._ * * * Say you were the interviewer \ examiner, how would you grade the following answers to this question? 1)               void strcpy(char *destination, char *source)     {       while (*source != '\0')         {           *destination = *source;            source++;            destination++;         }         *destination = *source;     }      2)               void strcpy(char *destination, char *source)         {            while (*(destination++) = *(source++)) ;         }      The first implementation is straightforward - it is readable and programmer- friendly. The second implementation is shorter (one line of code) but less programmer- friendly; it's not so easy to understand the way this code is working, and if you're not familiar with the priorities in this code then it's a problem. I'm wondering if the first answer would show more complexity and more advanced thinking, in the interviewer's \ examiner's eyes, even though both algorithms behave the same, and although code readability is considered to be more important than code compactness. It seems to me that since making an algorithm this compact is more difficult to implement, it will show a higher level of thinking as an answer in an exam. However, it is also possible that an interviewer \ examiner would consider the second answer not good because it's not readable. I would also like to mention that this is not specific to this example, but general for code readability vs. compactness when implementing an algorithm, specifically in exams \ interviews.