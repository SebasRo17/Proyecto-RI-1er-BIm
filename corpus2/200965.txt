The question motivations was depicted in the section below. There are many ways to make text italic, so, perhaps, there are more than one good " ** _swap italics algorithm_**". The problem reveals some aditional dificulties in a XHTML code, and using the `<i>` tag, that **must to be balanced**. Example:                <!-- original text: -->      <p id="p1"><i>Several more</i> Homo sapiens <i>fossils were discovered</i>.</p>      <!-- same text, swapping italics: -->      <p id="p2">Several more <i>Homo sapiens</i> fossils were discovered.</p>      So, looks like this,   1. _Several more_ Homo sapiens _fossils were discovered_.   2. Several more _Homo sapiens_ fossils were discovered. * * * # Algoritms introduction and discussion For " **layout solution** ", the simplest algorithm is checking the `font- style` CSS-property of all text blocks, and invert them with jQuery:               $('#myFragment *').each(function(){        if ($(this).css('font-style')=='italic')            $(this).css('font-style','normal')         else            $(this).css('font-style','italic')             });       But this algorithm not survive to a little more complex test,                <p id="p3"><b><i>F</i>RAGMENT <big><i>with italics</i> and </big> withOUT.</b></p>      The second simplest algorithm is for a **concrete solution** , and was used in the "Examples" section. Have two steps:   1. enclose the XHTML fragment into italics;   2. invert open/close italic tags (ex. `</i>` to `<i>`). That is, writing with Javascript,               var s = '... a fragment of XHTML content ...';     s = '<i>'+        s.replace(/<(\/?)i>/mg,                function (m,p1){                   return p1? '<i>': '</i>';               }        ) +        '</i>';        But also not survive to the second test, losting balance of tags... The "corrected" algorithm runs (!), but is not portable, neither fast or elegant. It is demonstred here, and at the example section below. # The point! So the question is, **there are a simple, good and generic (usable in any browser and portable to another languages) algorithm?** You know another "swap italics algorithm"? PS: "generic" in the sense that I even translate your algorithm to XSLT. The algorithm **must produce directallybalanced XHTML code** (without a intermediary blackbox like Tidy). * * * ## Motivations I need to port the "swap italics algorithm" to text editors, server parsers, etc. In all cases I can "normalize input" (and output) by standard XHTML and `<i>` tag. I am parsing XHTML text of prose books and scientific articles, exported from different origins and styles... The most texts are exported as "normal text", but a lot of titles (ex. article title, chapter title), and, sometimes, a full chapter or a full text-box (ex. article abstract) are stylized with italics. All these "stylized with italics" must be inverted. Typical cases:   * Transform the original "all chapter italics" into "all chapter normal text": see this case, where in a roughly 300-page book, 8 of the 25 chapters need to be inverted.   * Italicized quotation marks, abstracts, etc. See this example. Need change back to normal, but without lost the emphasis words.   * Writing binomial names of species, in Scientific texts, are usually typeset in italics (or inverted, in a font different from that used for "normal text"). Hundreds of italicized titles (of articles and of article-sections) of XHTML-exported articles must be inverted at my work place. PS: see the example of the beginning of the question ("Several more _Homo sapiens_ ..."). I need also **translate the generic algorithm (of your answer!) to a XSLT library** , where no "tag balancing correction" not exists. ## Examples Implementing in Javascript and PHP a **non-generic** "Swap italics algorithm". A generic one need a general "XML interleaving algorithm"... Here I use browser's (DOM) and Tidy corrections, as an alternative to "interleaving". ### Javascript It runs with complex inputs (!). Illustrating, by an jQuery implementation:                var s = $('#sample1').html(); // get original html text fragment           // INVERSION ALGORITHM: add and remove italics.      s = "<i>"+          s.replace(/<(\/?)i>/mg,                     function (m,p1){                        return p1? '<i>': '</i>';                    }          ) +          "</i>";  // a not-well-formed-XHTML, but it is ok...      $('#inverted').html(s); // ...the DOM do all rigth!      // minor corrections, for clean empties:      s = $('#inverted').html();      s = s.replace(/<([a-z]+)>(\s*)<\/\1>/mg,'$2'); // clean      s = s.replace(/<([a-z]+)>(\s*)<\/\1>/mg,'$2'); // clean remain      $('#inverted').html(s);        // END ALGORITHM           alert(s);      ### PHP, with Tidy The same of Javascript, "translated" to PHP -- the natural translation is using `DOMDocument()` class and `loadHTML`/`saveXML` methodos, but what have the same behaviour than browser's correspondents is the `tidy` class. Shows the same results (!)                $sample1='<b><i>O</i>RIGINAL <big><i>with italics</i> and </big> withOUT</b>';      $inverted = '... inverted will be here ...';      echo $sample1;      // Tidy correction      $s = $sample1; // get original html text fragment       // INVERSION ALGORITHM: add and remove italics.       $s = "<i>".           preg_replace_callback('/<(\/?)i>/s', function ($m){            return $m[1]? '<i>': '</i>';}, $s) .           "</i>";  // a not-well-formed-XHTML, but it is ok...       $config = array('show-body-only'=>true,'output-xhtml'=>true);       $tidy = new tidy;       $tidy->parseString($s, $config, 'utf8');       $s = $tidy;  // ... because Tidy corrects!            // minor corrections, for clean empties:       $s = preg_replace('/<([a-z]+)>(\s*)<\/\1>/s', '$2', $s); // clean       $s = preg_replace('/<([a-z]+)>(\s*)<\/\1>/s', '$2', $s); // clean remain       // END ALGORITHM       echo "\n\n$s";