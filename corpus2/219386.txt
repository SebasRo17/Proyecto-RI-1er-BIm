One of the greatest piece of documentation I ever read is _the TeXbook_ by Donald Knuth—the manual of the _TeX_ typesetting system, and I used it in my first analysis. As far as I can tell, the type of information conveyed by documentation falls in three categories: _recipe,_ _reference_ and _expert knowledge_ that I describe hereafter. Which categories am I missing? ## Recipe A recipe answers a question like “how do I solve that problem with this software?” and binds the _problem world_ with _software features._ Chapters 3, 7 and 8 in the _TeXbook_ answer questions like “How do I run TeX?” or “How do I type text?” and provide the user with recipes. Other software packages often contain installation or backup procedures that fall in this category. ## Reference A _reference_ documents all the needed details on some piece of software. It is useful for the user knowing that “this feature is useful to solve that problem” and wanting to know if it can parametrise “this feature” to solve a close problem. It is also useful for troubleshooting the software when it gives unexpected results. Chapter 14 “How TeX Breaks Paragraphs into Lines” in the _TeXbook_ is an example of a reference text. UNIX manual pages almost always belong to this category. ## Expert knowledge Expert knowledge pertaining to the problem solved by the software also belong to the software documentation. Reasons for this are at least:   1. Users are not experts in the area where the software is useful.   2. Experts use varying terminology and methodologies to describe or solve problems. For 1. mathematicians reading the _TeXbook_ also learn the _basics_ of design and layout: they get aware that there is a structured knowledge in this area and learn the names of the basic concepts involved, so that they can phrase out problems and get help. For 2. it is useful to “fix the notation” in the software documentation and this is best done by providing some high-level or background information. Hence expert knowledge contained in the user documentation binds the conceptual organisation of the problem as it is known to the software designers to the conceptual organisation of the problem as it is known to the software users.