looking through the docs of posix' `pthread_mutex_t` and window's `mutex` and `CRITICAL_SECTION` I noticed there is no easy way of checking whether the current thread holds a specific mutex posix' `pthread_mutex_t` can be tested when it's not reentrant but that is only a artifact of a non-reentrant mutex ofcourse checking whether another thread holds a mutex is trivial with trylock java does allow checking whether the current (and only current) thread holds an object monitor with `Thread.holdsLock(Object)` which is advised to only be used for debugging likewise the interface of `java.util.concurrent.locks.Lock` in also doesn't provide any checking method (the implementation `ReentrantLock` however does with `ReentrantLock.isHeldByCurrentThread()`) * * * I can imagine that this can be quite easily implemented alongside any other lock (and is even required when implementing a reentrant mutex) all it would require is a unique handle for each thread (already available in threading libraries or could even be the TLS pointer whichever is smaller) and at most 2 extra fields (one for the handle and one for the holdcount)   1. when locking: after the lock is acquired increment the holdcount and set the handle to the current thread handle   2. when unlocking: before unlocking decrement the holdcount and set the handle to nil only when the holdcount is now 0   3. when testing: get the handle and compare it to the current thread's handle   this may be possible without any membarriers as long as a simultaneous write doesn't mangle the bits of the read in a such way that a handle is read that wasn't being written (i.e. the reading thread's handle) the only race conditions possible are in #3 (the rest happens when the lock is held) and may be irrelevant depending on the memory model given the size of the read value (one word) ( **edit** : if a atomic read/write scheme is used this is even solved entirely) the holdcount is not even be necessary when the mutex is not reentrant and you're not making it reentrant * * * **EDIT2** : I want to clarify that the `hasLock` would only be used for debugging purposes (asserts) for example to ensure that a method that needs a lock held by the caller actually has it as for the race condition being irrelevant:   1. first requirement is that you need a way to write and read concurrently in a way that you would only get values that were actually written   2. second the test `handle == currentHandle` would treat both `nil` and the handle of another thread the same way   3. the only way that currentHandle would be equal to handle is when the current thread has written it during locking