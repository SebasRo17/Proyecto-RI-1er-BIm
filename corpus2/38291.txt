I guess I have to try harder and focus more but timed evaluation always frustrates me. I will show the issue on simple example of delayed trigger.                ClearAll@time; time = 0;      CreateScheduledTask[time++;, {1, 5}]      StartScheduledTask@ScheduledTasks[];           DynamicWrapper[Dynamic@time,                      If[time === 5, RemoveScheduledTask[ScheduledTasks[]]; Print["end"]]]      > >     1... 2... 3... 4... 5 "end" (*so it works OK*) >   * * * In general one may want to scope such procedure:               DynamicModule[{x},     ClearAll@x;          Column[{Button["start", x = 0;                              RemoveScheduledTask[ScheduledTasks[]];                              StartScheduledTask@CreateScheduledTask[x++;, {1, 5}]],              DynamicWrapper[Dynamic@x, If[x === 5, Print@1]]                  }] ]      > output before clicking: >   >   >     FE`x$$number (*as expected*) >   > > output after clicking: >   >   >     0 (*and it does not change*) >   We can see that the only procedure that was enabled was `x = 0;`. I was suspecting problems because `ScheduledTasks` are not related to `FrontEnd` while `DynamicModule` is. What is interesting is that changing `DynamicModule` to `Module` fixes the problem. **The question are:**   * What am I missing in case of `DynamicModule`? I've seen Module variable scoping in ScheduledTasks but I couldn't use it for my purpose. (*I've added `ClearAll` but it does not seem to make any difference.   * Schould I use `Module` even if this is only a minimal example of the code that will be implemented in larger cdf? Moreover, John Fultz reminded couple of times (e.g. here) that such constructs are incorrect.