I have developed a habit of using safe C++ constructs where possible, but there is one place where I'm always not sure if it's better to use references or resort to good ol' pointers. Example code:               int FillFancyPointer(char *&ptr)     {         ptr = NULL;              char *tmp_ptr = static_cast<char*>(calloc(...));         if(!ptr)             return -1;             ptr = tmp_ptr;        return 0;     }      Later in code:               char *ptr = nullptr;     if(FillFancyPointer(ptr)>=0 && ptr)        Nice();      The problem with this, IMHO, is that the ptr appears to be read only variable when looking at the code, while in reality it is modified. The COM approach `ISmthn *ptr;`, `CoCreate(..., &ptr)` seems more pronounced. But it's also more error prone, as there is this `**` stuff everywhere. Come to think of it, output variables like `std::string` will also be masked with such approach. `int Foo(const string &in, string &inout)` Do you find references confusing in such places?