# Background Developing a system for creating eBooks. The data is highly normalized. The eBook designs are packaged as "themes." The themes can be configured with options for: fonts, colours, some layout, and thematic elements (such as squares for bullet lists could become circles, hexagons, or arrows). The options are tightly coupled to the theme. For example, one theme might only allow the user to select certain fonts, while another theme might not have any thematic elements at all, while all themes might provide options for changing the page number layout, theme colours, and content for the header/footer. Creating eBooks is one example of the general class of problem: > The output depends on configurable options; the available options depend on > a particular constraint set. # Problem When a new constraint set (e.g., eBook theme) is created by a developer, the configurable options must be exposed as user interface elements. The user interface elements could be mapped to the options using a descriptive language, or XML. For example:               <group id=”page-number”>       <group id=”text-attribute”>         <string name=”UserInputPage” default=”# / ##” id=”ui-page” />         <colour name=”UserColourPrimary” id=”ui-colour-primary” />         <select name=”UserSelectBullet” id=”ui-bullet”>           <option id=”ui-select-square” />           <option id=”ui-select-circle” />         </select>         <integer name="UserRandomSeed" min="1" max="50" id="ui-random-seed" />       </group>     </group>     <text language="en">       <!-- Tab name -->       <ref id=”page-number”>Page Number</text>       <!-- Group name -->       <ref id=”text-attribute”>Text Attributes</text>       <!-- Display name for select options -->       <ref id=”ui-select-square”>Square</text>       <ref id=”ui-select-circle”>Circle</text>     </text>      The underlying theme implementation (whether PHP, Lua, Java, or C++) would define, expose, and use variables such as:               UserInputPage     UserColourPrimary     UserSelectBullet      Using XSLT, it would be reasonably trivial to convert the above map into sensible UI widgets that correspond to the variable definition in the XML. By creating this map, developers need not explicitly create the user interface, nor worry about either its layout or menu structure. The developer creates a map of the software's input variables and the computer automatically generates the UI. The UI, in this case will be XHTML, but could be XUL or any other representation. # Comparison Frameworks such as JavaServer Faces are similar to this idea; JSF and ADF issues include:   * Too complex with too much overhead.   * Often tied to specific implementation languages.   * The inputs are bound too closely to their final representation. For example:               <h:inputText value="#{helloBean.name}" ... />     <af:selectOneRadio value="#{bindings.x.hints.inputValue} layout="vertical" />      Vertical "selectOneRadio" radio button inputs should not be hard-coded throughout the application. Instead, the final UI representation should be based on intelligent defaults. In the XML example from the problem section, the UI should generate two radio buttons because there are two inputs in the `select` item. Three items would generate a drop-down. One item would create a checkbox. Similarly, the `<string>` could generate any of:   * input in HTML;   * JTextField in Java; or   * QLineEdit using QT4. Also similarly, the `<integer>` could generate a slider or a simple input field. Validation would be performed elsewhere. With HTML, the final look and feel of the item would be driven by CSS, just as with JSF. # Related Somewhat related:   * Development Approach: User Interface In or Domain Model Out?   * http://en.wikipedia.org/wiki/User_interface_markup_language # Question What approach would you take to create such a variable map definition that can then generate UI code?