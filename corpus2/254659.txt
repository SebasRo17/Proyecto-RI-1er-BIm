I'm programming an application for an embedded device. We are using an RTOS that supports multi threading. The device is supposed to mimic an older project that was programmed in plain C (without threads). The original project uses a stack and START / END functions at the beginning and end of each function that can be called throughout runtime. Each time START is called a constant number (identifying the function) will be put on the stack - END will remove it from the stack and check if the top is equal to the called function. If it is different something really bad has happened and the device will recover/reset. This feature is great for debugging purposes as it fully displays how functions are called. It would be very lovely to have such a feature in the multi-threaded version. I implemented START and END as a class in C++ using constructor and destructor which makes the handling fairly easy. Running this single-threaded works like a charm. Anything multithreaded will destroy the stack as the scheduler switches context and writing to one stack would not make sense. The most basic solution in my mind would be having one START/END stack for each thread -> Problem each function has to know which threads it runs on. Is there a better solution to this problem?