Historically a HLL is something like C, Fortran or Pascal and a VHLL is something like Ruby or Python. I am familiar with the terms 4GL, 5GL, DSL and LOP, and those who aren't should read Wikipedia for the definitions. I'm looking for UHLLs. My question is: are there any computer languages out there which are another order of magnitude more productive, and is anyone working on them? More productive means less authored code and less programmer time to achieve a result, less bugs and less debugging, closer conceptual link between code and requirements, less effort to modify and maintain. The main domain that interests me is general-purpose business and consumer applications, with a GUI or browser front end, data persistence and connections to other systems such as printing and email. Other people might well focus elsewhere. I recognise that some of those languages might be domain-specific, and that they might be little more than the configuration capability of a large and capable application. Excel spreadsheets fall into this category. I recognise that some of those languages might appear general, but might still be narrow in scope and unsuited to many problems. For example, Matlab might not be a good choice for a program that deals mainly with user interaction and textual data. I know some of the features that might be in a UHLL, by analogy with VHLL. I would expect to find one or more of the following (and feel free to add to the list):   * A drawing of a GUI form IS the program for a GUI form   * A table containing rows, columns and headers IS the program for a table in a database   * Declarative logic says what should be done and when, with no IF statements   * Operations on sets of data, with no FOR loops   * Non-sequential execution eg data driven, pattern matching, tree walking The motivation for the question is that I am increasingly fed up with the sheer hard work of translating relatively simple business requirements into large quantities of code to cater for what the computer wants or needs. The question is really about finding others out there who share my pain and are working on raising the level of languages and getting the computer to do more of the hard work. This was a major focus in the 1970s-80s, but is it still happening? These are some suggested answers to my question, provided here to to summarise or enumerate languages I know about, and which in my view fall short. There are many languages that are HLL or VHLL and contain individual features that belong to a higher level. I've used most of them (often badly). They include   * Lisp, with its macros and ability to self-modify   * Haskell, with data dependency and pattern matching   * SQL, which deals in rows and tables   * Rebol, which seems clever but I don't really get it   * APL (and J), with its multi-dimensional arrays and ultra-compact operators   * C# with LINQ   * AWK/Perl/Python/Ruby with wonderful collections and regexes built in These languages have too many low level features to be UHLL. The programmer still has to write many low level constructs for any useful program. There are RAD/4GL packages. I've used some:   * dBase/Foxpro   * Dataflex/Powerflex (my product)   * Access   * PowerBuilder And lots more I haven't used. Mostly the language is HLL at best but the package contains a framework and privileged connections between language and package so that applications can be built fast. I'm not sure why this approach ran out of steam, but in any case UHLL this is not. There are raw frameworks/libraries. I've used a few:   * Rails   * Java awt and swing   * .NET Windows Forms, WPF and ASP.NET. These are currently the state of the art. They leave the programmer firmly trapped in the mire of the implementation language, dealing with complexity at every turn. This is not UHLL, but a UHLL might conceivably be built on top of one of these. There are design tools, like UML and Rational's toolset, which I don't know well. As far as I can see they help articulate business requirements but can never replace the programming step. I don't want to eliminate programmers, just get more done per unit of time and effort. So having eliminated all contenders I can think, I hope someone else can provide a better candidate. Late Edit: I think I have an answer: Wolfram Language. http://www.wolfram.com/wolfram-language/