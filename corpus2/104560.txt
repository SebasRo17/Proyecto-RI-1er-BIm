In a web application that has a significant ajax component, where is the best place for the client-side concurrency responsibility to lie? We're trying to use MVC on both the server application (LAMP stack) and the client application (ajax, mostly jQuery and unobtrusive js). On the server-side, our model throws an exception if it finds a concurrency conflict that it can't solve on it's own. Essentially, the model tracks a revision number and date/user of creation and update. If the object being saved is out of date (older revision than in the data store), it attempts a merge. If it fails, the controller handles the exception and initiates some kind of resolution workflow. The issue is with the client application; since ajax runs requests asynchronously, the model doesn't necessarily have the latest version of the data, but only the controller would know that--it is responsible for handling the queue/polling. The original idea was to pass all the updates fetched from the server directly to the javascript models for handling the concurrency-- problem being that the lack of exceptions in javascript limits us to making flow-control decisions in the model that way. Is it a bad idea to move the merging/model-conflict-resolution into the javascript controller? Is there a better way to handle this without the controller getting to far into model land? Flow of the page:   1. User loads page(ajax application) with initial models--the models are numerous and have many attributes.   2. Page polls server for updates every 10-15 seconds--this is for auto-save and getting updates from other users.   3. User edits models.   4. Any conflicts that arise after initial entry are resolved when the user clicks the "save" button at the bottom of the page.