**Situation** Earlier this evening I gave an answer to a question on StackOverflow. _The question:_ > Editing of an existing object should be done in repository layer or in > service? > > For example if I have a User that has debt. I want to change his debt. > Should I do it in UserRepository or in service for example BuyingService by > getting an object, editing it and saving it ? _My answer:_ > You should leave the responsibility of mutating an object to that same > object and use the repository to retrieve this object. > > Example situation:               class User {      private int debt; // debt in cents      private string name;           // getters           public void makePayment(int cents){       debt -= cents;      }     }          class UserRepository {      public User GetUserByName(string name){       // Get appropriate user from database      }     }      _A comment I received:_ > Business logic should really be in a service. Not in a model. **What does the internet say?** So, this got me searching since I've never really (consciously) used a service layer. I started reading up on the Service Layer pattern and the Unit Of Work pattern but so far I can't say I'm convinced a service layer has to be used. Take for example this article by Martin Fowler on the anti-pattern of an Anemic Domain Model: > There are objects, many named after the nouns in the domain space, and these > objects are connected with the rich relationships and structure that true > domain models have. The catch comes when you look at the behavior, and you > realize that there is hardly any behavior on these objects, making them > little more than bags of getters and setters. Indeed often these models come > with design rules that say that you are not to put any domain logic in the > the domain objects. Instead there are a set of service objects which capture > all the domain logic. These services live on top of the domain model and use > the domain model for data. > > (...) The logic that should be in a domain object is domain logic - > validations, calculations, business rules - whatever you like to call it. To me, this seemed exactly what the situation was about: I advocated the manipulation of an object's data by introducing methods inside that class that do just that. However I realize that this should be a given either way, and it probably has more to do with how these methods are invoked (using a repository). I also had the feeling that in that article (see below), a Service Layer is more considered as a façade that delegates work to the underlying model, than an actual work-intensive layer. > Application Layer [his name for Service Layer]: Defines the jobs the > software is supposed to do and directs the expressive domain objects to work > out problems. The tasks this layer is responsible for are meaningful to the > business or necessary for interaction with the application layers of other > systems. This layer is kept thin. It does not contain business rules or > knowledge, but only coordinates tasks and delegates work to collaborations > of domain objects in the next layer down. It does not have state reflecting > the business situation, but it can have state that reflects the progress of > a task for the user or the program. Which is reinforced here: > Service interfaces. Services expose a service interface to which all inbound > messages are sent. You can think of a service interface as a façade that > exposes the business logic implemented in the application (typically, logic > in the business layer) to potential consumers. And here: > The service layer should be devoid of any application or business logic and > should focus primarily on a few concerns. It should wrap Business Layer > calls, translate your Domain in a common language that your clients can > understand, and handle the communication medium between server and > requesting client. This is a serious contrast to other resources that talk about the Service Layer: > The service layer should consist of classes with methods that are units of > work with actions that belong in the same transaction. Or the second answer to a question I've already linked: > At some point, your application will want some business logic. Also, you > might want to validate the input to make sure that there isn't something > evil or nonperforming being requested. This logic belongs in your service > layer. **"Solution"?** Following the guidelines in this answer, I came up with the following approach that uses a Service Layer:               class UserController : Controller {      private UserService _userService;           public UserController(UserService userService){       _userService = userService;      }            public ActionResult MakeHimPay(string username, int amount) {       _userService.MakeHimPay(username, amount);       return RedirectToAction("ShowUserOverview");      }           public ActionResult ShowUserOverview() {       return View();      }     }          class UserService {      private IUserRepository _userRepository;           public UserService(IUserRepository userRepository) {       _userRepository = userRepository;      }           public void MakeHimPay(username, amount) {       _userRepository.GetUserByName(username).makePayment(amount);      }     }          class UserRepository {      public User GetUserByName(string name){       // Get appropriate user from database      }     }          class User {      private int debt; // debt in cents      private string name;           // getters           public void makePayment(int cents){       debt -= cents;      }     }      **Conclusion** All together not much has changed here: code from the controller has moved to the service layer (which is a good thing, so there is an upside to this approach). However this doesn't look like it had anything to do with my original answer. I realize design patterns are guidelines, not rules set in stone to be implemented whenever possible. Yet I have not found a definitive explanation of the service layer and how it should be regarded.   * Is it a means to simply extract logic from the controller and put it inside a service instead?    * Is it supposed to form a contract between the controller and the domain?    * Should there be a layer between the domain and the service layer? And, last but not least: following the original comment > Business logic should really be in a service. Not in a model.   * Is this correct?     * How would I introduce my business logic in a service instead of the model?