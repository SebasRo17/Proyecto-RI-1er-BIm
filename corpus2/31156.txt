(This is a far tighter version of a previous question I asked) The problem with Collect is that while `Collect[exp, pattern, Simplify]` will simplify the coefficients, it does nothing to the matched patterns themselves. If one then calls `FullSimplify` on the result of the collection, it frequently undos the collect. This is especially important when collecting and matching with complicated non-integer exponents or exponentials. To solve this, what do you think of the following solution? Is there any way I could lose parts of the expression tree with this transformation?               CollectFullSimplifyImpl[exp_, pat_]:= If[MatchQ[#,pat], FullSimplify@#, #]& //@ Collect[exp, pat, FullSimplify];     CollectFullSimplify[exp_, pat_]:= FixedPoint[CollectFullSimplifyImpl[#, pat]&, exp]      I think I want to do a depth first MapAll so simplify the expressions from the bottom up if they are recursive and ensure that I don't undo the previous collections as I go through (i.e. calling FullSimplify on a higher level node could mean lower nodes no longer match the pattern). Why have a Fixed point? Want to allow the recollection//further simplification if the exponents have themselves simplified and could be combined, but having trouble finding a minimal example. Might be unncessary... *) To see the results, try the following tests:               exp = ((b - a)/a - b/a )x^(((b - a)/a) - (b/a)  )+(1 + a)x + (b - 1)x;     exp2 = ((b - a)/a - b/a )x^(((b - a)/a) - (b/a)  )+ x^x^((b - a)/a - b/a-1/x+x^((b - a)/a - b/a)); (* Test out the recursion *)     Print["Collect, then Collect with simplification, then CollectFullSimplify"]     Collect[exp, x^_]     Collect[exp, x^_, FullSimplify]     CollectFullSimplify[exp, x^_]          Print["Collect, then Collect with simplification, then CollectFullSimplify"]     Collect[exp2, x^_]     Collect[exp2, x^_, FullSimplify]     CollectFullSimplify[exp, x^_]      The following is the output               "Collect, then Collect with simplification, then CollectFullSimplify"          (*     ==> (1 + a) x + (-1 + b) x + (-(b/a) + (-a + b)/a) x^(-(b/         a) + (-a + b)/a)     *)          (* ==> (a + b) x - x^(-(b/a) + (-a + b)/a) *)          (*     ==> -(1/x) + (a + b) x          During evaluation of     *)          "Collect, then Collect with simplification, then CollectFullSimplify"          (*     ==> -x^(-(b/a) + (-a + b)/a) + x^x^(-(b/a) + (-a + b)/a - 1/x +        x^(-(b/a) + (-a + b)/a))     *)          (*     ==> -x^(-(b/a) + (-a + b)/a) + x^x^(-(b/a) + (-a + b)/a - 1/x +        x^(-(b/a) + (-a + b)/a))     *)          (* ==> -(1/x) + (a + b) x *)      One problem I have found is the following: `CollectFullSimplifyImpl[v[l][z_] , z^_]` becomes `v[l][Pattern[(If[MatchQ[#, z^Blank[]], FullSimplify[#], #]& )[z], Blank[]]]` This is ugly since I commonly want to call CollectFullSimplify on rules of the form `{v[l][z_] -> COMPLICATED STUFF`, and this wrecks it.