The usual example of Data Oriented Design is with the Ball structure:               struct Ball     {       float Radius;       float XYZ[3];     };      and then they make some algorithm that iterates a `std::vector<Ball>` vector. Then they give you the same thing, but implemented in Data Oriented Design:               struct Balls     {       std::vector<float> Radiuses;       std::vector<XYZ[3]> XYZs;     };      Which is good and all if you're going to iterate trough all radiuses first, then all positions and so on. However, how do you move the balls in the vector? In the original version, if you have a `std::vector<Ball> BallsAll`, you can just move any `BallsAll[x]` to any `BallsAll[y]`. However to do that for the Data Oriented version, you must do the same thing for every property (2 times in the case of Ball - radius and position). But it gets worse if you have a lot more properties. You'll have to keep an index for each "ball" and when you try to move it around, you have to do the move in every vector of properties. Doesn't that kill any performance benefit of Data Oriented Design?