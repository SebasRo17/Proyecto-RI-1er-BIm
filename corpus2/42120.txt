I tried solving this using mma. I am aware of this command - **Cellular automata**. But i don't want to use that coz then there is no challenge. So below is how i did it and my question is can this be done with fewer lines of code (without resorting to _CellularAutomaton_ ). Also i wanted to generalize it to any initial condition. > I am representing the grid shown in the puzzle as a (n $\times$ m) matrix > such that all the live cells are represented by _1_ and the dead ones by > _0_. Also in this particular case we have $n = 26$ and $m = 27$. Then i > manually made a list of the initial condition given in the question. Here > each pair represents the $(ij)^{th}$ element having live cells.   > > >   * _[as a side note - can this process be automated - i mean finding this > list from that image given for the intial grid by some image processing]_ >               list = {{2, 6}, {2, 13}, {3, 23}, {3, 25}, {4, 3}, {4, 10},            {4, 9}, {4, 18}, {5, 18}, {5, 2}, {8, 11}, {8, 12},             {10, 10}, {10, 12}, {11, 11}, {12, 18}, {13, 2}, {14, 2}, {13,               23}, {14, 8}, {14, 23}, {16, 24}, {17, 25}, {18, 24},               {18, 18}, {18, 17}, {19, 12}, {20, 12}, {20, 3}, {20, 4}, {22,              24}, {23, 23}, {22, 17}, {23, 18}};      > The matrix $A_{n \times m}$ now contains the elements _1_ and _0_ > corresponding to the live and dead cells receptively.   >  $f^{ij}_{0}$ contains the $(ij)^{th}$ element of $A_{n \times m}$                 A[n_, m_] := SparseArray[# -> 1 & /@ list, {n, m}, 0]           Table[f[0][i, j] = A[26, 27][[i, j]], {i, 1, 26}, {j, 1, 27}];      > The recursive function which gives the next generation is:-               f[k_][i_, j_] := f[k][i, j] = Module[{n = 26, m = 27, neg},            findNeighbours[i, j] := Module[{},          f[k - 1][#[[1]], #[[2]]] & /@ {{i - 1, j - 1}, {i - 1,             j}, {i - 1, j + 1}, {i, j - 1}, {i, j + 1}, {i + 1,               j - 1}, {i + 1, j}, {i + 1, j + 1}}];             neg = Cases[findNeighbours[i, j], _Integer];              (* Apply the rules to the ij th element*)         Which[f[k - 1][i, j] == 1,               Which[Count[neg, 1] < 2,                val = 0, (Count[neg, 1] === 2 || Count[neg, 1] === 3), val = 1,                 Count[neg, 1] > 3, val = 0],                 f[k - 1][i, j] == 0,                 Which[Count[neg, 1] === 3, val = 1, True, val = 0]]                 ]      > Finally we can plot the results to see the answer which is 3 if the starting > generation is called $1^{st}$ generation.                  genaration[0] =           ArrayPlot[         Table[f[0][i, j] = A[26, 27][[i, j]], {i, 1, 26}, {j, 1, 27}], Mesh -> True];                  genaration[n_] :=           ArrayPlot[Table[f[n][i, j], {i, 1, 26}, {j, 1, 27}], Mesh -> True]            res = ListAnimate[genaration[#] & /@ Range[0, 3],               AnimationRate -> 0.5]      ![](http://i.stack.imgur.com/mgrZo.gif)