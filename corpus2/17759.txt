I've got following data I'm reading from a file:               data = {{{2013, 1, 11}, 4},        {{2013, 1, 12}, 1},        {{2013, 1, 14}, 1},        {{2013, 1, 16}, 2},        {{2013, 1, 18}, 1},        {{2013, 1, 19}, -1, 16},        {{2013, 1, 20}, 2},        {{2013, 1, 21}, 2}        };      (notice that list elements may have an extra item.) Now I want a similar datelist with each time the accumulated sum (ignoring possible third elements after a data item, like the 16 in the example). Procedurally I'd do something like this:               tally = 0;     datelisttally = {};     For[i = 1, i <= Length[data],       tally = tally + data[[i]][[2]];        datelisttally = Append[datelisttally, {data[[i]][[1]], tally}]; i++];     DateListPlot[datelisttally, PlotRange -> {0, Automatic}, Joined -> True]      but I'd like to learn the best way to do this with functional programming, best being the fastest. (The file may hold several thousands of items.) **update**   I've benchmarked the 3 current solutions, and these are the results (list length = 1 million elements, averaged over 50 runs):   * Szabolc's: **0.33 s**   * PlatoManiac's: 0.54 s   * Leonid's: 3.33 s