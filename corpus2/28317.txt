Let the symbol `V` denote an element of some vector space and `nV` its norm. Let `lin` be a linear function, i.e. pull out factors that are not vectors:               lin[c_*x_?CustomVectorQ]:=c*lin[x]     CustomVectorQ[x_]:=MatchQ[x,V]      Let `f` be a (for simplicity constant) function generating an expression using `lin`               f[dummy_]:=lin[V/nV]      and `subst` shall be a simplification `subst[exp_]:=exp/.lin[V]->0`. Now, the odd thing is that if I apply `sf=subst@f@#&` to some list, the result differs depepnding on whether one uses `Map` or `ParallelMap`.               Map[sf,{dummy}]     ParallelMap[sf,{dummy}]      gives `{0}` and `{lin[V]/nV}`, respectively. Adding a debugging function `printf[exp_] := Module[{}, Print["Into subst: ", exp]; exp]`, `subst@printf@f@#&` seems to suggest, that the parallel computation does not use the downvalues of `lin` and thus `subst` does not work. Does anyone know why this happens and what can be done about it?