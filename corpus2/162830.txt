In order not to redo things several times I wanted to factorize common stuff. For Instance, let's say we have a cow and a horse. The cow produces milk, the horse runs fast, but both eat grass.               public class Herbivorous     {        protected int Quantity;             public void EatGrass(int quantity)        {           var evt= Build.GrassEaten                         .WithQuantity(quantity);           RaiseEvent(evt);        }             public void Apply(GrassEaten evt)        {            _quantity= evt.Quantity;        }     }          public class Horse : Herbivorous     {        private bool _HasFastRun;             public void RunFast()        {           var evt= Build.FastRun;           RaiseEvent(evt);        }             public void Apply(FastRunevt)        {            _HasFastRun= true;        }     }          public class Cow: Herbivorous     {        private bool _IsMilkProduced;             public void ProduceMilk()        {           var evt= Build.MilkProduced;           RaiseEvent(evt);        }             public void Apply(MilkProduced evt)        {            _IsMilkProduced= true;        }     }      To eat Grass, my application receives a command in Json or xml, or whatever that deserialise into this class:               namespace Herbivorous     {        public class EatGrass : CommandBase        {           public Guid IdHerbivorous {get; set;}           public Guid CommitId {get; set;}           public long Version {get; set;}           public int Quantity {get; set;}        }     }      The command handler should be :               public class EatGrassHandler : CommandHandler<EatGrass>     {        public override CommandValidation Execute(EatGrass cmd)        {           Contract.Requires<ArgumentNullException>(cmd != null);           Herbivorous herbivorous= EventRepository.GetById<Herbivorous>(cmd.Id);           if (herbivorous.IsNull())              throw new AggregateRootInstanceNotFoundException();           herbivorous.EatGrass(cmd.Quantity);           EventRepository.Save(herbivorous, cmd.CommitId);        }     }      so far so good. I get a Herbivorous object , I have access to its EatGrass function, whether it is a horse or a cow doesn't matter really. The only problem is here :               EventRepository.GetById<Herbivorous>(cmd.Id)      Indeed, let's imagine we have a cow that has produced milk during the morning and now wants to eat grass. The EventRepository contains an event MilkProduced, and then come the command EatGrass. With the CommandHandler, we are no longer in the presence of a cow and the herbivorious doesn't know anything about producing milk . what should it do? Should I have explicit contextual command like :               namespace Herbivorous.Cow         {            public class EatGrass : CommandBase            {               public Guid IdHerbivorous {get; set;}               public Guid CommitId {get; set;}               public long Version {get; set;}               public int Quantity {get; set;}            }            public class ProduceMilk : CommandBase            {               public Guid IdHerbivorous {get; set;}               public Guid CommitId {get; set;}               public long Version {get; set;}            }         }      This would mean that the external component that asks my herbivorous to eat grass should know that in this bounded context we talk about a cow. in the former command, we were talking about a general Herbivorous behavior, so the context of my call was not important. We knew that we needed herbivorous to eat grass that was all. This is my main problem possible leakage of domain specific from one bounded context to another. Actually It might mean too that I cannot support abstraction when working on interfaces between several applications. I wonder... Or I could just accept any event when rebuilding my herbivorous. It means that if it does not find a method to apply this event to, he will goes just fine trying to apply the next one of its stream. This is the real simple solution, but it does not put me at ease to know that events might not be applied ( and not producing errors) when rehydrating my object. (Actually the more I think about it the less I feel guilty..) Thanks for your help, I am just beginning with these kinds of problem, and I would be glad to have some news from someone more experienced.