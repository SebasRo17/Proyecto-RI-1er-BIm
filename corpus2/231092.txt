It seems like F# code often pattern matches against types. Certainly               match opt with      | Some val -> Something(val)      | None -> Different()      seems common. But from an OOP perspective, that looks an awful lot like control-flow based on a runtime type check, which would typically be frowned on. To spell it out, in OOP you'd probably prefer to use overloading:               type T =          abstract member Route : unit -> unit          type Foo() =          interface T with             member this.Route() = printfn "Go left"          type Bar() =          interface T with             member this.Route() = printfn "Go right"      This is certainly more code. OTOH, it seems to my OOP-y mind to have structural advantages:   * extension to a new form of `T` is easy;    * I don't have to worry about finding duplication of the route-choosing control flow; and   * route choice is immutable in the sense that once I have a `Foo` in hand, I need never worry about `Bar.Route()`'s implementation Are there advantages to pattern-matching against types that I'm not seeing? Is it considered idiomatic or is it a capability that is not commonly used?