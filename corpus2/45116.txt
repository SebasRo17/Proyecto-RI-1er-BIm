One thing that always irked me (in C#) was that there's a hard dependency between an interface/abstract class and the implementing class and assembly. Meaning that that if two different assemblies implements the same interface either one of them have to reference the other (where the interface lies) or they both have to reference a third assembly with the interface. It makes it harder to test different parts of an application separately and makes code much less flexible since you have to implement that specific interface. It also makes distributing libraries to third parties less tidy since if you want only to distribute part of your functionality you will either have to rework the class for thirdparties to include the interface, or have some silly assembly containing all but a interface in some cases. Shouldn't there be a way to have ducktypeable interfaces? So for instance if you have two objects with a method that takes an interface as parameter, and each assembly has separate but identical interfaces, then you would be able to interchange the two. I'm sure there are instances where we want the good 'ol strict interface dependencies we have right now but also having the possibility of "soft interfaces" might be a good idea? Or is the concept too convoluted and applicatable in too few situations (like multiple inheritance for instance). Are there languages which aren't completely ducktyped that have solved this issue and is there perhaps some designpattern to use to avoid the dependency? **Example:** Assembly A:               public interface ISomeInterface      {         ReadBooks();         WriteLetters();     }          Public ClassA : SomeInterface     {     }      Assembly B:               public interface ISomeOtherInterface      {         ReadBooks();         WriteLetters();     }          public class ClassB     {         public DoStuff (ISomeOtherInterface someOtherInterface)         {           ....         }     }      Here I'd like to have a Assembly C that references A and B and do:                 ClassA classA = new ClassA();       ClassB classB = new ClassB()       classB.DoStuff(classA as ISomeOtherInterface);      There's no direct dependency between A and B, but they can still be used together. I guess in this instance I could make an adapter class, but it feels clunky and in some instances not appropriate. Specific casting is one way to go, another would be to declare an interface as dynamic (or whatever) and then it would only check that the interfaces are identical (but not that they are the same interface). A third way would to be able to specify "dynamic" on parameters so the object could allow or disallow that kind of interfaces. Perhaps it even should be the other way around that unless you declare an interface as "explicit" you can always do that kind of typing.