`Solve` gives me an expression which I want to use as the body of a function. Rather than run `Solve` every time inside my function body, I just want to take the rule output `Solve` already gave me, and repurpose it into something that accepts arguments. For example, this works, but is slow because `Solve` runs in every invocation:               (* returns the two points where the line through pt {x1, y1}      with slope m intersects the circle x^2 + y^2 = 100 *)     intersections[m_, x1_, y1_] :=      Solve[y - y1 == m (x - x1) &&          x^2 + y^2 == 100, {x, y}] /. Rule[_, val_] -> val          intersections[1, 0, 0]     (* result: *) {{-5 Sqrt[2], -5 Sqrt[2]}, {5 Sqrt[2], 5 Sqrt[2]}}      I've tried variations on below, but they don't work:               solution = Solve[y - y1 == m (x - x1) &&           x^2 + y^2 == 100, {x, y}] /. Rule[_, val_] -> val /. {m -> #1,         x1 -> #2, y1 -> #3}          intersections[m_, x1_, y1_] := solution[m, x1, y1]      Below is almost what I want, but the rule replacements don't perform as well as real function arguments, and this is also dependent on copying around replacement symbol names:               solution = Solve[y - y1 == m (x - x1) &&           x^2 + y^2 == 100, {x, y}] /. Rule[_, val_] -> val ;     intersections := solution /. { m -> #1, x1 -> #2, y1 -> #3} &;      How can I take the the expression `Solve` gave me, and "function-ify" it? Copy-pasting the expressions into a function works, but obviously I don't want to do that.