I met a strange problem when trying to do an optimization. Initialization code,               goal = 2.;     vector = {1.0, 1.1, 1.2, 1.3, 1.4, 1.5};          f[m1_Real, m2_Real] := Block[{v},        v = Map[# + m1*Sin[Norm[{m1, m2}]] &, vector];        Clip[v, {0, goal}]];          g[m1_Real, m2_Real] := Max[(goal - f[m1, m2])/goal] + Norm[{m1, m2}];      where `f` is a vector function and `g` is a scaler function. I want to minimize `g[m1,m2]` with constrains `0.8 <= Min[f[m1,m2]] <= 1.0` and `0 <= m1 <= 2 && 0 <= m2 <=2`. Despite this seems straightforward, a direct implementation is problematic,               counter = 0;     NMinimize[{       g[m1, m2],       And[0.8 <= Min[f[m1, m2]]/goal <= 1.0, 0 <= m1 <= 2, 0 <= m2 <= 2]       }, {m1, m2},       Method -> {"NelderMead", "Tolerance" -> .001},       StepMonitor :> (Print[++counter, ":\t", {m1, m2}])]      If we execute the code, an error message NMinimize::bcons will be shown, which tells us that the constrains are not in the valid format. After a few tests I found out that the the problem is related to the command `Min` used in the first constrain `0.8 <= Min[f[m1, m2]]/goal <= 1.0`. If we do not use `Min` then there will be no problem, i.e., `0.8 <= Evaluate[Norm[f[m1, m2]/goal]] <= 1.0` can be evaluated without any problem. So it seems that `Min` is not valid for using as constrains with `NMizimize` (yet we can use `Norm`, `Plus`, etc.). But this is really inconvenient because I do need to use `Min` as part of the constrains. I wonder if we can fix this problem?