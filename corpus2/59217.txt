I have two complicated functions `f[x,y]` and `g[t]`. Before the main evaluation code in `g[expr]`, I run some computationally expensive tests to check that `expr` has correct syntax. If `expr` does not have correct syntax, it gives an error to the user. But otherwise, it continues. Now, the output of `f[x,y]` can be used as input of `g` (as in `g[f[x,y]]`). The result of `f[x,y]` is usually very _very_ complicated, but _always_ has correct syntax for the function `g`. Thus to save time I want to bypass the computationally expensive but pointless checks in `g`. For this I invented a tag: `$needsErrorChecking`, which is supposed to by switched to `False` if `f` and `g` are called in the nested form `g[f[x,y]]`. Otherwise it is `True`, in which case the error checking routines take place. Here is my toy example:               Clear[f, g]      f[x_, y_] := x + y          $needsErrorChecking = True;         g[f[z__]] ^:= "Nothing" /; ($needsErrorChecking = False);         g[t_] := Module[{variables}, Print[$needsErrorChecking];        If[$needsErrorChecking,(*Complicated Code*) Null, $needsErrorChecking = True]; 2*t];      However, Running               g[f[x, y]]      yields `True` and `2(x+y)`. So it gives the correct answer, but the error checking code isn't bypassed. What can I do to fix this? Or, is there a totally different way to go about accomplishing this task?