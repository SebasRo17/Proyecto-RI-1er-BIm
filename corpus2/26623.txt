I am seeking to integrate a highly oscillatory, multidimensional function. I am currently using NIntegrate's QuasiMonteCarlo approach. However, this is time-consuming and, given my current resources, not very accurate. How can I obtain more reliable estimates of the beasty integral given below? As the function itself will be integrated at a later stage, I am also interested in speeding up the function evaluation. The integral to be solved:               fun[r_?NumericQ, d_?NumericQ, c_, opts:OptionsPattern[]]:=        NIntegrate[           Cos[(c (d^2+r^2-2 d r Cos[ta] - 3 ((-r+d Cos[ta]) Cos[tb]+d Cos[a] Sin[ta] Sin[tb])^2)) / Abs[d^2+r^2-2 d r Cos[ta]]^(5/2)]            Cos[(c (d^2+r^2+2 d r Cos[ta] - 3 ((r+d Cos[ta]) Cos[tb]+d Cos[a] Sin[ta] Sin[tb])^2)) / Abs[d^2+r^2+2 d r Cos[ta]]^(5/2)]           * Sin[ta]*Sin[tb]/(2*Pi),        {ta,0,Pi},        {tb,0,Pi/2},        {a,0,Pi},        Evaluate@FilterRules[{opts},Options[NIntegrate]]     ]      Typically, $d$ = 2, $r$ is in the range from 0 to Infinity (with the small values and $r$=$d$ posing problems), and $c$ is in the range from 100 to 3000. A typical function call is:               AbsoluteTiming[fun[3, 2, 400, Method -> "QuasiMonteCarlo", PrecisionGoal -> 6,      MaxPoints -> 40000000]]     (* -> {102.3215798,-0.00442278} *)      This issues a NIntegrate::maxp warning and indicates an error estimate of 0.00011. Using the default strategy I obtain:               AbsoluteTiming[      fun[3, 2, 400, MaxRecursion -> 20, Method -> {GlobalAdaptive, MaxErrorIncreases -> 10000}]]     (* -> {9.3912165,-0.00439357} *)      and a NIntegrate::eincr warning. Estimated error: 0.0369. How to proceed from here? Thank you for your help.