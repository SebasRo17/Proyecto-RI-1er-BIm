I've been going back and forth on how to handle this best. **The problem** C# project consisting of WCF services used by a Flex application. A customer may request a functionality change that requires me to alter code to work just for them. It could be a single line of code in a method or maybe a method acts in a totally different way for customer x. **My Ideas**   1. Use branches for customers that have a customization. When a release is ready, merge to customer branches and try not to break / forget what their customization was for. We use SVN. I'm not a huge fan of this as the code base is very large.   2. Use inversion of control, dependency injection, and MEF. Create an interface for the class/s that needs to be modified. Create a new class library project (that is, customerabc), add a new class that implements the class just created, override method/s as needed for customer changes. Add a MEF export. I then place this in a customization folder and point MEF there. If it finds a DLL file in the folder, it uses that instead of the export from the executing assembly. I like option 2 ... Pros   1. Easy - normal deployment install, then drop in their DLL file.    2. Obvious - it might not be overly clear wether or not a customer is running code from their branch. With this option I could just look at the customization folder.   3. Clean - only the files that need to be customized exist. There isn't any need for a full copy of trunk. d. It promotes better SOLID for future development and refactoring (this project has little OOP). Cons   1. It will be harder to manage changes in trunk out to the customer projects.   2. It doesn't necessarily solve my problem with database changes or changes on the Flex side.   3. If the change is a single line of code in a 500 line method, I don't see any other option than to override that method, copy paste the code to the customer override and make the one line change. This isn't good use of DRY to me, but is there a good way around this?   4. OK, so better use of OOP and SOLID principles could mitigate some of this, but it also means that to implement a simple customer request, I have to do some major refactoring to the whole class... potentially many classes. What should I do?