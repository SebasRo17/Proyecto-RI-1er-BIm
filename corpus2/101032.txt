**Note** : this is a reposting as the question has been considered non- suitable for the Stack Overflow forum and should have been posted here. The original topic is there. I'd like to talk of multithreading, parallelism and the libraries available today to achieve that work. I'm especially wondering whether an easy-to-use library to achieve this concept (given below) already exists, or whether it would have to be written, and how hard it would be. **The purposes of the library** I'm looking for:   * accessible to most developers, not only to engineers or highly graduated persons (this should mean developers WANT to use it, not being afraid of it)   * available to C++ developers    * portable (start with Windows, Mac OS X and Linux, then extend to mobile devices)    * lightweight    * easy-to-use (related to accessibility)  **The most important features** I'm looking for:   * task parallelism    * task cancellation (in a soft and abrupt manner)    * task dependencies  **The existing related libraries** :   * **Thread Building Blocks** : really complicated to use, and rather restrictive licence (GPL / commercial), it's the only library that I've found and that includes all of the features I'm looking for    * **Grand Central Dispatch** : currently not portable, not too complicated, no task cancellation (once started), no task dependencies, no automatic dependency support (only manual)    * **PFunc** : Unix only, still a bit complicated, no task dependency, no task cancellation    * **Microsoft Task Parallel Library** : MS platform and .NET only, no hard cancellation, restricted and manual task dependencies (one task cannot wake up more than one other task)    * **OpenCL** : not currently available on all platforms, not much more that an GPU parallel task library (not as high level as I would wish)    * **OpenMP** : widely supported except free versions of Visual Studio, no task cancellation nor automatic task dependencies  So what are your thoughts about all of these? Why do you think there are so few libraries corresponding to these needs? Or did I miss some great library? And do you think it would mean too much work to achieve one? Or not interesting enough? Note that the lacks I wrote are those I found out with some searches, I'm not a expert in any of these libraries. The final purpose of this library, even if it's rather a dream, would be programming in a parallelized way as easily as you usually do with sequential programming. Ceylo