I am trying to write a function which produces square matrices with certain characteristics. The function should have two inputs:   1. number of the rows, `n`   2. number of the times each element in the range 1, 2, 3, ..., n should be repeated in the matrix So assuming the function is called `KOCH` then `KOCH[4, {2, 4, 5, 5}]` means the matrix should be 4 x 4 with 1, 2, 3 and 4 repeated respectively for 2, 4, 5, 5 times in the matrix, but each row in the output should be nondecreasing. And finally the function should find all the possible matrices, not only some of them. The code I prepared is as following               Koch[n_, num_] :=        Module[{list},         list = Flatten@Table[Range[n], {i, n}];         list = DeleteDuplicates[Sort /@ Tuples[list, {n}]];         list = DeleteDuplicates[Sort /@ Tuples[list, {n}]];         For[i = 1, i < n + 1, i++,            list = list[[Flatten@Position[Map[Count[#, i, 2] &, list], num[[i]]]]]];         list]      But as you notice what I am doing is to reproduce a large pool of the possible matrices and then filtering them with regards to the constraint on the number of repeatings. So it's inefficient. My function works for up to `n = 4` even though it takes seconds for `n = 4` but for `n = 5` it fails because of memory constraint with shooting this error > General::nomem: The current computation was aborted because there was > insufficientmemory available to complete the computation. I need to compute for up to `n = 15` and, therefore, need a better algorithm to find all the possible matrices given the constraints.