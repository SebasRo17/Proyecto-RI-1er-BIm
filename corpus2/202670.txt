Assume I have a simple interface for translating text (sample code in C#):               public interface ITranslationService     {         string GetTranslation(string key, CultureInfo targetLanguage);         // some other methods...     }      A first simple implementation of this interface already exists and simply goes to the database for every method call. Assuming a UI that is being translated at start up this results in one database call per control. To improve this, I want to add the following behavior: > As soon as a request for one language comes in, fetch _all_ translations > from this language and cache them. All translation requests are served from > the cache. I thought about implementing this new behavior as a decorator, because all other methods of that interface implemented by the decorater would simple delegate to the decorated instance.   However, the implementation of `GetTranslation` wouldn't use `GetTranslation` of the decorated instance _at all_ to get all translations of a certain language. It would fire its own query against the database.   This breaks the decorator pattern, because every functionality provided by the decorated instance is simply skipped. This becomes a real problem if there are other decorators involved. My understanding is that a Decorator should be additive. In this case however, the decorator is _replacing_ the behavior of the decorated instance. I can't really think of a nice solution for this - how would you solve it? Everything is allowed, even a complete re-design of `ITranslationService` itself.