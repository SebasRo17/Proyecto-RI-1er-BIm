I presently have a clock app that calculates from scratch at every iteration. This means O(1) corrupt bits in my doubles and heavy object creation and deletion as well. I am wary of running indefinite calculations with doubles or any other floats because O(n) corrupt bits normally accompany every step. I would like to know if there is an alternate way (in an iOS app) to transform and position clock hands with O(1), or maybe O(log n), corrupt bits after n steps. In particular, I was wondering what the corruption would be for "At each step, rotate each hand back to the zero position, meaning an affine rotation transformation of -1 * the last rotation the hand received, and then rotate forward by the new angle the hand should have at this step." In Objective-C's floating point arithmetic, is it ever not the case (excluding exceptions like a value indicating a number is corrupt) that x - x != 0.0 exactly? The cases I've seen illustrating floating point corruption bits include Python saying that 1.1 + 1.1 + 1.1 - 3.3 != 0.0; I haven't seen textbook examples of the form x - x != 0.0. This is not exactly the question of whether a raster image transformed by angle x and then by angle -x is its original self; it may be that the preceding suggestion would work fine for O(1) error on angles but usual corruption in the image drawn and transformed. What is the minimum "corruption complexity", meaning fewest corrupt bits at end of n calculations, for rendering a clock? Are there O(1) or O(log n) approaches? Thanks,