I'm writing a code to do rotational averages of image FFT's. I have a working version but it is pretty slow. Wondering if anyone has any thoughts on a way to do this more efficiently. Data looks like this generally: ![rawData FFT](http://i.stack.imgur.com/sGVvR.jpg)                   img1 = Import["http://i.imgur.com/0QZs0AN.png"];         img = ImageAdjust[ImagePeriodogram[img1], 1];              imgpts[r_, \[CapitalDelta]_, imagedimension_] :=            If[r != 0 , Table[{r Cos[2 \[Pi] t] + imagedimension/2,          r Sin[2 \[Pi] t]          + imagedimension/2} // N, {t, 0, 1,          1/(\[CapitalDelta] r)}], {{imagedimension/2, imagedimension/2},         {imagedimension/2, imagedimension/2}} // N];              RotationalAverage[FFT_, imgdim_, rmax_, \[CapitalDelta]_, inter_] :=            Table[{r, Mean[ImageValue[FFT, #, Resampling -> inter] & /@            imgpts[r, \[CapitalDelta], imgdim]]}, {r, 0, rmax}];              imagevals = RotationalAverage[img, 1024, 140, 16, "Bicubic"];      I decided to make each circle average over bins of the same arc-length. Im not sure if this is the "right" way to do this, but it seemed like a good idea. This gets me the data I want and I usually make a plot at this point just to check.                   ListPlot[imagevals]      ![plot for checking](http://i.stack.imgur.com/ku4fD.jpg) Then i stitch the images together to get a picture.                   ImgData = Reverse@Table[If[N[Sqrt[x^2 + y^2]] < 140,                  Interpolation[imagevals][Sqrt[x^2 + y^2] // N], 0], {x, 0, 128},          {y, 0, 128}] // Quiet;              ImageAdjust[ImageAssemble[{{Image[Reverse@Transpose@ImgData],          Image[ImgData]}, {Image[Transpose@ImgData],Image[Reverse@ImgData]}}], 1]      To get something like this ![final product](http://i.stack.imgur.com/ncEHq.jpg) What I'm ultimately after i guess is some optimization of accurate and fast, which is pretty vague but i guess i don't know how else to say it.