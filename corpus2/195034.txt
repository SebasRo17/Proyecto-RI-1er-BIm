To explain what I mean, let me start with an example. Consider a `deque` that supports `O(logn)` concatenation with another deque and `O(n)` addition of `n` elements at one end. This dequeimplements a general `seq` interface (or type-class, or what have you) that allows iterating over a collection. An explicit optimization approach would be, having a `concat` method (or function) for deque objects and a separate `pushSeq` method for seq objects. Each method would be documented with the appropriate complexity. An implicit optimization approach would be to have a single `concat` method that accepts a seq. An internal dynamic type test checks whether the supplied argument is actually a deque, and if so, calls an implementation method for concating deques. This is documented in the API. Obviously you could have both of these. The point of implicit optimization is that you don't give the user explicit control over optimization. It just "happens", unless the user deliberately looks for it. Right now I'm writing a library and I'm facing a very similar choice. I very much like the idea of a compact interface where things just "work". An implicit approach also gives me a lot more freedom. For example, maybe I can perform ten dynamic type tests to optimize the concat operation for different collections. Having ten different methods wouldn't make sense. What's your take on this? Which approach is better, and why?