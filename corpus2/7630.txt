I'm trying to write a simulation using Mathematica 8.0. Since I will most likely be doing the same operation over and over again, I'm trying to `Compile` whatever I can. However, I've been having problems avoiding `MainEvaluate` calls when I define `CompiledFunction` objects which refer to global variables. A simplified sample of what I'm trying to use is:               g = 4.49*^3;     m = 1.;     s = 1.;     ϵ = 2.;     sAcceleration = Compile[{{sPosition, _Real, 1}},        (-g (m + s))/(sPosition.sPosition + ϵ*ϵ)^(3/2) sPosition];      I have also tried wrapping the whole thing inside a `Module`, to no avail:               sAcceleration2 =  Compile[{{sPosition, _Real, 1}},       Module[{gg = g, mm = m,  ss = s, ϵϵ = ϵ^2},         (-gg (mm + ss))/(sPosition.sPosition + ϵϵ)^(3/2) sPosition]];      They seem to run just fine. However, when I take a look at what the `CompiledFunction` is trying to do internally using `CompilePrint`               << CompiledFunctionTools`     CompilePrint[sAcceleration]     CompilePrint[sAcceleration2]      I get, respectively > 1 R1 = MainEvaluate[ Function[{sPosition}, g][ T(R1)0]] > > ... > > 3 R1 = MainEvaluate[ Function[{sPosition}, m][ T(R1)0]] > > 4 R4 = MainEvaluate[ Function[{sPosition}, s][ T(R1)0]] > > ... > > 7 R6 = MainEvaluate[ Function[{sPosition}, ϵ][ T(R1)0]] > > 8 R7 = MainEvaluate[ Function[{sPosition}, ϵ][ T(R1)0]] > > ... and > 1 R1 = MainEvaluate[ Function[{sPosition}, g][ T(R1)0]] > > 2 R3 = MainEvaluate[ Function[{sPosition}, m][ T(R1)0]] > > 3 R4 = MainEvaluate[ Function[{sPosition}, s][ T(R1)0]] > > 4 R6 = MainEvaluate[ Function[{sPosition}, ϵ][ T(R1)0]] > > ... Since I will most likely be toying with different values for these variables in different simulation runs, but they will be held constant within a given run, can I avoid both `MainEvaluate` and feeding these variables to my function as additional arguments? Thanks in advance.