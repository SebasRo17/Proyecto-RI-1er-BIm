I figure this question has many solutions, and if an answer already exists it would be nice just to be referred to it. I need a function that 'maps' over my list and produces a list of equal length of either 1 or 0 with particular conditions that switch the the result from 1 to 0. The result starts as `0` and is carried into the next step unless one of these conditions is met:   1. That when both the first and element is `1` we set our result to `1`; this can happen on the first element of the list.   2. When the last element is `0` we set our result to `0`.   3. However if we don't find a `1` at position two in any even numbered list counting from the switch to `1` before the next switch back to `0`, then leave the result as 0 for the entire period. Essentially step 3 requires that if for the period that the result could be 1 (according to steps 1. and 2.) that at least once the even numbered elements in that period have [[2]]=1. For example if the data is `{{0, 0, 1}, {1, 0, 1}, {0, 0, 1}, {1, 0, 1}, {0, 0, 1}, {1, 0, 1}, {0, 0, 0}}` then the result of this algorithm is `{0, 0, 0, 0, 0, 0}`. Without the third condition it would yield `{0, 1, 1, 1, 1, 1, 0}`. However if the data is `{{0, 0, 1}, {1, 0, 1}, {0, 1, 1}, {1, 0, 1}, {0, 0, 1}, {1, 0, 1}, {0, 0, 0}}` (note the third element has a 1 at position 2 which meets the criteria that is in the element that is in a odd position after the switch, in this case 1 element after), then the result should be `{0, 1, 1, 1, 1, 0}`. So far I have tried a Which function in a Table. This is fine for steps 1. and 2., but not so good for 3.               Table[      Which[       i == 1 && data[[i, 1]] == 1 && data[[i, -1]] == 1, 1,       i == 1, 0,       i > 1 && (data[[i, 1]] == 1 || data[[i, 2]] == 1) &&         data[[i, -1]] == 1, 1,       i > 1 && (data[[i - 1, 1]] == 1 || newALtest[[i - 1, 2]] == 1) &&         data[[i - 1, -1]] == 1 && data[[i, -1]] == 1, 1,       i > 1, 0], {i, 1, Length[data]}]      Some example data is here               data={{0, 0, 0}, {0, 0, 0}, {0, 0, 1}, {1, 0, 1}, {0, 0, 1}, {1, 0, 1}, {0, 0, 1}, {1, 0, 1}, {0, 0, 0}, {0, 0, 0}, {1, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {1, 0, 0}, {1, 0, 1}, {0, 1, 1}, {1, 0, 0}, {0, 0, 0}, {1, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0},{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {1, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 1}, {1, 0, 1}, {0, 1, 1}, {0, 0, 0}, {0, 0, 1}, {0, 0, 1}, {1, 0, 1}, {0, 1, 1}, {0, 1, 1}, {0, 1, 1}, {0, 1, 1}, {0, 1, 1}}      Any tips about the approach to take would probably get me heading in the right direction (I'm trying steps 1. and 2. first, then using that result for another test, but I'm still mighty confused). For the above table, the result will be               result= {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1}