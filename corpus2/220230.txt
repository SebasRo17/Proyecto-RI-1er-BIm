I keep wondering if it is legitimate to use verbs that are based on nouns in OOP.   I came across this brilliant article, though I still disagree with the point it makes. To explain the problem a bit more, the article states that there shouldn't be, for instance, a `FileWriter` class, but since writing is an **action** it should be a **method** of the class `File`. You'll get to realize that it's often language dependent since a Ruby programmer would likely be against the use of a `FileWriter` class (Ruby uses method `File.open` to access a file), whereas a Java programmer wouldn't. My personal (and yes, very humble) point of view is that doing so would break the Single Responsibility principle. When I programmed in PHP (because PHP is obviously the best language for OOP, right?), I would often use this kind of framework:               <?php          // This is just an example that I just made on the fly, may contain errors          class User extends Record {              protected $name;              public function __construct($name) {             $this->name = $name;         }          }          class UserDataHandler extends DataHandler /* knows the pdo object */ {              public function find($id) {              $query = $this->db->prepare('SELECT ' . $this->getFields . ' FROM users WHEREÂ id = :id');              $query->bindParam(':id', $id, PDO::PARAM_INT);              $query->setFetchMode( PDO::FETCH_CLASS, 'user');              $query->execute();              return $query->fetch( PDO::FETCH_CLASS );         }               }          ?>      It is my understanding that the suffix DataHandler doesn't add anything relevant; but the point is that the single responsibility principle dictates us that an object used as a model containing data (may it be called a Record) shouldn't also have the responsibility of doing SQL queries and DataBase access. This somehow invalidates the ActionRecord pattern used for instance by Ruby on Rails. I came across this C# code (yay, fourth object language used in this post) just the other day:               byte[] bytes = Encoding.Default.GetBytes(myString);     myString = Encoding.UTF8.GetString(bytes);      And I gotta say that it doesn't make much sense to me that an `Encoding` or `Charset` class actually _encodes_ strings. It should merely be a representation of what an encoding really is. Thus, I would tend to think that:   * It is not a `File` class responsibility to open, read or save files.   * It is not a `Xml` class responsibility to serialize itself.   * It is not a `User` class responsibility to query a database.   * etc. However, if we extrapolate these ideas, why would `Object` have a `toString` class? It's not a Car's or a Dog's responsibility to convert itself to a string, now is it? I understand that from a pragmatic point of view, getting rid of the `toString` method for the beauty of following a strict SOLID form, that makes code more maintainable by making it useless, is not an acceptable option. I also understand that there may not be an exact answer (which would more be an _essay_ than a serious answer) to this, or that it may be opinion-based. Nevertheless I would still like to know if my approach actually follows what the single-responsibility principle really is. What's a class's responsibility?