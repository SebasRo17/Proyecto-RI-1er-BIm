Consider this example: given an option for a function `func` as `"x" :> (a&)`, how can one assign different values to `a` locally inside `func`?               a = False; (* global value of a *)     func[opt_] := With[{a = True}, Evaluate["x" /. opt]]; (* oversimplified function *)          func["x" :> (a &)]    (* ==> a & *)      No amount of `Evaluate` seems to help here. The problem with `With` is that in this case it is interpreted as `With[{a$ = 1}, a&]`, thus no replacement will be done. If I use `Block` instead of `With` the problem boils down to this (as `Block` won't replace variables inside `Function`):                Block[{a = True}, a &]   (* ==> a & *)      I do not want to define the option to be a function depending explicitly on `a`: I expect the user to write his own pure function for `"x"` where he can also use `a` that should acquire its local value when the `With/Block` is evaluated. Also, the problem disappears, if the code is simplified, but of course this is a no-go, as I need a function:               opt = "x" :> (a &);     With[{a = True}, Evaluate["x" /. opt]]   (* ==> True & *)      I've checked the following posts (mostly by Leonid and Mr.W), none of which offered a clear solution: this, this and this.