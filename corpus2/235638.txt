I was just working with a method of about 70 lines of code developed by others. It uses a very nice pattern structure, stuff like IOC container, but I wonder.. The method is too long? Is it a so long method still easily readable? The question could be finished, but now starts the premise from which my question has originated. * * * Before realizing its length (excessive for me) I was getting bored while trying to understand what it was doing. It's full of instruction of this kind:               if (success == null)     {         //Log response error         logger.LogProviderActionResponse(userId, "actionName", transactionRequestId,             _configuration.ResponseLogErrorTryAgainId, xmlResponse.InnerXml.ToXml(true));         return new CheckActionResult(ActionStatus.Failed);     }      What is it doing and why? It deals with logging of course, because the `success` variable is null, but what does it imply? And also there are many parameters, what is their meaning? I would need to read it carefully, to study it. The problem is that this method implements an interface and an abstract class, it has many siblings. Copy and pasted siblings which share the same structural behavior. But it's not immediate to distinguish structural information from domain specific information. In developing a new action or a new provider I should only need to copy, paste and modify **domain specific** stuff. But it's hard.. since they are deeply mixed together with structural behavior... ## Refactoring I would do to raise the readability   * ### 1st step surround all this logging with a #region that can be collapsed   * ### 2nd step could be to use Extract Method to trasnsform the previous log call to a single instruction. Something like: Log.LogWithReason(Success.IsEmpty); But the usage of return conflicts with this purpose requiring extra effort.   * ### 3rd step would be to completely separate the Logging responsability (using AOP? Implementing it in the base class? using events?). If one method has 5 / 8 calls to the log for different reasons. It's too much aware of logging. In my opinion the Single responsibility principle is violated since the methods has gained the secondary responsability of being strongly aware about logging. * * * The question remains the one specified in the title but I hope to read a very mature comparison here based on the seeds idea I've wrote! Thanks for your contribute