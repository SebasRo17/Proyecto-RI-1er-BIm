I have the following: **Constants:**               b3b = 2;     G = (1/eps^2);     a1 = 3;     a3 = 4;     xc = 0.3;      **Functions:**               y[x_] := (x*a1 - x^3*a3)/G     n[x_] := (y[x]^2)      **I want`g[x], gp[x], gpp[x]` as functions of `eps` only and all of these three functions should be evaluated at `x=xc` :**               g[x_] := (G*(-y[x]/eps)*Exp[-n[x]] - (b3b/eps)*          NIntegrate[(y[s])^4*Exp[-n[s]], {s, 0, xc}])      Please note that in the **integrand** above --> both `n[x]` and `y[x]` are functions of `eps` and so I can use `NIntegrate` since I am using `:=` for `g[x]` even though `eps` is not given a numerical value as yet. Everything is perfect till this point as I am able to get a numerical value for `g[xc]` for a `eps` value. The problem happens when I take the following derivatives:                gp[x_] := D[g[x], x]      gpp[x_] := D[gp[x], x]      since when I evaluate `gp[xc]` and `gpp[xc]` for a particular `eps` value, I get errors: `NIntegrate::inumr` and `General::ivar`. Therefore, I need a way to get around this. I must be doing something wrong. Any help would be greatly appreciated. Thanks!