I am trying to plot an electric pottentional of a dielectric cylinder along with it's field. The pottentional is a piecewise function               F[r_, f_] :=       Piecewise[{{-2 e r Cos[f]/(1 + er),      0 <= r < a}, {-e r Cos[f] + (er - 1)*a^2 *e*r^(-1)*Cos[f],      r >= a}}](*electorstatic pottential*)     e = 500;(*outer electric field*)     a = 0.02;(*cylinder's radius*)     er = 2;(*relevant acceptance*)      What's the best way to plot this function(pottential), with it's derivative(electric field)? I tried to plot it using `ContourPLot` but it doesn't look nice(I am not a Mathematica expert apparently)               ContourPlot[-2 e r Cos[f]/(1 + er), {r, 0, a}, {f, 0, 2 Pi}]     ContourPlot[-e r Cos[f] + (er - 1)*a^2 *e*r^(-1)*Cos[f], {r, a,      2 a}, {f, 0, 2 Pi}]     Show[%, %%]      ![](http://i.imgur.com/FkJkt.png) What I am trying to achive is a sophisticated plot,with the cylinder at the origin, where the equipottential lines and the electric field lines will be plotted. I found something like that on the net (specifically the page "Gradient field plots in Mathematica"), but I don't know how to modify it...               gradientFieldPlot[f_, rx_, ry_, opts : OptionsPattern[]] :=       Module[{img, cont, densityOptions, contourOptions, frameOptions,         gradField, field, plotRangeRule, rangeCoords},        densityOptions =         Join[FilterRules[{opts},           FilterRules[Options[DensityPlot],            Except[{Prolog, Epilog, FrameTicks, PlotLabel, ImagePadding,              GridLines, Mesh, AspectRatio, PlotRangePadding, Frame,              Axes}]]], {PlotRangePadding -> None, Frame -> None,           Axes -> None, AspectRatio -> Automatic}];       contourOptions =         Join[FilterRules[{opts},           FilterRules[Options[ContourPlot],            Except[{Prolog, Epilog, FrameTicks, PlotLabel, Background,              ContourShading, PlotRangePadding, Frame, Axes,              ExclusionsStyle}]]], {PlotRangePadding -> None, Frame -> None,           Axes -> None, ContourShading -> False}];       gradField = ComplexExpand[{D[f, rx[[1]]], D[f, ry[[1]]]}];       field =         DensityPlot[Norm[gradField], rx, ry,          Evaluate@Apply[Sequence, densityOptions]];       img = Rasterize[field, "Image"];       plotRangeRule = FilterRules[Quiet@AbsoluteOptions[field], PlotRange];       cont = If[         MemberQ[{0,            None}, (Contours /. FilterRules[{opts}, Contours])], {},          ContourPlot[f, rx, ry, Evaluate@Apply[Sequence, contourOptions]]];       frameOptions =         Join[FilterRules[{opts},           FilterRules[Options[Graphics],            Except[{PlotRangeClipping, PlotRange}]]], {plotRangeRule,           Frame -> True, PlotRangeClipping -> True}];       rangeCoords = Transpose[PlotRange /. plotRangeRule];       Apply[Show[          Graphics[{Inset[             Show[SetAlphaChannel[img,                "ShadingOpacity" /. {opts} /. {"ShadingOpacity" -> 1}],               AspectRatio -> Full], rangeCoords[[1]], {0, 0},              rangeCoords[[2]] - rangeCoords[[1]]]}], cont,           StreamPlot[gradField, rx, ry,            Evaluate@FilterRules[{opts}, StreamStyle],            Evaluate@FilterRules[{opts}, StreamColorFunction],            Evaluate@FilterRules[{opts}, StreamColorFunctionScaling],            Evaluate@FilterRules[{opts}, StreamPoints],            Evaluate@FilterRules[{opts}, StreamScale]], ##] &,         frameOptions]]      This can be run like that               gradientFieldPlot[(y^2 + (x - 2)^2)^(-1/         2) - (y^2 + (x - 1/2)^2)^(-1/2)/2, {x, -1.5, 2.5}, {y, -1.5,        1.5}, PlotPoints -> 50, ColorFunction -> "BlueGreenYellow",       Contours -> 10, ContourStyle -> White, Frame -> True,       FrameLabel -> {"x", "y"}, ClippingStyle -> Automatic, Axes -> True,       StreamStyle -> Orange]      And the amazing output is ![](http://i.imgur.com/qlDMM.png) What I would like to do is ![](http://i.imgur.com/1JVe9.jpg)