Starting from a set of points, I want to fill an area using disks. Each disk's center should be one of the points and the disks should not overlap. I've managed to write a function that, given a list of points, finds the respective radii of the disks:               findRadii[pts_] := Module[{        vars = Unique /@ (("x" <> ToString@#) & /@ Range@Length@pts),        norms = Norm[Subtract[##]] & @@@ Subsets[pts, {2}],        dists, constraints},       dists = Plus @@@ Subsets[vars, {2}];       constraints = Thread[dists <= norms]~Join~Thread[vars > 0];       NArgMax[{Total@vars^2, constraints}, vars]       ]      The function just maximises the square of the sum of radii with the constraint that each radius should be positive and the sum of two radii should be smaller than the dsitance between the respective points (I know that this in fact does not maximize the filled area, which maximizing `Total[vars^2]` would, but I've found the result to look nicer). Testing the function (and timing it) yields the following:               SeedRandom@1; foo = RandomReal[{0, 10}, {20, 2}];            Timing[radii = findRadii[foo];]     (* {13.931, Null} *)          Graphics[{MapThread[Circle[#1, #2] &, {foo, radii}], Red, Point[foo]}]      ![enter image description here](http://i.stack.imgur.com/Jcp9p.jpg) Am I missing a simpler way to calculate the distances? How can the function's performance be increased? Ultimately, I would like to use it with >100 points in reasonable time. Note that I don't need a strict maximum of the covered area, but rather a visually appealing result.