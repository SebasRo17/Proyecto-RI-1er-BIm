The post title's pretty much says it all... The reminder of this post just describes the little headway I made with this problem, FWIW. * * * One would hope that               In[100]:= Quiet[whatever[], Messages[SomeArbitraryBuiltIn]]      would do it, but no. For one thing, `Messages` shows only those messages that have been defined in the current session, and (from the docs):               In[1]:= Messages[NDSolve]     Out[1]= {}          Typically, for system commands, messages are only loaded when they are required:          In[2]:= NDSolve[{x'[t] == x[t, s], x[0] == 0}, x, {t, 0, 1}];             Messages[NDSolve]                       NDSolve::dvlen :                   The function x[t,s] does not have the same number of arguments as                   independent variables (1). >>          Out[2]= {HoldPattern[NDSolve::"dvlen"] :>                The function `1` does not have the same number of                 arguments as independent variables (`2`).}      Besides, even when `Messages` delivers the goods, it does so in a form that is not readily usable by `Quiet`; e.g.:               In[109]:= Take[Messages[General], 3]          Out[109]= {HoldPattern[General::appname] :>                  The name `1` is not valid for the application. A valid name starts with                  a letter and is followed by letters and digits.,                 HoldPattern[General::argtu] :>                  `1` called with 1 argument; `2` or `3` arguments are expected.,                 HoldPattern[General::bktmcp] :>                  Expression "`1`" has no closing "`2`"`4`.}      I'm sure that, after a few afternoons of torture, I'd just manage to come up with an incantation that's just _ridiculous enough_ to get all those `HoldPattern`'s to cooperate with `Quiet` (which, for additional pain, has attribute `HoldAll`), but I'd appreciate a leg up on that too.