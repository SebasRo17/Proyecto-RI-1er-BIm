Often times it's a good idea to have an abstract base class to isolate the interface of the object. The problem is that copy construction, IMHO, is pretty much broken by default in C++, with copy constructors being generated by default. So, what are the gotchas when you have an abstract base class and raw pointers in derived classes?               class IAbstract     {         ~IAbstract() = 0;     }          class Derived : public IAbstract     {         char *theProblem;         ...     }          IAbstract *a1 = new Derived();     IAbstract a2 = *a1;//???      And now do you cleanly disable copy construction for the whole hierarchy? Declare copy construction as private in `IAbstract`? Are there any rules of three with abstract base classes?