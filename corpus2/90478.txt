For code review technique training, I have to cover various topics. One of them is premature optimization. I found 3 traits of it as:   1. It's generally evil; causing **inverse effects**.   2. It's an **unnecessary pain** , causing no gain.   3. It demands lot of effort to achieve **little benefits** Is there any other trait which am I missing ? Also, to illustrate them, I usually get a good examples for only 1st scenario. Can someone suggest any solid example for 2nd and 3rd scenario also ? Example for 1st scenario: > Using char instead of int for smaller loops to save bytes!               for(char c = 0; c < 20; c++) {} //Evil: Accessing 'char' costlier than 'int'      [Note: I am not worried about the fact that compilers usually itself takes care of premature stuff. This training is meant just for illustration.] This question is not about, "What optimizations are premature?"