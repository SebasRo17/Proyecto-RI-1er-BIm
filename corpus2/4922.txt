Note that this question is _not_ a duplicate of that one. It is specifically about the pattern-matching engine, and explicitly excluding those patterns which call back into the full evaluation (i.e. `PatternTest` and `Condition`; if there are others like those, consider them excluded as well). To state the problem more specifically: Given a problem with a yes/no answer which can be decided in finite time by an appropriate Turing machine, does there always exist a Mathematica pattern involving neither `PatternTest` nor `Condition` together with an appropriate encoding for the input data which matches iff the Turing machine would give "yes" for the input data? To make more clear what I mean, I give an example of a problem solvable both with a Turing machine and with the pattern matcher: Given a natural number, determine whether that number is even or odd. It is obvious that a Turing machine can solve this problem in finite time. Here's how pattern matching can solve that problem: Encode the natural number into a list of as many `1`, so that 0 is `{}`, 1 is `{1}`, 2 is `{1,1}` etc. Then the pattern implementing the test is simply `{PatternSequence[1,1]...}`.