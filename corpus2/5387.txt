This question is inspired by a Stack Overflow question that I decided to solve using _Mathematica_. In addition to _Mathematica_ , I thought I'd use some of the new version's graph-related functionality, which I've never really explored in the past. It seemd like a natural fit, but the further I got into my program, the more awkward everything seemed. First, the board from the orginal question:               F X I E     A M L O     E W B X     A S T U      I use a mix of features to turn this into a `Graph`; with `ImportString` I was able to copy and past from my browser directly into a string literal in my notebook.               makeBoggleBoard[s_String] :=      makeBoggleBoard@ImportString[s]          makeBoggleBoard[mat : {{__String} ..}] /; MatrixQ[mat] :=      With[{dims = Dimensions@mat,        cPatt = {_Integer, _Integer},        dPatt = Alternatives[{1, 0}, {0, 1}, {1, -1}, {1, 1}]        },       With[{coords = Tuples[Range /@ dims]},        With[{          vertexRules =            Thread[coords -> Thread[{Range@Length@coords, Flatten@mat}]],          edgePattern = {c1 : cPatt, c2 : cPatt} /; MatchQ[c1 - c2, dPatt]          },         Graph@Cases[Tuples[coords, 2],           c : edgePattern :> ((UndirectedEdge @@ c) /. vertexRules)]]]]      This already seems a little bit clunky. Most of the difficulty comes about from trying to associate a letter with each vertex in my graph while keeping all the vertices distinct. However, this mostly seems to work well. Also, it will help to winnow the dictionary so it only contains valid words (they must have more than three letters and only use letters on the board). This part, at least, is pretty easy and quick:               makeBoggleDictionary[board_Graph] :=       With[{chars =           ToLowerCase@DeleteDuplicates@(VertexList@board)[[All, -1]]},        DictionaryLookup[chars ~~ chars ~~ chars ~~ (chars ...)]];      Now it's time to traverse the graph, finding all the words along the way. We need to traverse each possible path from each vertex, check to see if the path so far spells a word, and if it does, collect it. In order to keep performance reasonably in hand, we want to cull paths that can't possible spell a word as quickly as possible. Here's the function I came up with:               findWordsInBoggleBoard[graph_Graph, dict : {__String}] :=      With[{        makeWord = ToLowerCase@StringJoin[#[[All, 2]]] &,        lookup =          Function[pattern,           Flatten[StringCases[dict,             StartOfString ~~ pattern ~~ EndOfString]]]        },       Module[{extendPaths},        extendPaths[v_, {}] :=         With[{adj =             DeleteCases[VertexList@NeighborhoodGraph[graph, v], v]},          Join @@ (extendPaths[#, {{v}}] & /@ adj)];        extendPaths[v_, paths_] :=         Module[{           extended = Append[#, v] & /@ paths,           nexts,           strings,           feasible,           adj = DeleteCases[VertexList@NeighborhoodGraph[graph, v], v]},          strings = makeWord /@ extended;          Scan[           Sow,           lookup[Alternatives @@ strings]           ];               feasible =           Pick[            extended,            Function[string,              MatchQ[               Select[lookup[string ~~ __],                 StringLength@# >= 3 &], {__String}]] /@ strings];               nexts =           DeleteCases[            {#, Select[feasible, Function[path, FreeQ[path, #]]]} & /@ adj,            {{_, _}, {}}];                    extendPaths @@@ nexts          ];             Reap[Scan[extendPaths[#, {}] &, VertexList@graph]] /.         {{Null, {}} -> {}, {Null, {words : {__String}}} :> Union@words}]]      The performance is sort of acceptable (it takes about 3 seconds to find all the words in the sample board), but the entire approach I'm taking here seems very ugly. In particular, the repeated use of `NeighborhoodGraph` to find adjacent vertices in the recursion for `extendPaths` seems faintly ridiculous, and the whole approach feels quite low-level compared to some of the other graph functions. Can anyone suggest some possible ways to speed this up? **EDIT** : Part of what I'm interested in seeing is whether _Mathematica's_ graph functions are a good fit for this problem, though of course I'm happy to see the good, fast implementations that people have posted.