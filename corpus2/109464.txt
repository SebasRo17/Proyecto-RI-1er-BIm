I'm writing an API for an open source network monitoring system which is licensed under the GPLv2. I also intend to open source this API but would like to license it under the BSD License.   * I don't re-use or link to any of the code in this system and I don't use any header files.    * I will not be re-distributing any part of the network monitoring code.    * Part of my application will install into the network monitoring installation folders, but not replace, remove or modify any of its files My hook into the system is via:   * existing MySQL databases belonging to the service, my API reads and writes to these databases directly. My concern here would be that whilst I am not copying their SQL statements, there are some complex operations. I've found that in a couple of cases I've arrived at SQL statements or sequences of work that aren't too dissimilar to theirs, it's hard not to.   * I talk to a pipe to issue various commands and submit data directly into the checking engine. This pipe is documented by the author as an official mechanism to communicate with the checking engine. The command pipe uses single line strings to issue commands, the pipe does not return any data, it's "fire and forget".   * There are a number of HTTP CGI scripts in the system from which I can scrape status information. I may use these in a future release. Is this considered "arms length" enough for me to license my code under a different license? i.e. > http://www.gnu.org/licenses/gpl-faq.html#MereAggregation > > However, in many cases you can distribute the GPL-covered software alongside > your proprietary system. To do this validly, you must make sure that the > free and non-free programs communicate at arms length, that they are not > combined in a way that would make them effectively a single program. Would reading and writing rows to a database be considered "exchanging complex internal data structures"? > http://www.gnu.org/licenses/gpl-faq.html#MereAggregation > > By contrast, pipes, sockets and command-line arguments are communication > mechanisms normally used between two separate programs. So when they are > used for communication, the modules normally are separate programs. But if > the semantics of the communication are intimate enough, **exchanging complex > internal data structures** , that too could be a basis to consider the two > parts as combined into a larger program.