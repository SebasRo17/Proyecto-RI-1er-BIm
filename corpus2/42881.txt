In short, my question is the same as my previous one except that everything is now wrapped up in a module. The relevant code I'm working with is:               getinter[a_, b_, u0_, k_, m_, hbar_, Nu_, Np_, up_] :=          Module[{ekp, ms, LUs, env, eenv, envpart, f, kppart, g, approx,         approx1, papprox, approx2, hard, ereal, psiparts, real, real1,         realp, real2, er, inter},            ekp = energies[a, b, u0, k, 1, m, hbar, 0.001, 10^-15][[1]];            ms = effmass[a, b, u0, k, 0.2, 1, m, hbar, 0.001, 10^-15];            LUs = BuildLUs[a, b, Nu, Np, u0, up];            env[x_] := Abs[Det[envfunc[ms, hbar, x, up, Nu, Np, a, b]]]^2;            eenv = zeros[env, up + 0.000001, 0.01, 0, 1, 10^-15, 0.02][[1]];            envpart = getpsipieces[LUs[[1]], LUs[[2]], eenv, ms, hbar];            f[x_] := Evaluate@Piecewise[envpart];            Return[f[0.231]];          ]      envpart is a properly formatted object for piecewise and the variable it uses is named x. When I evaluate this, it's returning the structure I put into piecewise but now formatted as a case structure as opposed to an array. What I'd like it to do is to return f[0.231]='some number' like you would expect. Also, f[x_]:= Evaluate@Piecewise[envpart]; works fine if I take it out of the module. Thanks for the help. Also, I get the sense that the solution to this problem, if I fully understand it, will allow me to work out a lot of other problems I encounter, so I'd really appreciate any suggestions on where I can learn about the issues at play. Edited for slightly less awful formatting.