I have to add common functionality to some classes that share the same superclass, preferably without bloating the superclass. The simplified inheritance chain looks like this:               Element -> HTMLElement -> HTMLAnchorElement     Element -> SVGElement -> SVGAlement      The default `doSomething()` method on `Element` is no-op by default, but there are some subclasses that need an actual implementation that requires some extra overridden methods and instance members. I cannot put a full implementation of `doSomething()` in `Element` because 1) it is only relevant for some of the subclasses, 2) its implementation has a performance impact and 3) it depends on a method that could be overridden by a class in the inheritance chain between the superclass and a subclass, e.g. `SVGElement` in my example. Especially because of the third point, I wanted to solve the problem using a template class, as follows (it is a kind of decorator for classes):               struct Element {         virtual void doSomething() {}     };          // T should be an instance of Element     template<class T>     struct AugmentedElement : public T {         // doSomething is expensive and uses T         virtual void doSomething() override {}         // Used by doSomething         virtual bool shouldDoSomething() = 0;     };          class SVGElement : public Element { /* ... */ };     class SVGAElement : public AugmentedElement<SVGElement> {         // some non-trivial check         bool shouldDoSomething() { /* ... */ return true; }     };     // Similarly for HTMLAElement and others      I looked around (in the existing (huge) codebase and on the internet), but didn't find any similar code snippets, let alone an evaluation of the effectiveness and pitfalls of this approach. Is my design the right way to go, or is there a better way to add common functionality to some subclasses of a given superclass?