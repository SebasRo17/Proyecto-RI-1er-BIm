In a couple of months a colleague will be moving on to a new project and I will be inheriting one of his projects. To prepare, I have already ordered Michael Feathers' _Working Effectively with Legacy Code_. But this books as well as most questions on legacy code I found so far are concerned with the case of inheriting code as-is. But in this case I actually have access to the original developer and we do have some time for an orderly hand-over. Some background on the piece of code I will be inheriting:   * **It's functioning:** There are no known bugs, but as performance requirements keep going up, some optimizations will become necessary in the not too distant future.   * **Undocumented:** There is pretty much zero documentation at the method and class level. What the code is supposed to do at a higher level, though, is well-understood, because I have been writing against its API (as a black-box) for years.   * **Only higher-level integration tests:** There are only integration tests testing proper interaction with other components via the API (again, black-box).   * **Very low-level, optimized for speed:** Because this code is central to an entire system of applications, a lot of it has been optimized several times over the years and is extremely low-level (one part has its own memory manager for certain structs/records).   * **Concurrent and lock-free:** While I am very familiar with concurrent and lock-free programming and have actually contributed a few pieces to this code, this adds another layer of complexity.   * **Large codebase:** This particular project is more than ten thousand lines of code, so there is no way I will be able to have everything explained to me.   * **Written in Delphi:** I'm just going to put this out there, although I don't believe the language to be germane to the question, as I believe this type of problem to be language-agnostic. I was wondering how the time until his departure would best be spent. Here are a couple of ideas:   * **Get everything to build on my machine:** Even though everything should be checked into source code control, who hasn't forgotten to check in a file once in a while, so this should probably be the first order of business.   * **More tests:** While I would like more class-level unit tests so that when I will be making changes, any bugs I introduce can be caught early on, the code as it is now is not testable (huge classes, long methods, too many mutual dependencies).   * **What to document:** I think for starters it would be best to focus documentation on those areas in the code that would otherwise be difficult to understand e.g. because of their low-level/highly optimized nature. I am afraid there are a couple of things in there that might look ugly and in need of refactoring/rewriting, but are actually optimizations that have been out in there for a good reason that I might miss (cf. Joel Spolsky, _Things You Should Never Do, Part I_ )   * **How to document:** I think some class diagrams of the architecture and sequence diagrams of critical functions accompanied by some prose would be best.   * **Who to document:** I was wondering what would be better, to have him write the documentation or have him explain it to me, so I can write the documentation. I am afraid, that things that are obvious to him but not me would otherwise not be covered properly.   * **Refactoring using pair-programming:** This might not be possible to do due to time constraints, but maybe I could refactor some of his code to make it more maintainable while he was still around to provide input on why things are the way they are. Please comment on and add to this. Since there isn't enough time to do all of this, I am particularly interested in how you would prioritize. _Update:_ As the hand-over project is over I have expanded this list with my own experiences in this answer below.