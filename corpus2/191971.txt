The scope: it is part of a big ERP system which provides specific calculations. One can think of it as a salary calculation module in a CRM. Yet this is way beyond that in both complexity and integration points. Thus, there are a lot of technological debt, but not unmaintanable one. There some some unit/integration tests written. It _is_ testable, but it wasn't done much. It is an old part of that ERP system (3 years old), over the years it had mutated into what it is now, and there are willingness to try to complete it even if it costs some major efforts. The problem: the scope which provides a lot of various calculations based on a specific list of objects and the outcomes are not right sometimes. There are a lot of interesting (not so common) features about this scope:   * Dynamic C# formullas (loaded to context and then included in calculcations)   * A lot of reports doing the same calculations but on the database   * The scope is unstable and period-intense (new features and bugfixes are shipped every month) This scope has a lot of input parameters on all of the dependant objects. By multiplying all the possible parameter values we have 1,62*107 cases of possible outputs. Not all the parameters warry that much, but most of them do. So slicing half of that number is something around the practical possible otucomes. This scope is eating up a lot of time and money and is far from done in its current form. I would like to know what is ~~the silver bullet to~~ the most viable way to stabilize and finish the scope to the state where only minor bugs and nice to haves will occur? First of all I was thinking, that establishing a DoD (Definition of Done) would be a relevant thing to do. Then I came up to the fact that having that huge number of outputs working is half of that - everything must also be flexible on the UI scope as well. Will it be enoguh to establish a test plan, maybe do some bruteforcing tests? Should I consider any kind of design patterns? Validation options (like a solid third party validation service, etc.)? Will it be enough or maybe I have gaps in my modest knowledge that I should fill? _Note: the application is not what would one call monolithic. It is based on a lot of different services that can be easily extended, etc._