**2nd Edition** : To make it a bit more clear, and to summarize the discussion in comments. **I have a small image** , like this one:               InsertImage =       DensityPlot[Sqrt[1 - x^2 - y^2], {x, -1, 1}, {y, -1, 1},        Frame -> False,        ColorFunction -> (Opacity[Max[Re[#], 0],            GrayLevel[Max[Re[#], 0]]] &), ImageSize -> 40,        Background -> Opacity[0, Black]]      It is just a semi-transparent gray ball: ![enter image description here](http://i.stack.imgur.com/JsouH.jpg) Outside the ball you see white - because of transparency. **I have a big background** , like this one:               InsertIntoImage = Image[GrayLevel[0], ImageSize -> 400];      It is just big black background. **I want to insert the small image into the big one many-many times** , e.g. at these scaled positions:               PosList = {Cos[Pi #], Sin[4 Pi #]}^2 & /@ Range[0, 1, 0.005];      Vaguely, the result should be like:               Rasterize[       Graphics[{Inset[InsertIntoImage],          Inset[InsertImage, Scaled[#]] & /@ PosList},         ImageSize -> 400]] // AbsoluteTiming      ![enter image description here](http://i.stack.imgur.com/Vr41C.jpg) **Ideally** :   1. I want to add up only grayscale channels of big and small images.   2. Small images are to be added really many times - it is for video production, and the above example is a very light version of it.   3. I want to make it work fast for many more images at a time: Inset is way too slow. **Question: How to do it with CUDA?** **Notes on CUDA (why CUDA)** :   1. It should work much faster. Note, the overhead of caching one small image is negligible.   2. I can't seem to find an appropriate inbuilt function: CUDAImageAss[] uses only images of similar size.   3. Putting small images pixel by pixel in matrix form is not very much to my liking. I want to be able to specify small image positions at subpixel accuracy. Normally, this would smear each pixel of each small image with a pointspread function. It is doable, but I believe there must be existing algorithms.   4. Such a problem must have been solved a thousand times, e.g. in videogames, movie production, etc. Note, that GPUs in videogames allow rendering in realtime, hence this approach should work fast here too.