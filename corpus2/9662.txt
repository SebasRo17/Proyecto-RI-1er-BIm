## Background A word is a string of letters in an alphabet. A square-free word has no adjacent repeating substring. For example, (in the ternary alphabet of {0,1,2}) the words 00, 012121, and 0212012021 are all not square-free because they contain repeated subwords, but a word like 1201021 or 0102012021 is square-free. Here is code to test if a string over the alphabet {0,1,2} is square-free, but it is too slow:               ReverseWord[w_String] :=             StringReverse[w];     PermuteWord[w_String] :=             StringReplace[w, {"0" -> "1", "1" -> "2", "2" -> "0"}];     SubWords[w_String, len_Integer] :=             Module[{i}, Union[Table[StringTake[w, {i, i + len - 1}],            {i, StringLength[w] - len + 1}]]];     NoSquare[w_String] /; Mod[StringLength[w], 2] == 0 :=             (StringTake[#, StringLength[#]/2] =!=StringTake[#, -StringLength[#]/2]) &[w];     SquareFree[w_String] :=             Apply[And, Table[Apply[And, Map[NoSquare, SubWords[w, k]]],                              {k, 2, StringLength[w], 2}]];          SquareFree["0101"] (* returns False *)     SquareFree["0102012021"] (* returns True *)      I'm sure there are some wizards out there that knows the fastest way to do this! Here is a big squarefree word to test your fast functions on:               benchmark = Uncompress@"1:eJzt0sEJgDAQRNGUoh3sbinagQ3Y/\     03ISYIQQoSvzJ5UIknm7azHue1lKcXcws2jPuP2bvUrHtdj8P92vd3n7fN7+3/9/rPnz/\     rQ9//7/Gl/Oj/dH9qf9sv5a/vT+en+0P60X85f25/OT/dH3Z/OT/dH3Z/OT/\     eH9qf9cv7a/nR+uj+0P+2X89f2p/PT/aH9ab+cv7Y/nZ/uj7o/nZ/uj7r/\     wP0uYjwiEQ==";      ## Problem The ultimate way to determine square-freeness of words is to enumerate them! So the real problem is to generate all ternary squarefree words of length n efficiently. Here was my original implementation: the function ExtendSquareFreeQ[w] checks if word w is squarefree assuming that StringTake[w, 1;;-2] is squarefree. Then, starting from the list AllSquareFree4, we build up the next AllSquareFree5, and so forth...               iExtendSquareFreeQ = Compile[{{str, _Integer, 1}},            Module[{sl = Length[str]/2 // Floor, i},               For[i = 2, i <= sl, i++,                  If[Take[str, {-2 i, -(i + 1)}] === Take[str, {-i, -1}],                      Return[False]]                  ];                 True                 ], CompilationTarget -> "C", RuntimeOptions -> "Speed",                  RuntimeAttributes -> {Listable}, Parallelization -> True                ];      ExtendSquareFreeQ[str_String] := iExtendSquareFreeQ[ToCharacterCode[str]];       DistributeDefinitions[ExtendSquareFreeQ];           ExtendAllSquareFree[list_] := Module[             {cand, sfcand},              cand = Flatten @ Map[                 Function[w,                     Function[s, StringJoin[w, s]] /@                      Complement[{"0", "1", "2"}, {StringTake[w, -1]}]                     ],                     list               ];               sfcand = ParallelMap[ExtendSquareFreeQ, cand];               Pick[cand, sfcand]           ];          AllSquareFree2 = {"01"};     temp = AllSquareFree2;     byteCounts = {};     times = {};     Monitor[Table[       {time, temp} = AbsoluteTiming[ExtendAllSquareFree[temp]];       temps = Compress@temp;       AppendTo[times, time];       AppendTo[byteCounts, ByteCount[temps]/1000000];, {n, 2, 111}],       ListPlot[{times, byteCounts}, Mesh -> Full,        PlotRange -> {Automatic, All}, Filling -> Axis,       AxesLabel -> {"n", None}, InterpolationOrder -> 2, Joined -> True,        PlotLabel -> Text@Row[{           "n: " <> ToString[n],           "count: " <> ToString[Length[temp]*6],           "time: " <> ToString[N[time, 2]] <> " s",           "mem: " <> ToString[N[byteCounts // Last, 2]] <> " mB"},           " | "]]]       But both the time and memory complexities are way too high for $n>60$. Is there a much more efficient way to perform this search? Perhaps storing the lists of strings in special data structures and traverse them in fancy ways? I'll take any solutions of linear or quadratic complexity, or that can reach $n >= 111.$ **The main difficulty is that when storing all the words of length 63 _Mathematica_ runs out of memory!** I was hoping for some brilliant optimized data structures, but I guess I might just have to use a tree...