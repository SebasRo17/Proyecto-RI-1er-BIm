I am not sure if the title is appropriate. I have written a parser for CDB files in C# and ANTLR that creates runtime objects for me such that I can pass it to the TCF Agent which takes care of everything that needs to be taken care of on the side of Eclipse. Such a CDB file consists of Symbol Records, Function Records, Module Records and also Type Records and so on. It describes a C program compiled with SDCC. I already have a good structure for local variables which debug information I can retrieve by resolving an ID that consists of   * **scope_flag** Indicates the scope of the symbol: `L` local, `G`global, `F`File, ...   * **module_base** The address of the modules where the local variable is declared   * **level** and **level** A tupel that points to a node of a tree where each node is a scope `{ .. }`. It doesn't matter if it is a function scope or a control command (`if`, `for`, etc.)   * **index** The index of the symbol inside a node (Therefore it is an ordered list) This works and should be fast enough even for large programs. If Eclipse wants to know anything about a symbol wheter it's the name, type or value it sends me an ID that looks something like this (values in hex):               L@C415.E.1.1      and I can identify the symbol in my parser. The main problem I got now are global symbols like global variables, function names and so on. At the moment I have a `Dictionary<T>` that maps the name of a symbol to its runtime object:               /* Dictionary that holds all global-scoped symbols. */     private Dictionary<String, CDBSymbol> m_nameToGlobalSymbolDict = new Dictionary<String, CDBSymbol>();      Now consider a very large program where a lot of global symbols may occur. Is such a large hash-table the best I can do? At the moment a global symbol ID looks like these:               G@function_name1     G@global_integer1     G@function_name2      The only thing that I might could do would be to add identifiers for functions, variables etc. like               G@C.function_name1     G@E.global_integer1     G@C.function_name2      where `C` means code and `E` internal RAM but that would only allow me to split the hash-table and nothing else. Can anybody suggest me a solution or tell me if this is already okey the way I'm doing it? I hope it is clear what I am asking for. If not please let me know.