The problem I continually face is how to deal with computed values driven by domain logic while still working efficiently against the data store. Example: I'm returning a list of Products from my repository via a service. This list is limited by pagination info from request DTO sent by the client. In addition, the DTO specifies a sort parameter (a client-friendly enum). In a simple scenario, everything works great: the service sends paging and sorting expressions to the repo and the repo issues an efficient query to the DB. That all breaks down, however, when I need to sort on values generated in memory from my domain model. For instance the Product class has an IsExpired() method that returns a bool based on business logic. Now I can't sort and page at the repo level --it would all have be done in memory (inefficient) and my service would have to know the intricacies of when to issue these params to the repo and when to perform sorting/paging itself. The only pattern that seems to make sense to me is to store the state of the entity in the db (make IsExpired() a readonly field and update it via the domain logic before saving). If I separate this logic into a separate "read model/dto" and "reporting" repository, I'm making my model more anemic than I'd like to. BTW, every example I've seen out there for computations like this really seems to lean on in-memory processing and glossing over the fact that it is far less efficient in the long run. Maybe I'm prematurely optimizing, but that just doesn't sit right with me. I'd love to hear how others have dealt with this as I'm sure it's common on nearly project involving DDD.