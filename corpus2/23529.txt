Yesterday I had an issue that kept for quite a while. My code wasn't producing the right results. Now I know why and I am wondering how to avoid the issue in future. Consider the following code.               Clear[fAux];     fAux[i_] := fAux[i] = NDSolve[{y'[x] == Sin[y[x]^i], y[0] == 1}, y, {x, 0, Pi}][[1, 1, 2]];     f[i_, z_] := fAux[i][z];      Here, `f` returns the value of the solution of a ODE with parameter `i` at the value `z`. The solution of the ODE (an interpolating function) is memoized. You can convince yourself that it works fine by evaluating `f[1,1.5]` for example. Now I want to evalute this:               Table[f[2, x], {x, 0, 3}]      and I get an error message > "NDSolve::dsvar: 0 cannot be used as a variable." as well as unexpected results: > {Sin[y[0]^2][0], Sin[y[0]^2][1], Sin[y[0]^2][2], Sin[y[0]^2][3]} Looking at the down values of `fAux` you can see some strange things:               DownValues[fAux]      > {HoldPattern[fAux[1]] :> InterpolatingFunction[{{0.`, > 3.141592653589793`}},"<>"],   >  HoldPattern[fAux[2]] :> Sin[y[0]^2],   >  HoldPattern[fAux[i_]] :> (fAux[i] = NDSolve[{(y^\\[Prime])[x] == > Sin[y[x]^i], y[0] == 1}, y, {x, 0, \\[Pi]}][[1,1,2]])} The culprit is the name of the iterator in the `Table` function. It has the same name, `x`, as the dummy variable in `NDSolve`. If you replace either with `xx` for instance, everything works as expected. I find this very confusing and dangerous, to keep track of what name you gave to which iterator variable throughout the entire notebook. I'm not even sure how this would behave across packages you call from within the notebook. Is this a wanted behavior? How can I make sure I won't make the same mistake again?