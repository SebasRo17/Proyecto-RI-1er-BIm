As we know, The SRP states that every class should have single responsibility and that responsibility must be entirely encapsulated by the class. But setters and getters do serve another responsibility - they do abstract class property(data) access. if _Setters and getters_ do abstract class property access, then **they do serve another responsibility**. So if I have something like this,               class Config     {              private location;                   public function write(array $data)         {             ....         }              public function read($key)         {             ...         }              public function exists($key)         {             ...         }              public function delete($key)         {             ...         }              // Below comes property abstraction              // Here I doubt - I CANNOT USE this class without them         // but they seem to break the SRP at the same time!?              public function setFileLocation($location)         {             $this->location = $location;         }                   public function getFileLocation()         {             return $this->location;         }                   public function setConfigArray(...)         {             ...         }              public function getConfigArray()         {             ...         }     }      I do break the SRP. The problem is that, that's the only way class may exists. So the question is, In my situation, it's almost impossible to avoid `setFileLocation()` and `getFileLocation()` methods with CRUD ones. So if by combining CRUD methods with Data Access abstraction I do break the SRP, Is there any way I can adhere the SRP and keep the common concept of the Config class (CRUD operations) at the same time?