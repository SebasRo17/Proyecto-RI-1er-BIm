Going through Modulo operation (the avenue I entered while exploring the difference between `rem` and `mod`) I came across: > In mathematics the result of the modulo operation is the remainder of the > Euclidean division. However, other conventions are possible. Computers and > calculators have various ways of storing and representing numbers; thus > their definition of the modulo operation depends on the programming language > and/or the underlying hardware. Questions:   * Going through Euclidean division I found that remainnder of this operation is always positive (or 0). What limitation of the underlying computer hardware forces programming language designers to differ from mathematics?   * Every programming language has it predefined, or undefined, rule according to which the result of the modulo operation gets it's sign. What rationale is adopted while making these rules? And if the underlying hardware is the concern then shouldn't rules change according to that, independent of programming language?