I am interpolating a lot of data over geographic coordinates obtained via GPS, and frequently I need to plot these interpolated functions together. For example, I may have an interpolated elevation map that looks like this:               f0 = InterpolatingFunction[{{x0min, x0max},{y0min, y0max}}, <>]      and several other interpolated functions of other data sets that stretch over subregions of the rectangle `{{x0min, x0max}, {y0min, y0max}}`. So, say,               f1 = InterpolatingFunction[{{x1min, x1max},{y1min, y1max}}, <>]      where `{{x1min, x1max}, {y1min, y1max}}` lies entirely within `{{x0min, x0max}, {y0min, y0max}}` and so on. I need to plot these interpolated functions A LOT and in attempts to change the visualisations of my data sets, I need an efficient way to extract their limits and pass them on to plotting functions. For this I have written the following function:               intLimits[intF_ /; (Head@intF === InterpolatingFunction), x_: x, y_: y] :=           Module[{ArgList},             ArgList = First@intF;             Which[Length@ArgList < 2,                   ArgList~Prepend~x,                   Length@ArgList == 2,                   {First@ArgList~Prepend~x, Last@ArgList~Prepend~y}             ]           ]      which I use with plotting functions like so               f0plot= Plot3D[f0[x,y], Evaluate@First@intLimits[f0], Evaluate@Last@intLimits[f0]];     f1plot= Plot3D[f1[x,y], Evaluate@First@intLimits[f1], Evaluate@Last@intLimits[f1]];      This works well if used to plot a list of interpolation functions (replacing `f0` with `#` and mapping at the list) but it seems a bit ugly and the length of adding `Evaluate@First@intLimits` doesn't help with the readability of my notebook although seems necessary given the `HoldAll` `Attribute` of all plotting functions. So my question is: is there a more clever way to define the function `intLimits` or a better way in general to be able to pass on the range of variables of interpolated functions to plotting functions?