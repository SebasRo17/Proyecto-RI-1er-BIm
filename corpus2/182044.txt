I'm solving a graph-search optimization problem. I need to find the k best acyclic shortest-paths through a directed weighted graph. I know there are a number of exact and approximate k-best algorithms, but most of the recent research seems to be oriented toward very large, very sparsely- connected graphs (e.g. road routing and directions), and my graph is neither. Distinguishing aspects of my problem:   * The graph consists of approximately 160 vertices.   * The graph is nearly fully connected (bidirectionally, so ~160^2 ~= 25k edges)   * k will be quite small (probably less than 10)   * The maximum path length will probably be bounded and very small as well (e.g. 3-5 edges)   * I said 'acyclic' above, but just to reiterate - solutions must not include cycles. This isn't an issue for 1-best shortest path, but it becomes a problem for k-best - for example, consider a road routing - the 2nd shortest path from A to B might be the same as the 1-best, with a quick trip around a block somewhere. That's might be mathematically optimal, but not a very useful solution. ;-)   * We may need to re-weight edges on-the-fly for each calculation. An edge cost consists of a weighted sum of several factors, and the final requirements (whenever we get them) may allow a user to specify their own prioritization of those weighting factors, altering edge weights. This is a relatively small graph (we should be able to represent it in a few hundred KB), so it's probably reasonable to clone the graph in memory, apply the re-weighting, and then execute the search on the cloned graph. But if there's a more effective method of performing the search while computing weights on-the-fly, I'm interested. I'm looking at the algorithms described in Santos (K shortest path algorithms), Eppstein 1997 (Finding the k Shortest Paths), and others. Yen's algorithm is of interest, primarily because of the existing Java implementation. I'm not scared to read the research papers, but I thought it was worth throwing out the details of my problem and asking for pointers to save some reading time. And if you have pointers to Java implementations, even better.