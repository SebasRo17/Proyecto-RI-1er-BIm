I often find myself in situations where I, for example, need to build a table for some expression, but want to set the number of points rather then the step size, so the code ends up looking like this               lower = 0.2;     upper = Pi^2;     points = 100;     Table[Sin[x], {x, lower, upper, (upper - lower)/(points - 1)}] // ListPlot      I think that the typical Table syntax is much nicer in cases where we want to set the stepsize, but would much rather prefer to just think of the iteration specifications to be of the form {var,min,max,num} in these cases. Initially I though I would to this by just defining a function that takes this other iteration specification and returns the traditional equivalent, but since Table has holdall, you'd need to wrap everything in Evaluate which isn't pretty either example:               myIter[L_]:={L[[1]],L[[2]],L[[3]],(L[[3]]-L[[2]])/L[[4]]}     Table[Sin[x], Evaluate@myIter[{x, 0.2, Pi^2, 100}]] // ListPlot      So to get around this I added a pattern to modify the way Table is called if the second argument was wrapped in linIter:               linIter /: Table[exp_, iterator_linIter] := Table[exp, Evaluate@myIter[List @@ iterator]]     Table[Sin[x], linIter[x, 0.2, Pi^2, 100]] // ListPlot      This then allows me to have somewhat nice syntax to specify a new iterator. So my questions are   * Whether others have a more elegant way of implementing this, that allows one to call the expression with multiple iterators mixing step size and number based?   * What capabilities of `Table` I might possibly be losing by calling it this way?   * Is it possible to retain the syntax highlighting of `Table` while doing this?   * Also I'd appreciate general feedback. Am I committing blasphemy by messing with the call syntax for a built-in, or is would you easily get the intention if you where reading though some code that relied on this type of tricks to sort of have custom iterators?