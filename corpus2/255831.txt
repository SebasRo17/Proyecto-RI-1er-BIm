So far, I have used the **MVP** architecture pattern a few times. Every now and then, I wonder whether my `Presenter` should depend on my `View` or vice versa, that is the `View` depends on my `Presenter`. **NOTE** > Though the sample code provided is in C#, I don't mind about the language. > My question targets more precisely the **MVP** pattern. Additionally, it was > provided off the top of my head solely to help illustrate my concern. It may > not compile. Here's a short sample of what I'm used to do:               public interface IHasUiHandler<H> where H : IUiHandler {         H Handler { set; }     }          public interface IView {         void Close();         void Hide();         void Show();     }          public abstract class Presenter<V> where V : IView {         protected Presenter(V view) { this.view = view; }              public void CloseView() { view.Close(); }         public void HideView() { view.Hide(); }         public void ShowView() { view.Show(); }              private readonly V view;     }      And let's say I'm creating a Customer Management feature.               public interface ICustomerManagementUiHandler : IUiHandler {         Customer CreateNewCustomer();         IList<Customer> ListCustomers();         void RemoveCustomer(Customer customer);         Customer UpdateCustomer(Customer customer);     }              public class CustomerManagementPresenter : Presenter<ICustomerManagementView>                                              , ICustomerManagementUiHandler {         public CustomerManagementPresenter(ICustomerManagementView view             , CustomerManagementService service)              : base(view) {             view.Handler = this;             customers = service;         }              public Customer ChangeExistingCustomer(Customer customer) { return customers.Update(customer); }         public Customer CreateNewCustomer(Customer customer) { return customers.Add(customer); }         public IList<Customer> ListCustomers() { return customers.List(); }         public void RemoveCustomer(Customer customer) { customers.Remove(customer); }              private readonly CustomerManagementService customers;     }          public interface ICustomerManagementView : IHasUiHandler<ICustomerManagementUiHandler> {             }          public class CustomerManagementForm : Form, ICustomerManagementView {         public CustomerManagementForm() { }              public ICustomerManagementUiHandler Handler {              private get { return handler; }              set { if (handler == null) handler = value; }          }              private void changeCustomerButton_Click(object sender, EventArgs e) {             if (Handler == null)                  throw new InvalidOperationException("Can't change customer. No handler specified.");             Handler.ChangeExistingCustomer(current);         }              private void createCustomerButton_Click(object sender, EventArgs e) {                                     if (Handler == null)                  throw new InvalidOperationException("Can't add new customer. No handler specified.");             Handler.CreateNewCustomer(); // No parameters for sample simplicity sake.         }              private void deleteCustomerButton_Click(object sender, EventArgs e) {             if (Handler == null)                  throw new InvalidOperationException("Can't add new customer. No handler specified.");             Handler.RemoveCustomer(current);          }              private readonly ICustomerManager manager;         private ICustomerManagementUiHandler handler;     }      I feel like the `View` should depend on the presenter, so that there would be no need for a `Handler` property in the `View` itself. Then the `Presenter` could depend on the data access service or the like to handle the business entities and the like. This would wave away the **Method Injection**, which is a benefit, IMHO. Plus it seems to reduce complexity for waving away both the `IHasUiHandler` and `IUiHandler` interfaces. This makes it a easily testable code because the `Presenter` is an easily-tested class. However, this way I'm afraid that the `Presenter` has no real handle over the view which it should be able to either show or hide. So this is where I'm growing confused about which shall depend on which.