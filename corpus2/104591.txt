We use Integer type represent index variables most of the time. But in some situations, we're forced to choose               std::vector<int> vec;     ....          for(int i = 0; i < vec.size(); ++i)     ....      This will cause the compiler to raise the warning that mixed use of signed/unsigned variables. if I make the index variable as `for( size_t i = 0; i < vec.size(); i++ )`, (or an `unsigned int` )it will sort out the issues. When it come more specific to use windows types, most of the Windows APIs are dealing with DWORD (which typedef-ed as unsigned long). So when I use similar iteration, will again cause the same warning. Now if I rewrite it as               DWORD dwCount;     ....          for(DWORD i = 0; i < dwCount; ++i)     ....      I find this a bit weird. It might be the problem withe perceptions. I agree that we are supposed to use the same type of index variable to avoid the range problems can happen with the index variables. For e.g if we're using               _int64 i64Count; //      ....          for(_int64 i = 0; i < i64Count; ++i)     ....      But in the case of DWORD, or unsigned integers, are there any problems in rewriting it as               for(int i = 0; (size_t)i < vec.size(); ++i)      How most of the people are working with similar issues?