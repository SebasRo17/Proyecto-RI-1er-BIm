I was doing the first exercise in the paper Lattice QCD for Novices. This is the expected result: ![enter image description here](http://i.stack.imgur.com/Lo3sD.png) With the default "GlobalAdaptive" method for NIntegrate it threw errors saying that the error had increased more than 2000 times, so I switched to "LocalAdaptive". The result had some jitters, but was recognizable. ![enter image description here](http://i.stack.imgur.com/GnEwt.png) I decided to go back to "GlobalAdaptive" despite the warnings and slower time, and it actually looks really good despite the warnings. ![enter image description here](http://i.stack.imgur.com/RXlEw.png) However, the documentation says global adaptive is generally faster for multidimensional integrals. I'm looking for insight for why it is not true in this case, and in general, any settings that would give a better and faster result. I'm just getting into the options for the Monte Carlo methods. Here's the code:               stepSize = 1/2; stepCount = 8; potential[x_] := x^2/2; mass = 1;          action[x_List] :=       Sum[mass/(2 stepSize) (x[[j + 1]] - x[[j]])^2 +         stepSize potential[x[[j]]], {j, stepCount}]          ListLinePlot@      ParallelTable[       NIntegrate @@         Join[{E^-action[Join[{b}, Table[x[i], {i, stepCount - 1}], {b}]]},          Table[{x[i], -5, 5}, {i, stepCount - 1}], {Method ->            "LocalAdaptive"}], {b, 0, 2, .2}]          ListLinePlot@      ParallelTable[       Quiet[NIntegrate @@          Join[{E^-action[Join[{b}, Table[x[i], {i, stepCount - 1}], {b}]]},           Table[{x[i], -5, 5}, {i, stepCount - 1}]]], {b, 0, 2, .2}]