Quite recently, I thought about the use of `as`, `is` and direct cast in C#. Logically, is it a better idea to use :                var castedValue = value as type;      if (null != castedValue)      {          // Use castedValue.      }      than :               if (value is type)     {         var castedValue = (type)value;         // Use castedValue.     }      But I still have issues when dealing with this kind of pattern:               if (value is Implementation1)     {         var castedValue = (Implementation1)value;         // Use castedValue in a first way.     }     else if (value is Implementation2)     {         var castedValue = (Implementation2)value;         // Use castedValue in a second way.     }     else if (value is Implementation3)     {         var castedValue = (Implementation3)value;         // Use castedValue in a thrid way.     }     // And so on...      How can I improve this code to prevent casting two times when OK, and is it really necessary to cast twice? I don't want to make the code unreadable, but the idea is not to test a cast if a previous one succeeded. I had several ideas to fix this, but none of them seems to really satisfy the conditions... **Edit:** Here is a case I've got... There is this object that is created by a lower part of teh code I do not have control on. This object can be of several inherited types. In my layer, I do want to create a specific object depending on this type. I do have this constructor class:               public static IHighLevelObject MakeHighLevelObject(LowLevelObject lowLevelObject)     {         IHighLevelObject highLevelObject;              if (lowLevelObject is LowLevelObject1)         {             highLevelObject = new HighLevelObject1((LowLevelObject1)lowLevelObject);         }         else if (lowLevelObject is LowLevelObject2)         {             highLevelObject = new HighLevelObject2((LowLevelObject2)lowLevelObject);         }         else if (lowLevelObject is LowLevelObject3)         {             highLevelObject = new HighLevelObject3((LowLevelObject3)lowLevelObject);         }         // And so on...              return highLevelObject;     }      How do I solve this case ?