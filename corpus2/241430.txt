In a project I decided to implement the Decorator pattern. I have a class `Thing` with `methodA()`, and a class `AbstractDecorator` that inherits from `Thing` and that all decorators inherit from: `ConcreteDecorator1`, `ConcreteDecorator2`, etc. All of them of course override `methodA()` to add some functionality before delegating to the wrapped `Thing`. Usual Decorator implementation. I decided to implement a `WrappingFactory` (for a lack of a better name): it receives `Thing` objects and wraps them with a specified decorator. Some of the decorators require a parameter in the constructor, and `WrappingFactory` takes care of that too. Here it is:               public class WrappingFactory{              public static void addSomeFunctionality(Thing thing){             thing = new SomeDecorator(thing);         }              public static void addFunctionalityWithParameter(Thing thing, int param){             thing = new DecoratorWithParameter(thing, param);         }              public static void addSomeAwesomeFunctionality(Thing thing){             thing = new AwesomeDecorator(thing);         }          }      I did this but actually I don't know why. Does this have benefits as opposed to having the client instantiate decorators directly? If this has benefits, please explain them to me.