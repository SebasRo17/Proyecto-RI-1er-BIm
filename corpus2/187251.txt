If I wanted to implement my own version of the std::exception for no good reason, are there any special things about implementing this kind of object that I should be aware of? It seems like a fairly simple thing that is mostly a string wrapper... Here is my implementation so far:               #pragma once;          #include <string>          class MyException     {     public:         MyException(const std::wstring&);         virtual ~MyException(){}              virtual MyException& operator=(const MyException& rhs);         virtual const std::wstring& what(){return msg;};          private:         std::wstring msg;     };          MyException::MyException(const std::wstring& message)     :msg(message)     {     }          MyException& MyException::operator=(const MyException& rhs)     {         if(this == &rhs)         {             return *this;         }         msg = rhs.msg;         return *this;     }