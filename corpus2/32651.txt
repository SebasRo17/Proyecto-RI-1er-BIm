I have a function that I want to see applied, potentially within a derivative. The use of delayed vs. non-delayed rules seems irrelevant. See the following:               f$sub = {f[c_] :> a c};          f[c] //. f$sub;          q (f[c])^2 //. f$sub;          D[f[c], c] //. f$sub;          D[f[c] //. f$sub, c] //. f$sub;          (*The following is a rough reason of why I wanted rules *)     g$sub = {g[a] :> a + f[c] }          g2$sub = {g2[a] :> a + D[f[c], c] }          g[a] //. g$sub (* Don't want f sub'd, want to see it left with the function *)          g[a] //. Union[g$sub, f$sub] (* Want f$sub used to simplify things *)          f$alt$sub = {f[c_] :> 2 a c};          g2[a] //. Union[g2$sub, f$alt$sub ](* What does it look like with the alternative *)      Ideally, I would want to see the output as `a c`, `q (a c)^2`, `a`. The last doesn't work, presumably becomes `FullForm@D[f[c],c]` is `Derivative[1][f][c]` which doesn't match the pattern. Are there any easy tricks to get the substitution to respect derivatives? My first attempt of changing the rule to `fsub = {f[c_] :> a c, Derivative[1][f][c_] :> D[f[c], c]}` didn't seem to do anything (delayed or not).