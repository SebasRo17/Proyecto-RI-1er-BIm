I'm trying to learn Scala (I have previously glanced at Erlang, Haskell, Ruby and had similar issues). I do enjoy it, but I feel bad about some things it does and I wonder if that's just due to all the time I've spent with C++. **1\. Keeping it clean** I'll start with a problem of my own. With anonymous functions and loops hidden in foreach I feel encouraged to put everything in one line. I quickly end up with something hideous. It's even worse in Ruby where variables don't need to be declared. It's a mess. I wonder if there are any guidelines that can be followed to improve readability or if this is something one just has to get use to when programming in a concise language? **2\. Basic control structures** While foreach, map, etc. methods work great in simple cases they fail me in more complex ones. Containers preserve order of objects, and in a way, these methods hide that order form me. Let's say, I want to build an array B from the elements of array A with prime indices. I could do               var i = 0     val B = A.filter( e => { i+=1; is_prime( i ) } )      but it doesn't feel right. There is a duplication of counters - one inside filter, and one of my own. I see no reason why there wouldn't be a function which knows the position of the element it is processing. Am I missing something or is there some logic behind it? Now I just feel encouraged to use the usual C style loops. **3\. Scala's hidden inconsistency** Scala seems to boast having so much of it declared in it's libraries. With all the rules Scala needs to make those libraries feel comfortable, the language becomes as big as any other, which seems like missing the point, but that isn't what bothers me. What I dislike is Tuple. With it's special syntax, it acts like a language construct rather than an ordinary class. It feels like Scala is denying that many things are built into it. I'd appreciate it if someone could explain to me why such synthesis of library and language is so often implemented (not only in Scala). **4\. Efficiency** Firstly, I understand the benefit of having immutable objects in parallel algorithms, but how often do you actually need the concurrency? There are issues with it other than shared mutable objects. My point is that concurrent design has it's limitations and using it everywhere, like functional languages seem to do, must be terribly inefficient.   Secondly, even if we do consider immutable state a necessity, some algorithms I've seen are ludicrous. I'm thinking about the ones that work with lists as head::tail. I find it hard to believe that an algorithm, described in that way can be efficient. Again, I feel encouraged to write more imperative code. Am I underestimating optimizations or should sensitive algorithms really avoid some concepts?