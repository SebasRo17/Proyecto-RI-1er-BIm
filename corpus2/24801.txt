I am trying to evaluate this integral numerically $$ \int_0^{\infty } J_0(q R) \tanh(q) \, \mathrm{d}q $$ for large values of $R$. This makes the integrand oscillate more quickly and _Mathematica_ gives incorrect answers. To deal with this I am trying to increase `MaxRecursion` in `NIntegrate`. Simply coding                With[{R = 50},             NIntegrate[BesselJ[0, q R ] Tanh[q], {q, 0, ∞},                       AccuracyGoal -> 12, PrecisionGoal -> 4, MaxRecursion -> 100]]      throws no errors but it also does not increase computation time or give the correct answer. If I set `MinRecursion` to a large value (larger than 9 - the default value in `NIntegrate`) in an attempt, I see an increase in computation time                With[{R = 50},             NIntegrate[BesselJ[0, q R ] Tanh[q], {q, 0, ∞}, AccuracyGoal -> 12, PrecisionGoal -> 4,                      MinRecursion -> 20, MaxRecursion -> 100]]      I get an error saying               NIntegrate::minmax: MinRecursion (20) is greater than MaxRecursion (9).      I find this very confusing as I implicitly set the value of `MaxRecursion` in the code and it is not 9. _Mathematica_ will allow my Min and Max Recursion if I delete the Bessel function and just have the `Tanh` in `NIntegrate`. My only thought is that this is some built-in property of `BesselJ`. _Mathematica_ will also evaluate the `BesselJ` to arbitrary precision so I see no reason to limit the number of numerical subdivisions. Does anyone know a workaround? P.S. Here is a some code which will quickly produce a plot of the integral as a function of $R$                f[R_?NumericQ] := Module[{},  NIntegrate [BesselJ[0, q R ] Tanh[q], {q, 0, ∞}]];      LogLogPlot[f[R], {R, 1, 250}, PlotPoints -> 10, MaxRecursion -> 1, AxesOrigin -> {0, 0}]      The code works up until $R$ is about 15 then gibberish for anything larger. Thanks.