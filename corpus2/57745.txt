To illustrate, say I take the following function (the reason for the square root will be apparent soon)               dist = NormalDistribution[0.5,0.1];     f[x_] := Sqrt[PDF[dist,x]];      Then I can grab the Haar wavelet to calculate coefficients like               data = Table[Evaluate@f[x], {x,0,1,1/31}]; (* 32 equally spaced points *)     dwt = DiscreteWaveletTransform[data, HaarWavelet[], 5];      If I then take squares of coefficients, because of $$ \sum _{j=J_o}^{J_1} \sum _{k\in \mathbb{Z}} \psi _{j,k}^2+\sum _{z\in \mathbb{Z}} \varphi _{J_0,k}^2\simeq \int f^2 (x) \, dx = \left\| f\right\| ^2 $$ I should get $\simeq 1.0$ as $f$ is, in this case, the square root of a probability density function. And it kind-of works; to wit:               Total[Flatten[Last[#] & /@ dwt[Automatic]]^2]/31      returns 1.0 (`dwt[Automatic]` gives you the coefficients for the inverse transform only; see here). This should be very close to `NIntegrate[Evaluate@f[x]^2, {x, 0, 1}]`, which is _0.999999_. However, note that "/31"! Where did that come from? This is: that `1/31` does not appear in the Parseval's identity but it is needed for the calculation to work (!) And if I change `HaarWavelet[]` by `DaubechiesWavelet[]`, say, then this _data sampling_ no longer works. I am even taking care of the fact that the Daubechies family has bigger support and for that I am using the following function to determine the number of points required as:               dataSize[wave_, 1] :=       Length[WaveletFilterCoefficients[wave, "PrimalLowpass"]];     dataSize[wave_, n_Integer /; n > 1] :=       2 dataSize[wave, n - 1] -        Length[WaveletFilterCoefficients[wave, "PrimalLowpass"]] + 2;      What I am doing wrong? ( _Why this?_ You may ask. For example, one could use wavelet expansions to calculate the norm (in Hilbert space) between two functions, or a function and some other approximation; instead of attempting `NIntegrate`. By the way, I am actually interested in dimensions greater than 1) **Note:** I am only interested in _orthogonal_ wavelets; Parseval's formula should be just ok as far as I know. **UPDATE** I modified `dist` to `NormalDistribution[0.5,0.5]`. In this case, one needs a longer interval `{x,-2,3}` to effectively cover $f$. In this case, the squared coefficients are added like **5**`Total[Flatten[Last[#] & /@ dwt[Automatic]]^2]/31` (note the factor 5.) This points me to the fact that the $x_i$ sample points are usually considered as in the `[0,1]` interval (if I remember correctly), therefore the final answer needs to be _rescaled_ by 5. Still... work in progress.