I want to deal with the following list.               mylist = Table[cof[i] exp[i], {i, 1, n}]; (*n is very larege *)      `exp[ ]` is a function of `{x1, x2, x3, x4, ...}` and `cof[]` doesn't depend on the variables `{x1, x2, x3, x4, ...}`. `exp[ ]` has a pattern like this, `x_ Exp[_]` (see the following example). I want to deal with this list according to some rule. That is, if `exp[k1]` can be obtained by `exp[k2]` under some permutation of the variables `{x1, x2, x3, x4, ...}`, then I delete the term `cof[k2] exp[k2]` in `mylist` and change `cof[k1]` to `(cof[k1] + cof[k2])`. It seems I should compare all the `exp[]` terms. I cannot find a way to that for this problem. Any help? Here is a simple example,               inputlist = {2 const x1 x2 Exp[2 x1 x1 + 3 x2 x2 + 2 x3 x3 - x1 x2 + x2 + cf1],                   2 x1 x3 Exp[2 x1 x1 + 2 x2 x2 + 4 x3 x3 - x1 x2  ],                  -x1 x3 Exp[2 x1 x1 + 3 x3 x3 + 2 x2 x2 - x1 x3 + x3 ],                  3 Exp[2 x1 x1 + 3 x2 x2 + 4 x3 x3 ],                  -2 Exp[4 x1 x1 + 2 x2 x2 + 3 x3 x3 ]};      The corresponding `exp[]` can be written as,               exp[1] = x1 x2 Exp[2 x1 x1 + 3 x2 x2 + 2 x3 x3 - x1 x2 + x2];     exp[2] = x1 x3 Exp[2 x1 x1 + 2 x2 x2 + 4 x3 x3 - x1 x2  ];     exp[3] = x1 x3 Exp[2 x1 x1 + 3 x3 x3 + 2 x2 x2 - x1 x3 + x3 ];     exp[4] = Exp[2 x1 x1 + 3 x2 x2 + 4 x3 x3 ];     exp[5] = Exp[4 x1 x1 + 2 x2 x2 + 3 x3 x3 ];      Based on the rule, we notice that               exp[1] /. {x1 -> x1, x2 -> x3, x3 -> x2} == exp[3];      exp[4] /. {x1 -> x2, x2 -> x3, x3 -> x1} == exp[5];      so the output list should be               outputlist = {       (2 const Exp[cf1]-1) x1 x2 Exp[2 x1 x1 + 3 x2 x2 + 2 x3 x3-x1 x2 + x2],        2 x1 x3 Exp[2 x1 x1 + 2 x2 x2 + 4 x3 x3 - x1 x2 ],       Exp[2 x1 x1 + 3 x2 x2 + 4 x3 x3]     }