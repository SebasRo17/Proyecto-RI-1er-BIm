I have "logic engine" which executes set of user configured steps. These steps are saved in the database as "Step" entities. The engine gets the first step and then executes steps until there are no more steps to execute:               public void Execute(details, data, Step firstStep)     {         var step = firstStep;         while (null != step)         {             step = step.Execute(details, data);         }     }      The different types of steps are expressed as derived classes. Each of them must implement the Execute method. The data and details parameters are used by the step to execute some logic. As fas as the logic engine knows it is just executing step after step without any knowledge what those steps do. **The problem:** Some of the steps need to access external services to get data or maybe even the same or different database where the actual step entities are stored. The information is **usually** used by other steps. One could say that some of the steps are just for loading data from external sources/database and other steps are using that data to make decisions. This separation is done so that we can use different data sources (as long as they produce the same kind of output to us) without the need to write any additional code. Is there a better way to handle this type of domain? If I separate the actual Step and the logic (i.e. loading data from external service or from database) then my whole domain model (steps) doesn't have any logic. I would most likely have something like:               var handler = dictionary[step];     handler.Execute(step, details, data);      **Now the logic and any external dependencies are in the handler object but the actual domain object (step) is just a dummy place holder for the information.** That doesn't sound right either.