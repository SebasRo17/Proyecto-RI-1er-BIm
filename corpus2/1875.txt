First the background. I'm trying to solve for the roots of a rather messy complex equation. This is not the exact equation, but it's a decent (simpler) stand in:               Tan[x - I a] + I == I (x - I a)^(-1/2)      I can use `FindRoot` to solve for a particular root, i.e.               FindRoot[Tan[z] + I == (I) (z)^(-1/2), {z, Pi - .3 I}]      which gives `{z -> 3.08945 - 0.465902 I}`. The thing is, the real part of these equations (as well as the imaginary parts) alone have periodic solutions. For example, look graphically at this solution: ![Mathematica graphics](http://i.stack.imgur.com/oJAna.png) However, realizing that the real roots tend to be spaced roughly at integer factors of $\pi$ (i.e. consider `Tan[x]==x^(-1/2)`), using `FindRoot[Tan[z] + I == (I) (z)^(-1/2), {z, 2 Pi - .3 I}]` indeed gives the next root. However, in the actual equation some roots get spaced un-evenly, and it's possible to miss particular roots when using this guess method. I recognize that another approach to doing this explicitly solves the real and imaginary parts of the equation as simultaneous roots to two real equations:                FindRoot[{Re[Tan[x + I y] + I] == Re[(I) (x + I y)^(-1/2)],         Im[Tan[x + I y] + I] == Im[(I) (x + I y)^(-1/2)]},       {{x, Pi}, {y, -.3}}]      and gives the same result, `{x -> 3.08945, y -> -0.465902}`. Given this info, is there a way to use a `RootSearch`-type function to find _all_ complex (simultaneous) roots to this (these) equation(s) over a particular range of real values **without guessing** each real part of root to be an integer value of $\pi$? **Edit** As an added complication, I actually have two complex equations that I need to solve simultaneously, so if the solution could be generalizeable to allow for this sort of thing, that would be an added bonus. * * * **Also Edit** I've tried a few of the suggestions in the comments and answers below. Some work for the sample case I gave above, but for my actual problem they don't really work. So, I figured may as well give the whole crazy thing I'm trying to solve:                   s1 = {(-2 ky Pi wavelength Cot[           1/2 (b ky + n Pi)] + (km - I nm) (4 Pi^2 +             ky^2 wavelength^2 -             2 ky (km - I nm) Pi wavelength Tan[              1/2 (b ky + n Pi)]))/((km - I nm) wavelength) == 0,                (-2 kx Pi wavelength Cot[           1/2 (a kx + m Pi)] + (km - I nm) (4 Pi^2 +             kx^2 wavelength^2 -             2 kx (km - I nm) Pi wavelength Tan[1/2 (a kx + m Pi)]))/((km - I nm) wavelength) == 0}      This equation needs to be solved for different values for the parameters in this equation `a`, `b`, `wavelength`, etc. Here's a sample:               wavelength = 26 10^-3;     nm = -100;     km = 5;     a = 13 10^-4;     b = 64 10^-5;     m = 1;     n = 0;      Now, if I try               Solve[{Sequence@@s1, Abs[kx] <= 10, Re[kx] >= 0, Abs[ky] <= 10, Re[ky] >= 0}]      I get an error "This system cannot be solved with the methods available to Solve.". However, trying `Sequence@@N@s1` it suggests trying exact input. Similarly, `Reduce` does not work with `N` values, and with exact values takes impossibly long to solve. So, I'm still looking for a _fast_ numerical approach. Perhaps something like J.M. suggested in a comment could be generalized for more than two equations?