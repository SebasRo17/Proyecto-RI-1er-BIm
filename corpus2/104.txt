I used the code below (which is a sample from this gist containing more similar code) in my answer to my own question about Mandelbrot-like sets for functions other than the simple quadratic on Math.SE to generate this image: ![graphic](http://i.stack.imgur.com/pL8nx.png)               cosineEscapeTime =       Compile[{{c, _Complex}},        Block[{z = c, n = 2, escapeRadius = 10 \[Pi], maxIterations = 100},         While[And[Abs[z] <= escapeRadius, n < maxIterations],          z = Cos[z] + c; n++]; n]]          Block[{center = {0.5527, 0.9435}, radius = 0.1},       DensityPlot[       cosineEscapeTime[x + I y], {x, center[[1]] - radius,         center[[1]] + radius}, {y, center[[2]] - radius,         center[[2]] + radius}, PlotPoints -> 250, AspectRatio -> 1,        ColorFunction -> "TemperatureMap"]]      What could I do to improve the speed/time-efficiency of this code? Is there any reasonable way to parallelize it? (I'm running Mathematica 8 on an 8-core machine.) * * * _**edit_** Thanks all for the help so far. I wanted to post an update with what I'm seeing based on the answers so far and see if I get any further refinements before I accept an answer. Without going to hand-written C code and/or OpenCL/CUDA stuff, the best so far seems to be to use `cosineEscapeTime` as defined above, but replace the `Block[...DensityPlot[]]` with:               Block[{center = {0.5527, 0.9435}, radius = 0.1, n = 500},      Graphics[       Raster[Rescale@         ParallelTable[          cosineEscapeTime[x + I y],           {y, center[[2]] - radius, center[[2]] + radius, 2 radius/(n - 1)},            {x, center[[1]] - radius, center[[1]] + radius, 2 radius/(n - 1)}],         ColorFunction -> "TemperatureMap"], ImageSize -> n]      ]      Probably in large part because it parallelizes over my 8 cores, this runs in a little under 1 second versus about 27 seconds for my original code (based on `AbsoluteTiming[]`).