I have a set of loadable data decoders for a specific type of data and a stream to read containing data. Now I want the program to select the correct decoder in a reliable way so I want to use a trial-and-error algorithm. It seems resonable to create a decoder and connect it to the stream using a constructor:               // C++ code     // codecs is an array of structs containing function pointers loaded from a dll     FileIn src("foo.wav");     for(size_t i=0; i<N_CODECS; ++i)         {         try             {             WaveIn wavein(codecs[i],src);             //Process data             return;             }         catch(...) //Swallow error. It's likly that another codec works. But if it were another error??             {             src.reset();             }         }     //no codec found (definitly an error)      Here, there is probably no true error before we have tried all codecs in the list. The reason to try-catch here is that it is not possible to get return code from the ctor. Would it be better to use zombie objects in this case? EDIT: What the constructor does, is the following               WaveIn::WaveIn(Vtable& vt, FileIn& src):m_vt(vt)         {         m_handle=m_vt.create(src);         if(m_handle==NULL) //Resources allocated in DLL were released in this case.              {throw "Bad file";}         }      The dtor:               WaveIn::~WaveIn()         {         m_vt.destroy(m_handle);         }